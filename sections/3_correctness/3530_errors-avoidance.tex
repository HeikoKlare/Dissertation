\section{Detection and Avoidance of Errors}

\todo{Matrix for avoidability (there should be some text for that later): network rule not avoidable, network relation analyzable, transformation achievable by construction}

\todo{Maybe discuss replacement of algorithm with less-restrictive one as in failures section and problem of consistency check by transformation execution again or here instead}

\todo{Insights are, at first, not so interesting. All network mistakes can lead to any kind of failures, depending on the way the algorithm works. But this means, exchanging the algorithm, we can provoke specific failures when we make certain changes. And, additionally, we know about specific failures for mistakes at the transformation level, which is the most interesting part, because those mistakes can be fixes systematically (see sync chapter about construction correctness) and mistakes at the network levels are handled by an appropriate application algorithm anyway. This must be the case anyway, because we need to deal with undecidability of the underlying problem. Thus, the conservative solution to the network level problems is perfectly fine. Especially because we will see in the evaluation that in a case study, most problem occured at the transformation level.}

\todo{Discuss the effect of whether algorithm return bot in consequence of maximal execution number or because transformation could not be applied. If transformation cannot be applied (see level 2 mistake before), this may be an indicator for an actual mistake in the transformations (such as incompatibilities), whereas the abortion because of reaching the execution bound can also be just a conservative abortion because of the undecidability of the orchestration problem.}

Network errors cannot be avoided by construction, thus it good that appropriate orchestration strategy resolves them.
--> Final section: How to handle the errors: Network errors by conservative strategy to fail safely -> we do not reach failure state but detect the failure; transformation errors by construction
--> Trace back failures to errors
--> Termination can always be ensured, then terminating inconsistently; if then, e.g., duplication occur, then can (but must not be) because of missing synchronization. We will see in evaluation that missing synchronization is the main source of duplications.

\todo{Compatibility not achievable by construction, synchronization achievable by construction; rest is orchestration? Only by construction if network is a tree (modularization level)}

\todo{Diskutieren: Was tun im Fehlerfall? Wir sagen einfach, der Transformationsentwickler müsste schauen, aber wie sähe ein entsprechender Prozess aus? -> Out of scope dieser Arbeit -> Future Work}

\todo{Diskutieren, dass man die Fehler auf Level 2 und 3 natürlich gar nicht direkt als Fehler bzgl. unserer Annahmen sehen kann. Das macht es insbesondere sinnvoll diese Fehler per konservativem Algorithmus aufzulösen.}


%At the system level, mistakes can only be avoided by careful requirements elicitation. 
%Since occurring mistakes on that level represent non-conformance with a usually informal notion of consistency, such mistakes cannot be automatically avoided or detected.
At the global level, mistakes occur due to non-conformance with an informal notion of consistency and %cannot be detected automatically but 
can only be avoided by careful requirements elicitation. 
We therefore have to assume that global level mistakes are reliably avoided by the developers.
Analytic approaches~\cite{klare2018docsym}
can ensure that specifications at the modularization and operationalization level are free of faults.
%This can be applied on both the modularization and the operationalization level.
Nevertheless, %under the assumption that transformations are developed independently, 
the drawback of such an approach is that it works a-posteriori, when transformations are combined to a network. %, so transformations would have to be adapted %after their specification 
%when they are combined to a network
We, in contrast, want to achieve avoidance of interoperability issues a-priori, so that transformations can be developed independently and combined afterwards.
It is easy to see that mistakes at the modularization level cannot be avoided a-priori. 
%If modular transformations are developed independently, 
Ensuring that transformations are non-contradictory %, i.e. that they rely on the same notion of a global consistency specification, 
would require developers to have knowledge about the other transformations, which breaks the assumption of independent development.
%This breaks our assumption that developers have restricted domain knowledge, each defining one modular consistency specification.
%
Finally, mistakes regarding element matching at the operationalization level are domain-independent. 
This enables the development of generic mechanisms to ensure interoperability at the operationalization level by construction, without knowing about other transformations.

In the following, we discuss one strategy to avoid mistakes at the modularization and one to avoid those at the operationalization level.
Developers can use these strategies to build networks that are free of faults, or can use them to fix mistakes if failures occur.
