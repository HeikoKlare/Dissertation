\section{Detection and Avoidance of Errors}
\label{chap:errors:avoidance}

\mnote{Error avoidance vs. detection}
There are two ways to deal with the possibility of errors in transformation networks.
First, mistakes can be avoided (a priori), which was the major goal of the discussions and approaches presented in the previous chapters, such that no failures can occur when executing a transformation network or at least failures due to specific mistakes are avoided.
Second, mistakes can be detected (a posteriori) by identifying failures of the transformation network execution.
We have already discussed that how a mistakes manifests depends on the used application algorithm.
An algorithm without an artificial execution bound may fail by non-termination, one without proper consistency checks may fail by returning inconsistent models and a conservative algorithm, such as the provenance algorithm proposed in \autoref{chap:orchestration:algorithm}, may terminate returning $\bot$.

\begin{propertable}
    \rowcolors{1}{\firstlinecolor}{\secondlinecolor}
    \begin{tabular}{C{2.4em}L{7.7em}L{6.7em}L{11.6em}}
        \toprule
        \textbf{Level} & \textbf{Name} & \textbf{Avoidance} & \textbf{Detection} \\
        \midrule
        1 & \LevelTransformation & By construction & Duplicate element creation \\
        2 & \LevelNetworkRelation & By analysis & Any network failure \\
        3 & \LevelNetworkRule & - & Any network failure \\
        \bottomrule
    \end{tabular}
    \caption[Avoidance and detection of mistakes at specification levels]{Avoidance and detection of mistakes at the different levels in the transformation network specification process.}
    \label{tab:errors:avoidance}
\end{propertable}

\mnote{Detection from categorization}
In \autoref{tab:errors:avoidance}, we depict the possibilities of avoiding and detecting mistakes at the different levels in the transformation network specification process.
Avoidability is derived from the discussions in the previous chapters, whereas the detection is a result of the preceding categorization of mistakes and resulting failures.


\subsection{Error Avoidance}

\mnote{Failure absence indicating mistake absence}
In the best case, no failures occur in a transformation network, which means that no mistakes were made at all or at least none of them leads to a failure in a specific scenario.
In fact, a network without mistakes does not mean that no failures occur, because the application algorithm can always fail because of undecidability of the orchestration problem.
Thus, the absence of failures indicates the absence of mistakes, but not vice versa.

\mnote{Mistake avoidance at different levels}
To avoid mistakes, we have already discussed different approaches in the previous chapters.
Associated with the identified specification levels, we can identify at which levels mistakes can be avoided by construction, by analysis, or not at all.
At the \leveltransformation level, correctness requires transformations to be synchronizing.
As discussed in \autoref{chap:synchronization}, this property can be achieved by construction, because it is a property of a single transformation and does not depend on the other transformations to be combined with.
We have also proposed techniques, especially the matching of existing elements, to achieve this correctness by construction.
At the \levelnetworkrelation level, correctness requires consistency relations to be compatible.
As discussed in \autoref{chap:compatibility}, this property can be validated by analysis of the transformations and their consistency relations.
It can, however, not be avoided by construction.
Finally, at the \levelnetworkrule level, we do not have a precise notion of correctness, which makes it impossible to define criteria for avoidance.

\mnote{Avoidance at \leveltransformation level}
Since we assume transformations to be developed independently and reused modularly, it is especially relevant that mistakes at the \leveltransformation level, for which the required knowledge exists, can be avoided by construction.
The necessary knowledge for avoiding mistakes at the \levelnetworkrelation level does actually not exist with that assumption, thus we may not even consider them as actual mistakes.
Finally, the mistakes that cannot be avoided by construction are handled by the proposed use of a conservative application algorithm anyway.
As we have discussed before, consistency checks of transformations may be based on the assumption that consistency is achieved by construction.
Thus, it is important that correctness at the \leveltransformation level is achieved by construction, as otherwise the application algorithm may apply non-synchronizing transformation without detecting that the yielded models are inconsistent, thus returning inconsistent models.

%\todo{Diskutieren, dass man die Fehler auf Level 2 und 3 natürlich gar nicht direkt als Fehler bzgl. unserer Annahmen sehen kann. Das macht es insbesondere sinnvoll diese Fehler per konservativem Algorithmus aufzulösen.}

\mnote{Avoidance by network topologies}
In \autoref{chap:classification}, we will discuss how network topologies affect how prone a transformation network is to the possibility of containing faults.
We will show that an appropriate topology avoids faults at the network levels and thus avoids the possibility that transformation developers can make the discussed mistakes.
We will also discuss in \autoref{chap:improvement} an approach how networks of such a topology can be constructed without the necessity that the direct transformations between the metamodels must have such a specific topology.
Thus, it is also possible to avoid such mistakes by construction, but this limits the networks we can define to specific topologies.

% \todo{Reference to Part 3 for avoiding mistakes at higher levels by using appropriate topology}


\subsection{Error Detection}

\mnote{Tracing between mistake and failure types}
Whenever mistakes are not avoided by construction or analysis, they can be detected by failures of the application algorithm.
The insights regarding the relations between mistakes and failure types may at first not sound interesting, because all mistakes at the two network levels can lead to any kind of failure, depending on how the algorithm works.
And even if a duplication occurs, which is in particular the result of a mistake at the \leveltransformation level, this can also be a consequence of a mistake at the two network levels.
Additionally, the algorithm may not only fail because of mistakes, but also because of undecidability of the orchestration problem.
Still, we can make some relevant conclusions for the detection of errors.

\mnote{Identifying failure cause by model state}
Insights about the causing mistakes can especially be derived from an inconsistent state of the models that the algorithm produced, e.g., by investigating whether this inconsistent state contains duplications of elements.
This is why we proposed the provenance algorithm in \autoref{chap:orchestration:algorithm}, which is supposed to support the process of identifying problems in the transformations that lead to the application algorithm not being able to find a consistent orchestration.
Thus, in case the algorithm fails for specific inputs, it is up to the transformation developer to investigate the state of the models in which the algorithm failed to identify the reason for that.

\mnote{Algorithm exchange to identify mistakes}
Whenever the application algorithm fails, it can be useful to exchange the algorithm with one with different properties.
Thus, if the algorithm does not terminate, it can be useful to introduce an artificial execution bound to be able to produce an inconsistent state of the models.
These inconsistent models can also be retrieved from a conservative algorithm as proposed in \autoref{chap:orchestration:algorithm}, which is specifically developed to improve the ability to find the reasons for the algorithm not to find consistent models.

\mnote{Duplications indicate missing synchronization}
The occurrence of duplications is a specific indicator for missing synchronization.
They can occur in inconsistent returned models produced by the algorithm and will most likely occur because of missing synchronization.
In our evaluation in \autoref{chap:correctness_evaluation}, we will see that in the investigated case study duplications occurred because of missing synchronization in most cases or can at least be distinguished from duplications caused by other mistakes.

\mnote{Failure frequency indication}
If the algorithm fails for most inputs in any way, this may be an indicator that the algorithm is not only unable to yield consistent models because of the orchestration problem, but because some essential mistakes prevent it from from finding consistent models, such that, in the worst case, no consistent orchestration exists at all.
Thus, an often failing algorithm may be an indicator for, among others, incompatibilities.

\mnote{Identifying failure cause by returning $\bot$}
It may make a difference whether a conservative algorithm fails returning $\bot$ because the maximal number of executions was reached, or because a transformation could not be applied anymore.
While the inability to apply a transformation can be seen as an indicator for an actual mistake within the transformations (such as the \levelnetworkrelation level error in \autoref{fig:errors:mistake_effects_example_cases}), the abortion because of reaching the execution bound can also be just the conservative behavior to avoid non-termination because of the undecidability of the orchestration problem.

\mnote{Unique identification of fault existence}
Finally, in the best case errors are avoided by construction, especially potential mistakes at the \leveltransformation level.
At the network levels, mistakes cannot be avoided but, in the best case, analyzed.
Since we need a conservative application algorithm anyway, it does also ensure that such mistakes do not lead to unwanted results.
In the worst case, the algorithm will only be able to yield consistent models in few or even no cases.
Then the transformation developer must investigate the state of the models with which the algorithm fails to identify the reasons.
Although there are several indicators for the existence of faults, it cannot be uniquely distinguished whether the application algorithm fails because of undecidability of the orchestration problem or because actually the transformations contain a fault.
Since we assume independent development and reuse of transformations, the focus on avoiding mistakes at the \leveltransformation level and the handling of mistakes at the network levels by a conservative algorithm fits well to that context assumption.


% \todo{Mistake leads to specific failures, especially missing synchronization, but failure must not be because of specific mistake. In all cases, algorithm can fail because of undecidability of orchestration problem. However, duplications (in an aborted state or inconsistent returned state) can indicate missing synchronization. Additionally, failing for most inputs, it is likely that the algorithm is not only unable to find consistent models but that some mistakes in the transformations, such as incompatibility, lead to them.
% Consequence: We should in best case avoid them by construction or analysis, as they cannot be uniquely identified in failing networks.}

% \todo{Maybe discuss replacement of algorithm with less-restrictive one as in failures section and problem of consistency check by transformation execution again or here instead}

% \todo{Insights are, at first, not so interesting. All network mistakes can lead to any kind of failures, depending on the way the algorithm works. But this means, exchanging the algorithm, we can provoke specific failures when we make certain changes. And, additionally, we know about specific failures for mistakes at the transformation level, which is the most interesting part, because those mistakes can be fixes systematically (see sync chapter about construction correctness) and mistakes at the network levels are handled by an appropriate application algorithm anyway. This must be the case anyway, because we need to deal with undecidability of the underlying problem. Thus, the conservative solution to the network level problems is perfectly fine. Especially because we will see in the evaluation that in a case study, most problem occured at the transformation level.}

% \todo{Discuss the effect of whether algorithm return bot in consequence of maximal execution number or because transformation could not be applied. If transformation cannot be applied (see level 2 mistake before), this may be an indicator for an actual mistake in the transformations (such as incompatibilities), whereas the abortion because of reaching the execution bound can also be just a conservative abortion because of the undecidability of the orchestration problem.}

% Network errors cannot be avoided by construction, thus it good that appropriate orchestration strategy resolves them.
% --> Final section: How to handle the errors: Network errors by conservative strategy to fail safely -> we do not reach failure state but detect the failure; transformation errors by construction
% --> Trace back failures to errors
% --> Termination can always be ensured, then terminating inconsistently; if then, e.g., duplication occur, then can (but must not be) because of missing synchronization. We will see in evaluation that missing synchronization is the main source of duplications.

% \todo{Compatibility not achievable by construction, synchronization achievable by construction; rest is orchestration? Only by construction if network is a tree (modularization level)}

%\todo{Diskutieren: Was tun im Fehlerfall? Wir sagen einfach, der Transformationsentwickler müsste schauen, aber wie sähe ein entsprechender Prozess aus? -> Out of scope dieser Arbeit -> Future Work}

%At the system level, mistakes can only be avoided by careful requirements elicitation. 
%Since occurring mistakes on that level represent non-conformance with a usually informal notion of consistency, such mistakes cannot be automatically avoided or detected.
% At the global level, mistakes occur due to non-conformance with an informal notion of consistency and %cannot be detected automatically but 
% can only be avoided by careful requirements elicitation. 
% We therefore have to assume that global level mistakes are reliably avoided by the developers.
% Analytic approaches~\owncite{klare2018docsym}
% can ensure that specifications at the modularization and operationalization level are free of faults.
% %This can be applied on both the modularization and the operationalization level.
% Nevertheless, %under the assumption that transformations are developed independently, 
% the drawback of such an approach is that it works a-posteriori, when transformations are combined to a network. %, so transformations would have to be adapted %after their specification 
% %when they are combined to a network
% We, in contrast, want to achieve avoidance of interoperability issues a-priori, so that transformations can be developed independently and combined afterwards.
% It is easy to see that mistakes at the modularization level cannot be avoided a-priori. 
% %If modular transformations are developed independently, 
% Ensuring that transformations are non-contradictory %, i.e., that they rely on the same notion of a global consistency specification, 
% would require developers to have knowledge about the other transformations, which breaks the assumption of independent development.
% %This breaks our assumption that developers have restricted domain knowledge, each defining one modular consistency specification.
% %
% Finally, mistakes regarding element matching at the operationalization level are domain-independent. 
% This enables the development of generic mechanisms to ensure interoperability at the operationalization level by construction, without knowing about other transformations.

% In the following, we discuss one strategy to avoid mistakes at the modularization and one to avoid those at the operationalization level.
% Developers can use these strategies to build networks that are free of faults, or can use them to fix mistakes if failures occur.
