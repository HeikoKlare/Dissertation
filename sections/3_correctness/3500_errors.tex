\chapter{Classifying Errors in Transformation Networks 
    \pgsize{20 p.}
}
\label{chap:errors}

\mnote{Discuss error as the result of failing in achieving correctness}
In the previous chapters, we have introduced a notion of correctness for transformation networks and discussed how we can achieve or analyze different kinds of correctness for the different artifacts of the transformation network, namely the consistency relations, the consistency preservation rules and the application function.
It may, however, easily occur that a transformation developer defines transformations that do not adhere to all these kinds of correctness, be it because of missing knowledge about them or by accident.

\mnote{Classification of consistency specification and categorization of errors}
In this chapter, we thus discuss what may happen if correctness was not achieved.
The possible types of errors that can occur depend on the abstraction level provided by the formalism or language to specify a transformation in.
We thus first propose a classification of specification levels for transformations.
We then systematically derive a categorization of potential \emph{failures}, i.e., the unwanted results the application algorithm may yield, the \emph{faults} that led to the mistakes, i.e., the errors in the implementation of the transformation, and finally the causing \emph{mistakes}, i.e. the errors made by a developer when analyzing and defining consistency that led to an implementation fault.
Finally, we relate the possible types of mistakes, faults and failures to the correctness notions that we have introduced before to evaluate how far the proposed solutions can avoid those errors.

\mnote{Subordinate contributions}
This chapter thus constitutes our contribution \contributionref{contrib:correctness:errors}, which consists of three subordinate contributions: a classification of consistency specification levels, a categorization of potential errors, and a relation of the categorization to the yet discussed correctness notions and measures to achieve them.
\todo{Finally update goals}
It answers the following research question:

\researchquestionrepeat{rq:correctness:errors}

\mnote{Benefits of contributions}
As the central goal of this chapter, we classify the possible types of errors to derive systematic knowledge about mistakes that can be made and failures that can arise from them.
First, this helps transformations developers to identify the reasons for arising failures.
Second, it allows us to identify which relevant errors we can avoid or detect with the approaches proposed in the previous chapters and how relevant the problems that we solve with them are.
The latter will be part of our subsequent evaluation at a case study.

\mnote{Publication of results}
Several of the insights regarding errors in transformation networks are results of the two master's theses by \textcite{syma2018ma} and \textcite{saglam2020ma}, who investigated errors that occurred when combining independently developed transformations in two case studies.
Essential results from the former thesis were published in \owncite{klare2019icmt} and are part of the following discussion in revised form.

%Problem statement: We now know what correctness means and how to constructively achieve or at least analyze it. We, however, want to know what may happen if correctness was not achieved by any reason.
%We want to have systematic knowledge what kinds of problems can occur, what types of reasons there are and how they manifest.
%We want to derive how many of the typical problems we can systematically resolve with our contributions, i.e., how relevant the problems that we solve are (how often they occur).


Network errors cannot be avoided by construction, thus it good that appropriate orchestration strategy resolves them.
--> Final section: How to handle the errors: Network errors by conservative strategy to fail safely -> we do not reach failure state but detect the failure; transformation errors by construction
--> Trace back failures to errors
--> Termination can always be ensured, then terminating inconsistently; if then, e.g., duplication occur, then can (but must not be) because of missing synchronization. We will see in evaluation that missing synchronization is the main source of duplications.

Failures can occur because of different conceptual and technical mistakes.
We do not consider technical mistakes, e.g., missing handling of null or comparable things.
We do not consider conceptual mistakes regarding correctness of a single transformation (unidirectional). I.e., if a single transformation does not ensure consistency in one direction appropriately, we do not consider that a relevant mistake. Mistakes regarding synchronization, however (occurring with concurrent changes but not changes in one of the models), are relevant.
We assume that transformations are correct, i.e., CPRs correct w.r.t. their relations

Inkompatible Constraints und inkompatible Optionsauswahl lässt sich oft gar nicht unterscheiden, insb. wenn Constraints nicht explizit angegeben sind. Dann sind Constraints implizit durch CPRs definiert. Es könnte aber auch sein, dass die (vom Entwickler gedachten) Constraints relaxierter sind und dann das Problem die Optionsauswahl ist und nicht die Inkompatibilität von Constraints.

\todo{Unterschied Klassifizierung/Kategorisierung: Klassifizierung benötigt Klassifizierungsdimension, Kategorisierung nicht}
Klassifizierung: Wir packen Spezifikationsszenarien in vordefinierte Klassen, entsprechend ihrem Abstraktionsgrad
Kategorisierung: Wir identifizieren Kategorien von Mistakes/Faults/Failures und diskutieren deren Vollständigkeit
Im Unterschied sind bei der Kategorisierung die Kategorien vorher nicht bekannt.

\todo{Discuss problem of default values}

Weitere Fehlertypen diskutieren / explizit ausschließen, insb. Implementierungsfehler, technische Fehler. Diese führen i.d.R. aber auch dazu, dass eine Transformation nicht korrekt ist.
Wir nehmen wir Korrektheit einer Transformation an!
In der Evaluation werden wir das noch entsprechend unterscheiden.

\todo{Ziel dieses Kapitels: Wie hängen Korrektheitsdefinition voneinander ab (Hierarchie/Ebenen), was passiert, wenn einzelne Korrektheiten nicht erfüllt sind? Welche Fehler treten auf? Und wie häufig passiert das? (Letzteres eher als Evaluation verkaufen)}

\todo{Compatibility not achievable by construction, synchronization achievable by construction; rest is orchestration? Only by construction of network is a tree (modularization level)}

\todo{Discuss errors by two unidirectional transformations not adhering to the same consistency relation, which we already teasered in \autoref{chap:synchronization} and have seen in the case study}



\section{The Consistency Specification Process}
\todo{Process and levels from ICMT to identify how levels depend on each other (restructure according to relations (compatibility), individual transformations and networks), and derive which errors occur and how they depend on each other}

The process of specifying consistency between multiple models can be considered at different conceptual levels depending on the knowledge a developer must have to ensure correctness at that level.
For example, at the lowest level a developer may only know that a transformation shall be used within a network without knowing the concrete network, which only allows to exclude specific errors, whereas further errors are relevant and need to be considered when having knowledge about the other transformations to combine it with.
In addition, depending on the level of abstraction that a specification formalism, such as a transformation language, provides, the developer must only deal with some of these levels as the language abstracts from the other, which determines the resulting challenges a developer has to deal with.
%In \autoref{chap:correctness:notions_consistency:monolithic_modular}, we have introduced the separation between a modular and monolithic notion of consistency.
%Although we focus on a modular notion of consistency in this thesis, we will see how a monolithic notion relates to the error potentials of modular specifications.
In consequence, these levels are supposed to mean that at each of them specific kinds of mistakes can be made and that a formalism may ensure correctness with respect to one of those levels and the ones below, whereas the transformation developer is still responsible for avoiding mistakes at the levels above.
%even if abstraction is lifted to that appropriate level, thus correctness as the lower levels is ensures, specific potential mistakes can still be made.

\begin{table}
    \small
    \begin{tabular}{C{2.4em}L{4em}L{12em}L{10em}}
        \toprule
        \textbf{Level} & \textbf{Name} & \textbf{Correctness} & \textbf{Knowledge} \\
        \midrule
        1 & Transformation & synchronizing transformations & individual transformation \\[1em]
        2 & Network Relation & compatible consistency relations & consistency relations of complete network \\[1em]
        3 & Network Rule & interoperable consistency preservation rules & transformations of complete network\\
        \bottomrule
    \end{tabular}
    \caption[Knowledge levels in transformation network specification]{Distinguished levels in the transformation network specification process with their correctness criteria and required knowledge.}
    \label{tab:errors:levels}
\end{table}
\newcommand{\leveltransformation}{transformation\xspace}
\newcommand{\levelnetworkrelation}{network relation\xspace}
\newcommand{\levelnetworkrule}{network rule\xspace}

We distinguish three such levels, which we summarize in \autoref{tab:errors:levels}, together with their properties, which we discuss in the following.
%They are supposed to mean that even if abstraction is lifted to that appropriate level, thus correctness as the lower levels is ensures, specific potential mistakes can still be made.
%At the \emph{global level}, we consider the ($n$-ary) relation and/or transformation between all involved models.
%At the \emph{modularization level}, we consider the combination of modular, binary relations and synchronizing transformations between the involved models.
%At the \emph{transformation level}, we consider the synchronization of transformation between two models.
%
At the \emph{\leveltransformation level}, we consider the specific properties, especially synchronization, of a single transformation to be used in a, more precisely any, transformation network.
At the \emph{\levelnetworkrelation level}, we consider the interplay of the binary consistency relations of a concrete set of transformations.
At the \emph{\levelnetworkrule level}, we consider the interplay of the consistency preservation rules of a concrete set of transformations.
These levels depend on each other, because, for example, consistency preservation rules cannot properly work together if each on its own is not at least synchronizing and thus correct at the \leveltransformation level.
On the other hand, a transformation can be correct at the \leveltransformation level without being correct at the relation and \levelnetworkrule level.

These levels are especially different in what knowledge they require to be able to deal with and even avoid potential errors.
For the \leveltransformation level, it is sufficient to know that a transformation may be used in a transformation network without knowing the concrete network.
For the \levelnetworkrelation level, at least the relations of the other transformations in the network must be known.
Finally, for the \levelnetworkrule level, the transformations of the complete network must be known.
This influences how far errors at the different levels can be avoided, first, because of the required knowledge to do so and, second, because of the possibility to ensure correctness at all.
% Remark: correctness for rules -> decidability

%\todoHeiko{Annahme: Immer nur Änderung an einem Modell (keine Synchronisation)}

%The process of specifying consistency between $n>2$ types of models using a network of \acp{BX} can be separated into different conceptual levels.
%We distinguish three such levels:
%At the \emph{global level}, we describe the ($n$-ary) relations between all involved model types.
%At the \emph{modularization level}, we split these global relations into modular, binary relations.
%Finally, at the \emph{operationalization level}, we define preservation of consistency %after changes 
%according to the modular relations.
%That classification forms our contribution \ref{contrib:levels}.

%All of these levels have to be considered during the consistency specification process.
%A developer specifies consistency on one of these levels, depending on the abstraction level that the transformation language provides, and the transformation engine finally derives an operationalization from that.
%Although a developer does not specify consistency on multiple levels, he or she has to think about the levels on and above the one consistency is specified on.
%For example, to define an operationalization, the developer must be aware of the modular consistency relations.
%If a developer only specifies the modular consistency relations, the transformations engine has to derive an appropriate operationalization.
%In the end, to preserve consistency, an operationlization has to be derived from a specification on any of those levels.
%The benefit of clearly separating these levels is that they have different potentials for mistakes, faults, and resulting failures. 
%Consequently, avoiding a specific kind of mistake, which is related to one of the identified levels, completely prevents a specific category of failures.
%We exemplify these levels in \autoref{fig:properties:levels_overview} and explain them in more detail in the following.

%\todoHeiko{Give an example for mistakes here! Maybe one example for every level as well?}

\subsection{Consistency Specification Levels}
%\label{chap:properties:levels}

In the following, we introduce the three mentioned levels more precisely.
They represent a revised version of the three levels we have presented in \owncite{klare2019icmt}.
In that work, we have discussed the \emph{global} level, which considers the global knowledge in terms of the overall, $n$-ary relation between all involved models.
We have, however, discussed different correctness notions in \autoref{chap:correctness:notions_correctness} and argued why we do not consider a \emph{monolithic} notion of consistency, which conforms to the \emph{global} specification level, as we do not assume this global knowledge to be represented explicitly, such that it would make sense to explicitly consider correctness according to it.


%\begin{figure}
    %\centering
%    \includegraphics[angle=-90, width=\textwidth]{figures/levels_overview.pdf}
%    \input{figures/properties/levels_overview.tex}
    %\caption{Examples for Abstraction Levels in the Consistency Specification Process}
    %\label{fig:properties:levels_overview}
%\end{figure}

%\todoHeiko{Definieren was Correctness auf jedem der Levels heißt. System: Richtig bzgl. den tatsächlichen Konsistenzbeziehungen, Modularization: Richtig bzgl. der globalen Spezifikation, Operationalization: Korrekte Ergebnisse nach Änderungen bzgl. der modularen Spezifikationen}

\subsubsection*{Level 1 (\emph{\leveltransformation}):}
At the first level, we do only consider the knowledge that a transformation shall be used in a transformation network.
According to our formalism presented in \autoref{chap:correctness:formalization}, this means that the transformation needs to be \emph{synchronizing}.
We have discussed in \autoref{chap:synchronization} how synchronization can be achieved with ordinary transformation languages.
Correctness at this level is given by the fulfillment of the synchronization property for a transformation.

\subsubsection*{Level 2 (\emph{\levelnetworkrelation}):}
At the second level, we consider the knowledge about the concrete network in which the transformations shall be used, but restricted to their relations.
In consequence, it would be possible that the relations between all models are known, e.g., because there is a common understanding of the relations, which may also be documented.
We have discussed in \autoref{chap:compatibility} that \emph{compatibility} is a relevant property of the consistency relations in a transformation network to ensure that the transformations are able to find consistent models after changes.
Correctness at this level is thus given by the consistency relations being compatible.

\subsubsection*{Level 3 (\emph{\levelnetworkrule}):}
At the third level, we consider the knowledge about the complete transformations of a concrete network, thus especially also the consistency preservation rules that preserve consistency.
We have discussed in \autoref{chap:orchestration} the problem of orchestrating these rules and also discussed several issues that may prevent an algorithm from finding a consistent orchestration, such as the selection of an option from different possibilities provided by a consistency relation to restore consistency.

% At the most abstract level, we consider the knowledge about all actual consistency relations between the involved model types.
% This knowledge can be represented by an $n$-ary relation between all model types, containing all tuples of consistent instances of the $n$ model types according to a consistency specification (\autoref{def:consistency_specification}). 
% We refer to this as a \emph{global} consistency specification.

% \subsubsection*{Level 2 (\emph{Modularization}):} 
% At the second level, the global knowledge of the first level is separated into partial, binary consistency relations that, in combination, represent the overall knowledge about consistency in the system.
% These relations should not contain any contradictions.
% We do not necessarily need to describe relations between all pairs of model types, since some may not share information that may become inconsistent, or some may be represented transitively across other relations.
% %This does also comprise the selection of a network structure that is capable of representing the full system knowledge.
% %Mathematically speaking, on this level the knowledge on this level 
% This knowledge 
% can be represented by up to $\frac{n*(n-1)}{2}$ binary relations, each containing all pairs of instances of two of the model types that are consistent.
% This corresponds to a set of binary consistency specifications according to \autoref{def:consistency_specification}.
% We refer to these as \emph{modular} consistency specifications.\\[-1em]

% \noindent\textit{Remark:} 
% %\begin{remark*}
% Although in theory not all kinds of $n$-ary relations can be separated into binary relations~\cite{stevens2020BidirectionalTransformationLarge-SoSym}, we assume that all consistency relations considered in an automated consistency preservation process can be expressed by binary relations.
% We shortly discussed why this is a reasonable assumption in \autoref{chap:properties:terminology}.
%As stated by \textcite{stevens2020BidirectionalTransformationLarge-SoSym}, this is a reasonable assumption, because it is hard enough for people to think about and specify binary relations.
%Additionally, the separation into binary relations is the extreme case, which we explicitly consider here, nevertheless our finding also apply to a modularization into consistency specifications of higher arity.
%\end{remark*}

%\todoHeiko{Definieren, wie man mit mehrere CPS Konsistenz erreicht -> Zum Ziel der Arbeit kommen, dass man modulare CPS bel. Veschalten kann, um zu Konsistenz zu kommen.}  
% \subsubsection*{Level 3 (\emph{Operationalization}):}
% At this level, the consistency preservation is operationalized in terms of binary consistency preservation specifications according to \autoref{def:consistency_preservation_specification}. % for modular consistency specifications %after \autoref{def:consistency_specification} 
% %on the second level.
% %This requires the definition of update operations that restore consistency after user changes.
% As discussed in \autoref{chap:properties:terminology}, we consider a set of consistency preservation specifications that can be composed to restore consistency.
% In contrast to a single \ac{BX}, an operationalization in %arbitrary
% networks of \acp{BX} has to deal with confluence of information.
% This can lead to problems, such as overwrites or duplications of information, whenever a change can be propagated across at least two paths in the network of \acp{BX} to the same model.
% %It especially requires an identification of matching elements in different consistency preservation specifications to avoid duplicate element creations or insertions. 
% %For example, if an element is propagated from a model of $\mathcal{M}_1$ to a model of $\mathcal{M}_2$ and from this model to one of $\mathcal{M}_3$, then an additional consistency preservation specification from $\mathcal{M}_1$ to $\mathcal{M}_3$ must consider the already existing element instead of creating an additional or overwriting the existing one.
% We have seen an example, in which such multiple transformation paths cannot be avoided, in \autoref{fig:properties:motivational_example}.
%We refer to these as modular consistency preservation specifications.

%\todoHeiko{Maybe call this recombination of modularized knowledge? Makes fokus more on operationalization/ consistency preservation, as that is where the problems occur}
%Mathematically speaking, on this level consistency preservation specifications according to \autoref{def:consistency_preservation_specification} are defined, which adhere to the consistency specifications according to \autoref{def:consistency_specification} on the second level.
%Mathematically speaking, this is the step from a consistency specification of relations to a consistency preservation specification of restore functions.
%We refer to these as modular consistency preservation specifications.
%OLD: partial knowledge (adding information to make partial specifications combinable without knowing about the others)


\subsection{Abstraction to Specification Levels}

All three levels are relevant during the specification process of a transformation network and potential mistakes that can be made on each of them need to be avoided.
As mentioned before, a specification formalism, usually a transformation language, provides a specific level of abstraction associated with one of the conceptual levels introduced above, which relieves the developer from dealing with potential problems of the lower levels.
He or she must, however, still ensure correctness with respect to all higher levels.

At the lowest level, a transformation language does not ensure correctness regarding any of the levels.
For example, an imperative imperative, unidirectional transformation language requires the developer to ensure synchronization of transformations at the \leveltransformation level, compatibility of the relations at the \levelnetworkrelation level, as well as interoperability of the consistency preservation rules at the \levelnetworkrule level.
Rather declarative, usually bidirectional transformation languages already relieves the developer from specifying consistency preservation rules and lifts the abstraction to consistency rules, from which consistency preservation rules are automatically derived.
Some of those language even relieve the developer from manually ensuring synchronization, for example, using keys for matching existing elements in \gls{QVTR}.
In this case, the transformation engine ensures correctness at the \leveltransformation level, but the developer still has to ensure it for the other levels.
Then, the developer must only deal with potential problems arising at the higher levels.
Integrating an analysis for compatibility, such as the one proposed in \autoref{chap:compatibility}, to \gls{QVTR} could thus also abstract from the \levelnetworkrelation level.

Languages that ensure correctness at higher levels than the \leveltransformation level are currently rather unusual.
This requires either the specification of multidirectional transformations, i.e., a less modular or even monolithic notion of consistency (see \autoref{chap:correctness:notions_correctness}), or at least additional analysis functionality integrated into the languages to, for example, ensure compatibility and thus correctness at the \levelnetworkrule level.
For example, multidirectional \gls{QVTR}~\cite{macedo2014FrameworkMultiDirectional-BX} or extensions of \glspl{TGG} to multiple model~\cite{trollmann2015TransformationTGGtoMultiModel-ICMT,trollmann2016SynchronizationTGGtoMultiModel-ICMT} or to \glspl{MGG}~\cite{konigs2006MGGs-sosym} provide means to define rules between multiple models, from which then consistency preservation rules between two models are derived, thus abstracting from the problems of ensuring rule compatibility and interoperability of consistency  preservation rules.
The \commonalitieslanguage~\cite{gleitze2017a}, which we present in detail in \autoref{chap:commonalities}, also lifts the abstraction such that the relation and \levelnetworkrule level must not be considered by the transformation developer.
This is, however, achieved by a specific network topology induced by that language, which avoids several of the problems that we discussed for networks of arbitrary topologies.

Correctness at the higher conceptual levels always requires correctness at the lower levels.
Especially the interoperability of transformations at the \levelnetworkrule level requires the transformations to be synchronizing, i.e., correct at the \leveltransformation level, and the relations to be compatible, i.e., correct at the \levelnetworkrelation level.
In fact, compatibility of the relations does not require the transformations to be synchronizing, i.e., theoretically the \levelnetworkrelation level does not require correctness at the \leveltransformation level.
It does, however, not make sense from a knowledge perspective to ensure compatibility of relations when the transformations that ensure them are not even synchronizing, because synchronization of a transformation can already be ensured independent from the other transformations to combine it with, whereas this knowledge is required for ensuring compatibility.

% A transformation language finally derives a consistency preservation specification from a specification on any of the levels and executes it. %specification is finally transformed into a consistency preservation specification by a transformation language, no matter on which level it is specified.
% Imperative transformation languages expect specifications at the operationalization level, whereas rather declarative, usually bidirectional transformation languages expect specification at the modularization level.
% Specifications at the global level are rather unusual, but could for example be expressed with multidirectional QVT-R~\cite{macedo2014FrameworkMultiDirectional-BX}, or the Commonalities language~\cite{gleitze2017a}.
% A specification must finally be free of mistakes that can be made on any of those levels. 
% The responsibility depends on the abstraction level the transformation language provides, as the developer is responsible for avoiding mistakes at or above the level at which he or she specifies consistency, whereas the transformation language is responsible for those below.

% Specifications must especially be correct regarding all higher levels.
% This means that an operationalization in consistency preservation specifications must preserve consistency according to the underlying modular consistency specifications.
% So after changing a consistent set of models, the consistency preservation has to return another set of models that is consistent again, as shown in \autoref{fig:properties:levels_overview}.
% Additionally, modular consistency specifications must be correct regarding the global specification in the sense that it must contain the same sets of models as the global specification. %exactly those sets of models that are in the relation of the modular specification are in the one of global specification.
% Finally, the global consistency specification has to be correct regarding some, usually informal, notion of consistency for the considered model types.
% Since this can usually not be validated, we assume a global specification to be correct. %made the assumption of having normative consistency specifications.
% This conforms to the notion of \emph{correctness} already defined for \acp{BX}~\cite{stevens2010sosym}, but is used for the extension to networks of \acp{BX} here.

% A specification on one level must always be correct regarding all higher levels.
% This means, for example, that an operationalization in consistency preservation specifications must preserve consistency according to the underlying modular consistency specifications.
% So after changing a consistent set of models, the consistency preservation has to return another set of models that is consistent again, as shown in \autoref{fig:levels_overview}.
% Additionally, modular consistency specifications must be correct regarding the global specification in the sense that it must contain the same sets of models than the global specification. %exactly those sets of models that are in the relation of the modular specification are in the one of global specification.
% Finally, the global consistency specification has to be correct regarding some, usually informal notion of consistency for the considered model types.
% Since this can usually not be validated, we assume a global specification to be correct. %made the assumption of having normative consistency specifications.

% To preserve consistency for a set of models, all specification levels have to be considered.
% A developer defines a concrete specification on one of these levels, which usually depends on the used transformation language and especially the level of abstraction it provides.
% He therefore has to consider all levels on and above the one he specifies consistency on to ensure correctness, and especially has to avoid mistakes that can be made on those levels.
% On the other hand, the transformation language abstracts from all levels below the one consistency is specified on, and especially has to avoid all mistakes that can be made there.
% In the end, %for correct consistency preservation, 
% all mistakes on all levels must be avoided, but the responsibility depends on the level consistency is specified on.


% %Depending on level on which consistency is defined, potentials mistakes that can be made on one of the levels either have to be avoided by the developer or by the used transformation language and its engine.
% %The developer must avoid all mistakes that can arise from the conceptual levels on and above the one he specifies consistency one, whereas the transformation language must ensure that no mistakes occur on the lower levels, which it abstracts from.
% Imperative transformation languages expect specifications on the operationalization level, which means that the transformation developer has to ensure that he makes no mistakes on the Levels 1--3.
% Rather declarative, usually bidirectional transformation languages expect specifications on the modularization level, as they abstract from the operationalization. In that case, the developer must only deal with potential mistakes from Level 1--2 and possible operationalization mistakes have to be handled by the language and its engine.
% Finally, specifications on system level are rather unusual, but could for example be expressed with multidirectional QVT-R~\cite{macedo2014FrameworkMultiDirectional-BX}, or the Commonalities language~\cite{gleitze2017a}. % or the domain-specific DUALLY approach~\cite{eramo2012a}. %Nevertheless, knowledge about the overall consistency constraints in the system is still important, even when providing a specification on a lower level.
% \todoHeiko{Die letzten beiden Abschnitte möglicherweise tauschen, da im letzten eingängier erklärt wird, wie die Ebenen voneinandern abhängen. Der mittele Abschnitt ist sehr schwer verständlich.}
% %As we are focused on networks of \acp{BX}, whose specification happens on the modularization or operationalization level, we are especially concerned with those two levels. 
% %We therefore assume that the developer ensures that no mistakes on the system level are made by knowing about



\section{Issues in Transformation Networks}

\todo{Matrix for avoidability (there should be some text for that later): network rule not avoidable, network relation analyzable, transformation achievable by construction}

In this section, we %first identify and 
categorize potential \emph{failures} that can occur when executing \acp{BX} in a network to preserve consistency.
We then consider \emph{mistakes} that a developer can make and that lead to \emph{faults} in the specifications of consistency and its preservation.
\todo{Heißt der folgende Satz nicht, dass auf jeder Ebene genau ein Typ von Fehler auftreten kann?}
We derive them from the specification levels introduced in \autoref{chap:properties:levels}, as each kind of mistake is specific for one of those levels.
We finally relate the mistakes to the failures that can occur while executing the operationalization of a faulty consistency specification.
That categorization forms our contribution \ref{contrib:issues}.
In the following, we only discuss failures and their causing mistakes, but no strategies to solve or avoid them.
Such strategies are discussed in \autoref{chap:prevention}.
%The identification and categorization in this section is based on argumentation. To show the correctness of identified mistakes, failures and their dependencies, we provide an appropriate evaluation in \autoref{sec:evaluation}.

%\todoHeiko{Introduce mistake, fault, failure} 

% \begin{itemize}
%     \item Define three essential abstraction levels in the development process
%     \item Levels depend on each other, so \emph{fulfillment} on one level is mandatory to investigate the next level
%     \item Mistakes on all levels may introduce failures in the execution of the operationalization of consistency constraint preservation
%     \item We summarize potential failures, identify their causes (mistakes and faults) and then categorize and relate them
% \end{itemize}

\subsection{Mistakes, Faults and Failures}
\todo{Introduce terms}

\subsection{Potential Failures}
\label{chap:errors:failures}

Mistakes in the specification of consistency, no matter on which of the specification levels, % (\autoref{sec:process:levels}),
can lead to failures when executing the preservation of consistency according to that specification. % on an actual system. 
Before identifying the causal mistakes, we first categorize the types of potential failures into three categories. We depict them in \autoref{fig:correctness:categorization}.

\begin{figure}
    \centering
    \input{figures/correctness/categorization.tex}
    \caption{Categorization and Dependencies of Mistakes, Faults and Failures}
    \label{fig:correctness:categorization}
\end{figure}

First, consistency preservation can fail by \textbf{resulting in an inconsistent state}. This can either occur \emph{deterministically} or \emph{non-deterministically}, if the result depends on the execution order of the consistency preservation specifications.

Second, consistency preservation can fail by \textbf{not terminating}. This can either manifest in an \emph{alternating loop}, when a feature, e.g., an attribute, alternates between two or more values, or in a \emph{diverging loop}, when at least one feature value diverges, e.g., a number counting up or a string being repeatedly appended.

Third, consistency preservation can result in \textbf{duplications}. \emph{Multiple instantiation} can occur because different consistency preservation specifications instantiate an element multiple times, although all of them represent the same element. % and thus should be the same. 
For example, an element is created by transformations $\mathcal{M}_1 \rightarrow \mathcal{M}_2 \rightarrow \mathcal{M}_3$ and another is created by transformation $\mathcal{M}_1 \rightarrow \mathcal{M}_3$, although there should be only one element.
\emph{Multiple referencing} can occur due to the same reason because an element is inserted into a reference or attribute list several times, although it should be inserted only once. 
%Such duplications are a special kind of termination in inconsistent states.


% If mistakes are made during the specification of consistency, no matter on which of the levels introduced in \autoref{sec:process:levels}, this can finally lead to failures in the consistency preservation executed on an actual system. Before identifying the causing mistakes, we first give an overview on the types of failures that may occur and separate them into three categories.\\[-0.7em]

% \compactsubsection{Termination in inconsistent states}
% \begin{enumerate}[topsep=4pt]
%     \item \emph{Deterministic:} The consistency preservation process can deterministically terminate in a state that is not consistent. % wrt. the defined consistency specification.
%     \item \emph{Non-deterministic:} Consistency preservation can non-deterministically terminate in an inconsistent state, depending on the execution order of the binary consistency preservation specifications. %in which the partial consistency preservation rules are executed.
% \end{enumerate}

% \compactsubsection{Non-termination}
% \begin{enumerate}[resume, topsep=4pt]
%     \item \emph{Alternating loops:} Consistency preservation can be non-terminating, alternating between two or more values in at least one feature (e.g. a number or a String alternating between two values).
%     \item \emph{Diverging loops:} Consistency preservation can be non-terminating, having at least one feature with a diverging value (e.g. a number counting up or down, a String being always appended).
% \end{enumerate}

% \compactsubsection{Duplications}
% \begin{enumerate}[resume, topsep=4pt]
%     \item \emph{Multiple instantiation:} An element can be instantiated multiple times by different consistency preservation specifications, although all of them represent the same element and thus should be the same. E.g. an element is created by transforamtions $\mathcal{M}_1 \rightarrow \mathcal{M}_2 \rightarrow \mathcal{M}_3$ and another is created by transformations $\mathcal{M}_1 \rightarrow \mathcal{M}_3$, although the same element is meant.
%     \item \emph{Multiple referencing:} An element may also be inserted into a non-containment reference or an attribute list several times, although the same element is meant, within the same situations as multiple instantiation can occur.
% \end{enumerate}


\subsection{Mistakes and Faults}
\label{chap:errors:mistakes}

%\todoErik{Ich dachte immer, \enquote{Mistakes} machen nur Menschen}
Developers or the transformation engine can make different kinds of mistakes on each of the specification levels, which lead to faults in the specification and finally to different kinds of failures during consistency preservation.
In the following, we derive mistakes and faults from the specification levels, depicted in \autoref{fig:correctness:categorization}.

\subsubsection{Global Level}
Regarding global consistency specifications for a set of model types, two basic mistakes can be made. 
These mistakes concern compliance of the defined consistency specification with the actual notion of consistency between the involved model types.
First, a specification can be incomplete (\emph{underspecified}), which means that some consistency constraints are missed. 
As a result, the consistency specification according to \autoref{def:consistency_specification} would contain more tuples of models than are actually consistent to each other. 
%%As a result, if one would define the consistency specification according to \autoref{def:consistency_specification}, more tuples of models would be in the relation than are actually consistent to each other. 
%Incomplete consistency specifications can lead to \emph{false positives}, when investigating whether a given tuple of models is consistent or not.
Another potential mistake are too restricted (\emph{overspecified}) consistency specifications, which means that additional, faulty consistency constraints are considered. 
As a result, actually consistent tuples of models would be missing in the consistency specification according to \autoref{def:consistency_specification}. 
%As a result, if one would define the consistency specification according to \autoref{def:consistency_specification}, actually consistent tuples of models would not be in the relation. 
%This %, in contrast, 
%can lead to \emph{false negatives}, because actually consistent models are identified as inconsistent.

\begin{figure}[bt]
    \centering
%    \includegraphics[angle=-90, width=\textwidth]{figures/levels_overview.pdf}
    \input{figures/correctness/mistakes_specification_levels.tex}
    \caption{Examples for Mistakes on Different Specification Levels}
    \label{fig:correctness:mistakes_specification_levels}
\end{figure}

\subsubsection{Modularization Level}
When developers modularize the global consistency specification by defining binary consistency specifications, these modular specifications can be non-compliant with the global one. 
Two kinds of mistakes, similar to those at the global level, can be distinguished, regarding compliance of modular and global specifications. %, but regarding compliance of modular and global specifications rather than between the global specification and the actual notion of consistency.
First, modular consistency specifications can be incomplete (\emph{underspecified}), so that there are global constraints which are not covered by them. 
The modular consistency specifications $\mathit{CS}_{1,2}$, $\mathit{CS}_{2,3}$ and $\mathit{CS}_{1,3}$ in \autoref{fig:correctness:mistakes_specification_levels} are incomplete iff
%For three model types $\mathcal{M}_1, \mathcal{M}_2$ and $\mathcal{M}_3$ with a global consistency specification $\mathit{CS}$, the binary specifications $\mathit{CS}_{1,2}$, $\mathit{CS}_{2,3}$ and $\mathit{CS}_{1,3}$, as depicted in \autoref{fig:levels_overview} are underspecified iff 
%\todoHeiko{Hier die Grafik aus dem Level-Kapitel übernehmen}
\begin{align*}
    & \exists M_1, M_2, M_3 : \\
    & \hspace{1em} (M_1, M_2) \in \mathit{CS}_{1,2} \land (M_2, M_3) \in \mathit{CS}_{2,3} \land (M_1, M_3) \in \mathit{CS}_{1,3} \land (M_1, M_2, M_3) \not\in \mathit{CS}
\end{align*}
This finally leads to \emph{false positives} when investigating whether a given tuple of models is consistent regarding the global specification. %as actually inconsistent models (regarding the global specification) are identified as consistent. %investigating whether a given set of models is consistent regarding the global specification or not, because actually inconsistent models regarding $\mathit{CS}$ are consistent according to all modular relations $\mathit{CS}_{1,2}$, $\mathit{CS}_{2,3}$ and $\mathit{CS}_{1,3}$.
%This finally leads to \emph{false positives} when investigating whether a given set of models is consistent regarding the global specification or not, because actually inconsistent models regarding $CS$ are consistent according to all modular relations $\mathit{CS}_{1,2}$, $\mathit{CS}_{2,3}$ and $\mathit{CS}_{1,3}$.
%\todoHeiko{Das folgende eher zu Avoidance Strategy? Überlapp vorhanden?}
%Such incomplete specifications can especially occur if constraints between two types of models are not expressed at all (so the consistency specification covers all model pairs), but are only transitively defined over two or more other relations. 
%For example, if $\mathit{CS}_{1,3}$ shall be omitted and transitively expressed across $\mathit{CS}_{1,2}$ and $\mathit{CS}_{2_3}$, the following must hold:
% \begin{align*}
%     & \forall M_1 \in \mathcal{M}_1 : \forall M_2 \in \mathcal{M}_2 : \forall M_3 \in \mathcal{M}_3 : \\
%     & \hspace{1em} \mathit{CS}(M_1, M_2, M_3) \iff \mathit{CS}_{1,2}(M_1, M_2) \land \mathit{CS}_{2,3}(M_2, M_3)
% \end{align*}
%\begin{align*}
    %& \forall M_1, M_2, M_3 : (M_1, M_2, M_3) \in \mathit{CS} \Leftrightarrow (M_1, M_2) \in \mathit{CS}_{1,2} \land (M_2, M_3) \in \mathit{CS}_{2,3}
%\end{align*}
%If this transitive relation misses or is even unable to express certain direct constraints, inconsistent models would be idenitified as consistent. %\todoHeiko{Das transitive muss man wohl an einem Beispiel erklären, am besten Ref. zu Intro}
Modular consistency specifications cannot only be incomplete because of an actual specification mistake, but also because of $n$-ary relations on the global level that cannot be expressed by a set of binary relations.
We excluded that case by our assumption made in \autoref{chap:properties:levels}, as otherwise a modularization into binary relations would not be possible at all.
If such cases have to be supported, the modularization would have to be extended to also consider $n$-ary relations.

Second, a modular specification can be too restricted (\emph{overspecified}) regarding the global consistency specification if additional constraints are added. 
The modular consistency specifications in \autoref{fig:correctness:mistakes_specification_levels} are overspecified iff
\begin{align*}
    & \exists M_1, M_2, M_3 : \\
    & \hspace{1em} (M_1, M_2, M_3) \in \mathit{CS} \land \big[ (M_1, M_2) \not\in \mathit{CS}_{1,2} \lor (M_2, M_3) \not\in \mathit{CS}_{2,3} \lor (M_1, M_3) \not\in \mathit{CS}_{1,3} \big]
\end{align*}
In \autoref{fig:correctness:mistakes_specification_levels}, omitting the dashed relation in $\mathit{CS}_{2,3}$ would lead to such an overspecifiation.
Overspecifications lead to additional constraints regarding the global specification, but also, and more severe, to contradicting constraints regarding other modular specifications.
In case of contradictions, the modular consistency specifications cannot be fulfilled at the same time.
In such a case, the graph of consistency relations %, as shown in \autoref{fig:mistakes_specification_levels}, 
would contain no cylces, i.e. sets of models that are consistent to each other.
We have discussed an example for such contradicting specifications %in the motivating example 
in \autoref{chap:properties:levels}, where constraints for transferring an employee name contradicted. % contains contradicting constraints for transferring the name. % to other types of models.
%In this case, when several binary specifications are combined to keep multiple models consistency, the resulting fault are incompatible binary specifications in the sense that different relations cannot hold at the same time because they are based on different global consistency specifications.
Such mistakes lead to \emph{false negatives} as actually consistent models (regarding the global specification) are identified as inconsistent. %, when investigating whether a given set of models is consistent regarding the global specification or not, because actually consistent models regarding $\mathit{CS}$ are not consistent according to the modular relations $\mathit{CS}_{1,2}$, $\mathit{CS}_{2,3}$ and $\mathit{CS}_{1,3}$.

%\begin{itemize}
    %\item inadequate structure
    %\item missing knowledge about other modular relation
%\end{itemize}

\subsubsection{Operationalization Level}
The types of mistakes that can be made at the operationalization level are different from those at the other levels, because this level does not concern the definition of consistency specifications (\autoref{def:consistency_specification}), but of consistency \emph{preservation} specifications (\autoref{def:consistency_preservation_specification}).
Such specifications are faulty if no composition of them exists that returns a consistent tuple of models for each possible change. % it does not lead to a consistent state after making modifications to a consistent tuple of models.
In \autoref{fig:correctness:mistakes_specification_levels}, an exemplary application of a single consistency preservation specification is depicted that leads to models that are not consistent according to the (global and modular) consistency specifications.
%If no concatenation of CPSs exists that finally returns a consistent set of models for each possible change, the specifications are faulty.
Let $\mathcal{CPS}$ be a set of consistency preservation specifications  %, e.g. $\mathcal{CPS} := \{\mathit{CPS}_{1}, \ldots, \mathit{CPS}_{m}\}$
for the binary consistency specifications $\mathcal{CS}$ % := \{\mathit{CS}_{1,2}, \mathit{CS}_{2,3}, \mathit{CS}_{1,3}\}$ %(where there can be more than one consistency preservation specifications for each consistency specification) 
%in \autoref{fig:mistakes_specification_levels}. %, metamodels $\mathcal{M}_0, \ldots, \mathcal{M}_n$, 
and
let $\mathfrak{M}_{\mathcal{CS}}$ be the set of model tuples that are consistent regarding $\mathcal{CS}$ (cf. \autoref{chap:properties:terminology}). 
The consistency preservation specifications are faulty iff
% \begin{align*}
%     & \exists M_0, M'_0 \in \mathcal{M}_0, M_1, M'_1 \in \mathcal{M}_1, M_2, M'_2 \in \mathcal{M}_2 : \forall \mathit{CPS}_0, \ldots, \mathit{CPS}_k \in \mathcal{CPS} : \\
%     & \hspace{1em} ((M_0, M''_0), (M_1, M''_1), (M_2, M''_2)) = \mathit{CPS}_0 \circ \dots \circ \mathit{CPS}_k((M_0, M'_0), (M_1, M'_1), (M_2, M'_2)) \\
%     & \hspace{1em} \Rightarrow \exists \mathit{CS}_{i,j} \in \mathcal{CS} : \neg \mathit{CS}_{i,j}(M''_i, M''_j)
% %    & \exists M_0, M'_0 \in \mathcal{M}_0, \ldots M_n, M'_n \in \mathcal{M}_n : \nexists \mathit{CPS}_0, \ldots, \mathit{CPS}_k \in \mathcal{CPS} : \\
% %    & \hspace{1em} ((M_0, M''_0), \dots, (M_n, M''n)) := \mathit{CPS}_0 \circ \dots \circ \mathit{CPS}_k((M_0, M'_0), \dots, (M_n, M'_n)) \\
% %    & \hspace{1em} \land \exists \mathit{CS}_{i,j} \in \mathcal{CS} : \neg \mathit{CS}_{i,j}(M''_i, M''_j)
% \end{align*}
\begin{align*}
    & \exists (M_1, \dots, M_n) \in \mathfrak{M}_{\mathcal{CS}}, (M'_1, \dots, M'_n) \in \mathcal{M}_1 \times \dots \times \mathcal{M}_n: \forall \mathit{CPS}_1, \ldots, \mathit{CPS}_k \in \mathcal{CPS} : \\
    %& \exists M_1, M'_1 \in \mathcal{M}_1, \dots, M_n, M'_n \in \mathcal{M}_n : \forall \mathit{CPS}_1, \ldots, \mathit{CPS}_k \in \mathcal{CPS} : \\
    & \hspace{1em} \mathit{CPS}_1 \circ \dots \circ \mathit{CPS}_k \big((M_1, M'_1), \dots, (M_n, M'_n) \big) = \big( (M_1, M''_1), \dots, (M_n, M''_n) \big)\\
    & \hspace{2em} \land \exists \mathit{CS}_{i,j} \in \mathcal{CS} : (M''_i, M''_j) \notin \mathit{CS}_{i,j}
%    & \exists M_0, M'_0 \in \mathcal{M}_0, \ldots M_n, M'_n \in \mathcal{M}_n : \nexists \mathit{CPS}_0, \ldots, \mathit{CPS}_k \in \mathcal{CPS} : \\
%    & \hspace{1em} ((M_0, M''_0), \dots, (M_n, M''n)) := \mathit{CPS}_0 \circ \dots \circ \mathit{CPS}_k((M_0, M'_0), \dots, (M_n, M'_n)) \\
%    & \hspace{1em} \land \exists \mathit{CS}_{i,j} \in \mathcal{CS} : \neg \mathit{CS}_{i,j}(M''_i, M''_j)
\end{align*}
%\todoHeiko{Das ist nicht so schön, weil nicht klar ist, welche CS to welcher CPS gehört und so}
%This means that there can be changes for which no execution of consistency preservation specifications is able to properly restore consistency. 

In practice, mistakes at the operationalization level occur due to missing identification of equal elements in different consistency preservation specifications. 
In our motivational example (\autoref{fig:properties:motivational_example}), %consider that an employee is created in the scheduling system for an employee created in the task management system after introducing one in the personnel management system.
consider that an employee is created in the personnel management system, transformed to the task management system and from that to the scheduling system.
The additional direct specification between personnel management and scheduling system has to consider the already created employee rather than instantiating a new one.
%We consider %this case and 
%options to avoid such problems in \autoref{sec:avoiding:matching}.
%In our example, if a class is created in Java after creating a UML class for a ADL component through appropriate consistency preservation specifications and the consistency preservation specification between ADL and Java also defines the creation of a class in Java, it is necessary that the already existing class is considered rather than creating a new class. We will consider this case and options to avoid such problems in \autoref{sec:avoiding:matching}.

% \begin{itemize}
%     \item unknown connection of elements in consistency specifications
%     \item Really, really make an example here, to distinguish from modularization level!!
% \end{itemize}

%In the following, we call all mistakes on modularization and operationalization level \emph{interoperability issues}, as they are all concerned with modularized specifications that have to interoperate. 


\section{Categorization and Discussion}
\label{chap:errors:categorization}

\begin{figure}[tb]
    \centering
    \input{figures/correctness/failure_examples_employee.tex}
%    \includegraphics[angle=270, width=\textwidth]{figures/mistakes_examples_employee.pdf}
    \caption{Consistency Constraints on Metamodel Extract (top), Failure due to Mistake on Modularization Level (left), Failure due to Mistake on Operationalization Level (right)}
    \label{fig:correctness:mistake_effects_example}
\end{figure}

%We associated the mistakes presented in the previous section with the specification level they can occur on. Additionally, we summarized potential failures that can occur when executing final consistency preservation specification in the section before.
Although all failures occur during operationalization, the mistakes that lead to them can also be made at a higher specification level, such as the modularization or global level.
More importantly, each type of failure can be traced back to specific types of mistakes, or, vice versa, specific mistakes lead to specific kinds of failures.
\autoref{fig:correctness:mistake_effects_example} shows extracts of the three metamodels from our motivation, as well as consistency constraints between them.
There are two options for a constraint between personnel data and scheduling system.
The first option is contradictory to the one defined between personnel data and task management system, as already discussed in \autoref{chap:properties:levels}.
This demonstrates that contradictory constraints are a typical fault that can result from contradicting modular knowledge, when different persons define such constraints independently.
If, nevertheless, such a contradictory consistency specification is operationalized to a consistency preservation specification, the propagation of changes may never terminate.
This is shown in the left scenario in \autoref{fig:correctness:mistake_effects_example}, where
%Due to the contradicting constraints, 
the name is replaced repeatedly in an \emph{alternating loop} as indicated by the dashed arrows.

If no mistakes are made on the modularization level, so that no contradictions exist, %which especially means that the consistency specifications are free of contradictions, 
missing matching of equal elements in the consistency preservation specifications can still lead to duplicate element instantiations.
With the second option for the constraint in \autoref{fig:correctness:mistake_effects_example}, %no contradicting constraints and thus 
no mistakes on modularization level exist.
However, a missing matching of elements %in the consistency preservation specification 
can lead to the situation shown in the right scenario of \autoref{fig:correctness:mistake_effects_example}, in which two employees are instantiated across different transformation paths.
%We also demonstrated in the example that missing matching of equal elements in the consistency preservation specifications can lead to duplicate instantiations of elements.

These were two of several causal chains for mistakes and faults to resulting failures.
We give a full overview of those dependencies in \autoref{fig:correctness:categorization}.
Missing constraints lead to deterministic inconsistencies, because such inconsistencies are not modelled and thus resolved.
Additional consistency constraints do not lead to any actual failures, but reduce the set of consistent models. 
The only consequence is that consistency preservation does not consider models that would actually be consistent.
Contradicting constraints, which can arise from a faulty modularization, are more severe, as we have seen in the example:
They can either lead to non-deterministic inconsistencies, e.g., depending on the execution order of consistency preservation specifications, or to loops that alternate or diverge values.
Finally, the missing element matching at the operationalization level can lead to multiple instantiations, as we have seen in the example, or multiple insertions. %, if elements are added to a multi-valued reference multiple times.

%\todoHeiko{Tun wir das wirklich? Oder nur ein Level?}
%In the following, we discuss strategies to avoid mistakes at the different levels.
%Afterwards, we evaluate whether our identified categorizes of mistakes, faults and failures and their dependencies are actually correct.

%Categorize the detected Causes/Mistakes into three categories, which map to the steps identified in the first subsection. Two categories have to be resolved by user and, especially, are only resolvable in the moment when concrete transformations are combined (explain why!). One category can be solved by applying appropriate pattern, explained in the next section. Each category resolution is an assumption of the next (e.g. pattern matching does not make any sense when transformations are incompatible or at least the failures than can occur may differ).

\section{Avoiding Errors}

%At the system level, mistakes can only be avoided by careful requirements elicitation. 
%Since occurring mistakes on that level represent non-conformance with a usually informal notion of consistency, such mistakes cannot be automatically avoided or detected.
At the global level, mistakes occur due to non-conformance with an informal notion of consistency and %cannot be detected automatically but 
can only be avoided by careful requirements elicitation. 
We therefore have to assume that global level mistakes are reliably avoided by the developers.
Analytic approaches~\cite{klare2018docsym}
can ensure that specifications at the modularization and operationalization level are free of faults.
%This can be applied on both the modularization and the operationalization level.
Nevertheless, %under the assumption that transformations are developed independently, 
the drawback of such an approach is that it works a-posteriori, when transformations are combined to a network. %, so transformations would have to be adapted %after their specification 
%when they are combined to a network
We, in contrast, want to achieve avoidance of interoperability issues a-priori, so that transformations can be developed independently and combined afterwards.
It is easy to see that mistakes at the modularization level cannot be avoided a-priori. 
%If modular transformations are developed independently, 
Ensuring that transformations are non-contradictory %, i.e. that they rely on the same notion of a global consistency specification, 
would require developers to have knowledge about the other transformations, which breaks the assumption of independent development.
%This breaks our assumption that developers have restricted domain knowledge, each defining one modular consistency specification.
%
Finally, mistakes regarding element matching at the operationalization level are domain-independent. 
This enables the development of generic mechanisms to ensure interoperability at the operationalization level by construction, without knowing about other transformations.

In the following, we discuss one strategy to avoid mistakes at the modularization and one to avoid those at the operationalization level.
Developers can use these strategies to build networks that are free of faults, or can use them to fix mistakes if failures occur.






\section{Summary}

\begin{insight}{Errors}
    Errors in transformation networks can be classified regarding mistakes made by the transformation developers when thinking about consistency and its preservation, faults made during their implementation in terms of transformations and failures, which are the manifestation of faults when executing the transformations.
    We found that we can assign different kinds of mistakes to different specification levels, depending on the necessary knowledge about the transformation network.
    In addition, specific kinds of failures are caused by specific kinds of mistakes.
    Thus, if a specific failure occurs, one knows that a specific kind of mistake is the reason for that failure and helps to locate the problems.
    Finally, due to our insights about compatibility and synchronizing transformations, we are able to avoid specific mistakes and thus failures already by construction of a single transformation, whereas others can be avoided by analyzing the transformations for compatibility.
\end{insight}