%%
%% FORMALIZATION
%%
\section{A Formal Notion of Transformation Networks}

\mnote{Goal: formalize transformation networks and correctness notions}
We yet discussed a general notion of consistency and its preservation with a focus on a modular way of specifying it.
This notion, however, was only specified in a rather informal way to first be able to discuss correctness notions and determine which notion is relevant for the considerations in this thesis.
In the following, we define a formal notion of consistency and its preservation, based on the informal explanation given before.
We also give a precise definition of notions for correctness between the artifacts of a modular specification.
Furthermore, we now focus on transformation-based approaches for preserving consistency, i.e., we consider specifications that transform changes within one or more models into changes in one or more other models.

%Allgemeine Definition Transformationsnetzwerke:
%\begin{itemize}
    %\item Definition Transformation aus Relation und Wiederherstellungsroutinen; Routinen nehmen n Modelle und n Deltasequenzen (eine pro Modell) und liefern n Deltasequenzen zurück.
    %\item Im Allgemeinen könnte eine Transformation beliebige dieser Deltasequenzen modifizieren. Wir verlangen jedoch, dass eine Transformation nur Deltas anhängt, also die Sequenzen länger werden
    %\item Genauer beschränken wir auch, welche Sequenzen eine Transformation sehen und ändern darf, genau gesagt darf sie die Sequenzen von zwei Modellen sehen und eine davon verlängern.
    %\item Hier kommt bereits der Unterschied zu bisherigen Transformationen, denn die sehen nur Deltas an einem Modell und erzeugen Deltas an dem anderen. Das ist bei uns schon gänzlich anders. Bidirektionale Transformationen unterstützen das im Übrigen auch nicht, sondern sind nur Spezifikationen, aus denen sich Wiederherstellungsroutinen für beide Richtungen ableiten lassen (siehe Stevens 2010)
    %\item Relationen in erster Instanz auf Modellebene (also bzgl. ganzer Modelle, nicht einzelner Modellelemente) definieren
    %\item Direkt als multidirektionale Transformation definieren, also beliebig viele geändert Ein- und Ausgabemodelle (oder jeweils nur eins?)
    %\item Korrektheit einer Transformation (nach Stevens) definieren!
    %item Versuchen den Konkatenationsoperator zu definieren ohne dass er alle Metamodelle referenzieren muss (also Transformation wählt aus einer großen Eingabemenge relevanten Modelle aus, ändert relevante und dann fügt der Operator sie in die große Menge ein)
    %\item Definition Transformationsnetzwerk als Tupel aus Metamodellen, Transformationen und einer Ausführungsfunktion. 
    %\item Die Ausführungsfunktion führt für eine gegebene Änderung eine Auswahl der Transformationen nacheinander aus.
    %\item Korrektheit eines Netzwerkes definieren: Die Ausführungsfunktion erzeugt eine Transformationssequenz, die angewendet auf eine Änderung für alle Änderungen ein korrektes Ergebnisse produziert, d.h. die Modelle sind konsistent bzgl. allen Konsistenzrelationen.
%\end{itemize}


\subsection{Modular Consistency Specification}

\mnote{Extensional specifications are relations}
As already discussed informally before, an extensional specification of consistency enumerates all sets of models that are considered consistent to each other, i.e., it specifies a relation between the models.
Since it eases comprehension of the definitions if the considered models are identifiable with an index, we will consider, without loss of generality, tuples rather than sets of models throughout the rest of this thesis.

\begin{definition}[\ModelLevelConsistencyRelation]
    Given a tuple of metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$, a \emph{\modellevelconsistencyrelation} $\consistencyrelation{CR}{}$ is a relation for instances of the metamodels $\consistencyrelation{CR}{} \subseteq \metamodeltupleinstanceset{M} = \metamodelinstanceset{M}{1} \times \dots \times \metamodelinstanceset{M}{n}$.

    For a tuple of models $\modeltuple{m} = \tupled{\model{m}{1}, \dots, \model{m}{n}} \in \metamodeltupleinstanceset{M}$ we say that:
    \begin{align*}
        \modeltuple{m} \consistenttomath \consistencyrelation{CR}{} \equivalentperdefinition \modeltuple{m} \in \consistencyrelation{CR}{}
    \end{align*}
    Otherwise, we call $\modeltuple{m} \mathtext{inconsistent to} \consistencyrelation{CR}{}$.
\end{definition}

\mnote{Start with coarse-grained model-level relations}
Given a tuple of models, we consider that tuple of models consistent if it is contained in the consistency relation.
This conforms to consistency definitions such as the one proposed by \textcite{stevens2010sosym} for bidirectional transformations.
We explicitly denote this kind of consistency relation as \emph{model-level}, because we will later need a more fine-grained notion of consistency relations at the level of \metaclasses and need to distinguish between the two.

\mnote{Modular notions of consistency}
If a single relation describes consistency between all relevant models, consistency is directly defined by means of model tuples being in that relations. We call such a relation a \emph{monolithic relation}.
However, if we have a \emph{modular} notion of consistency, i.e., a relation does only define consistency between some of the relevant models and the global notion of consistency is defined by a combination of several such relations, we need an explicit definition for that notion.
For the sake of simplicity, we focus on binary relations as a modular representation of consistency, but this definition could also be generalized to relations of arbitrary arity.
We assume that there is only one consistency relation between each pair of metamodels.
This assumption is without loss of generality, because two relations between the same metamodels are equivalent to only considering their intersection, i.e., only the model pairs that are considered consistent by both relations.

\todo{wlog: no direction of relation}

\begin{definition}[Consistency]
    Let $\metamodeltuple{M} =  \tupled{\metamodelsequence{M}{n}}$ be metamodels and let $\consistencyrelation{CR}{i,j} \subseteq \metamodelinstanceset{M}{i} \times \metamodelinstanceset{M}{j}$ be a binary \modellevelconsistencyrelation for any two metamodels $\metamodel{M}{i}, \metamodel{M}{j} \in \setted{\metamodelsequence{M}{n}}$.
    For a given tuple of models $\modeltuple{m} = \tupled{\model{m}{1}, \dots, \model{m}{n}} \in \metamodeltupleinstanceset{M}{} = \metamodelinstanceset{M}{1} \times \dots \times \metamodelinstanceset{M}{n}$, we say that this model tuple is \emph{consistent to} $\consistencyrelation{CR}{i,j}$ if and only if the instances of $\metamodel{M}{i}$ and $\metamodel{M}{j}$ are in that relation:
    \begin{align*} 
        &
        \modeltuple{m} = \tupled{\model{m}{1}, \dots, \model{m}{n}} \consistenttomath \consistencyrelation{CR}{i,j} \equivalentperdefinition %\\
        %& \formulaskip
        \tupled{\model{m}{i},\model{m}{j}} \in \consistencyrelation{CR}{i,j}
        %\exists \model{m}{i} \in \metamodelinstanceset{M}{i}, \model{m}{j} \in \metamodelinstanceset{M}{j} : \model{m}{i} \in \modelset{m} \land \model{m}{j} \in \modelset{m} \land \tupled{\model{m}{i}, \model{m}{j}} \in \consistencyrelation{CR}{}
    \end{align*}
    For a set of binary \modellevelconsistencyrelations $\consistencyrelationset{CR}$ for metamodels $\metamodeltuple{M}$, we say that a tuple of models $\modeltuple{m} \in \metamodeltupleinstanceset{M}{}$ is \emph{consistent to} $\consistencyrelationset{CR}$ if and only if it is consistent to each consistency relation in that set:
    \begin{align*} 
        &
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \equivalentperdefinition %\\
        %& \formulaskip
        \forall \consistencyrelation{CR}{} \in \consistencyrelationset{CR} : \modeltuple{m} \consistenttomath \consistencyrelationset{CR}
    \end{align*}
\end{definition}

\mnote{Examplary binary relations}
The definition states that given a set of \modellevelconsistencyrelations the models must be consistent to all of these relations to consider them consistent to the set.
Consider, for example, the relations $\consistencyrelation{CR}{1} = \setted{\tupled{\model{m}{1}, \model{m}{2}}}$, $\consistencyrelation{CR}{2} = \setted{\tupled{\model{m}{2},\model{m}{3}}}$, $\consistencyrelation{CR}{3} = \setted{\tupled{\model{m}{1}, \model{m}{3}}}$ with $\model{m}{i} \in \metamodelinstanceset{M}{i}$ for metamodels $\metamodel{M}{i}$. Then the model tuple $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}$ is consistent to these relations, because it is consistent to each of the binary relations.
These consistency relations are equivalent to a monolithic relation $\consistencyrelation{CR}{} = \setted{\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}}$, because a model tuple $\modeltuple{m}$ is consistent to $\consistencyrelation{CR}{}$ exactly when it is consistent to $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$.


\subsection{Expressiveness of Modular Consistency Specifications}

\mnote{Modular and monolithic specification are not equivalent}
Although in that exemplary case the binary relations are equivalent to a monolithic relation, such an equivalence is not always given. In general, two interesting insights come along with that definition of consistency based on modular relations. First, expressiveness of defining consistency modularly by a set of relations is not equivalent to defining one monolithic relation between all models. Second, a modular definition of consistency can easily contain contradictions, which may lead to an empty set of consistent models.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/correctness/notion/binary_definable.png}
    \caption[Modular consistency relation that cannot be modularized]{A monolithic consistency relation which cannot be equally expressed by binary relations.}
    \label{fig:correctness:binary_definable}
\end{figure}

\mnote{Binary relations reduce expressiveness}
It is easy to see that a combination of binary relations is not able to express the same consistency relations as one monolithic relation.
For example, the monolithic relation $\consistencyrelation{CR}{} = \setted{\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}'}, \tupled{\model{m}{1}, \model{m}{2}', \model{m}{3}}, \tupled{\model{m}{1}', \model{m}{2}, \model{m}{3}}}$ cannot be expressed by binary relations, as also depicted in \autoref{fig:correctness:binary_definable}.
The binary relations necessarily need to contain $\tupled{\model{m}{1}, \model{m}{2}}$, because $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}'} \in \consistencyrelation{CR}{}$ and $\tupled{\model{m}{2}, \model{m}{3}}$, because $\tupled{\model{m}{1}', \model{m}{2}, \model{m}{3}} \in \consistencyrelation{CR}{}$. However, this would mean that $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}$ is considered consistent to the binary relations although it not consistent to the modular relation $\consistencyrelation{CR}{}$.
Thus, using sets of binary relations in contrast to a single monolithic relation reduces expressiveness.
\textcite{stevens2017a} discusses the property of a multiary relation to be expressed by binary ones as \emph{binary-definable} in detail.
She proposed restrictions to binary relations that may be sufficient and still practical for expressing consistency, such as a notion of \emph{binary-implemented} relations.
However, we reasoned the assumption that relations need to be specified independently and thus modularly anyway, thus we have to accept that these restrictions in expressiveness exists.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/correctness/notion/contradictions_example.png}
    \caption[Example for incompatible consistency relations]{Modular consistency relations, which together cannot be fulfilled (left) or which cannot be fulfilled for some of the consistent model pairs (right).}
    \label{fig:correctness:contradictions_example}
\end{figure}

\mnote{Binary relations may be contradictory}
Additionally, it is easy to define multiple binary relations of which each can be fulfilled by certain models, but for which no tuple of models exists that is consistent to all of them. Consider the relations $\consistencyrelation{CR}{1} = \setted{\tupled{\model{m}{1}, \model{m}{2}}}$, $\consistencyrelation{CR}{2} = \setted{\tupled{\model{m}{2}, \model{m}{3}}}$, $\consistencyrelation{CR}{3} = \setted{\tupled{\model{m}{1}, \model{m}{3}'}}$, which are also depicted at the left of \autoref{fig:correctness:contradictions_example}.
Although for each of these relations a consistent set of models exists, which is exactly the one defined in each relation, no tuple of models exists that fulfills their combination.
This example already demonstrates the worst case, in which no consistent models exist for a set of relations.
In other cases, it may be possible that only for some models that are consistent according to one or some of the relations no model tuple exists that is consistent for all models.
Consider the relations $\consistencyrelation{CR}{1} = \setted{\tupled{\model{m}{1}, \model{m}{2}}}$, $\consistencyrelation{CR}{2} = \setted{\tupled{\model{m}{2}, \model{m}{3}}, \tupled{\model{m}{2}, \model{m}{3}}'}$, $\consistencyrelation{CR}{3} = \setted{\model{m}{1}, \model{m}{3}'}$, which are also depicted at the right of \autoref{fig:correctness:contradictions_example}.
In this case, the tuple $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}'}$ would be considered consistent to the relations, but although $\tupled{\model{m}{2}, \model{m}{3}} \in \consistencyrelation{CR}{2}$ there exists no $\model{m^*}{1} \in \metamodelinstanceset{M}{1}$ so that $\tupled{\model{m^*}{1}, \model{m}{2}, \model{m}{3}}$ is consistent to all these relations.

\mnote{Sets of relations can forbid models}
It is easy to see that one monolithic relation may be equally represented by an arbitrary number of sets of binary relations by simply adding model pairs to these binary relations that are never consistent to the other relations, like we have seen for the pair $\tupled{\model{m}{2}, \model{m}{3}}$ in the previous example.
This means that the combination of relations can lead to the situation that some models are actually forbidden (like $\model{m}{3}$ in the example before) due to the combination of consistency relations.
Whether such a situation is intended or not can finally depend on the semantics of the actual models and relations, but we will discuss which situations may be unintended in general, thus independent from the scenario.
We already informally discussed this as a notion of \emph{compatibility}, for which we investigate in \autoref{chap:compatibility} how far this behavior is or should be expected.


\subsection{Incremental and Inductive Consistency Preservation}

\mnote{Preserving consistency}
While the previous discussion only considered when models are considered consistent, it is of especial interest to ensure that consistency of models is preserved.
We informally introduced such specifications as \glspl{consistency preservation rule}.
In the following, we will restrict us to \emph{incremental} and \emph{inductive} consistency preservation and give a precise definition for that.
This means that we make the following assumptions to the process:
\begin{properdescription}
    \item[Information preservation (incrementality):] After a change to one model, the others are not generated from scratch but updated according to the performed changes. This ensures that information that cannot be generated but was added by users to the other models is preserved.
    \item[Consistency assumption (induction):] We assume models to be consistent before a change is processed by \glspl{consistency preservation rule}. Otherwise the preservation rules would need to be able to handle arbitrary states of the models and it would be unclear consistency to which \glspl{consistency relation} has to be restored.
\end{properdescription}
While incrementality is an essential requirement whenever consistency shall be preserved to avoid information loss, inductivity may not be necessary.
We, however, make this assumption to avoid requiring from the \glspl{consistency preservation rule} that they need to be able to process an inconsistent state without knowing which changes introduced it.
From a theoretical point of view, we could omit that requirement, but this would make the specification of \glspl{consistency preservation rule} impractically complicated, such that omitting that requirement is not practically relevant anyway.
%In consequence, an incremental and inductive \gls{consistency preservation rule} takes a consistent tuple of models and changes to them and returns a tuple of models that is consistent again.

\todoLater{Do we need inductivity for synchronization? Otherwise we may remove it here and from following definitions?}
%\todo{Explicitly discuss incrementality here, although we actually do not need it. So leave it out? No, needed for synchronization definition. But make clear that this is a specialization and discuss generalization.}
%\todo{Make precise here that we have incremental consistency, thus last consistent state and delta to that is known. We did not assume that in the informal notion before.}

\mnote{Monolithic and modular consistency preservation}
Like we already discussed for \glspl{consistency preservation rule} in general, incremental preservation rules can be realized in an either monolithic or modular way.
A monolithic consistency preservation rules takes a tuple of models that is consistent to a consistency relation and a change to these models and returns another tuple of models that is consistent again.
In a modular specification of \glspl{consistency preservation rule}, a set of such rules is given which are able to preserve consistency of a subset of the given models according to modular consistency relations.
In our case, we consider such rules for two models, each of them restoring consistency according to a binary consistency relation.
%We will later discuss if and how an execution order of such consistency preservation rules can be determined.

\mnote{Drawbacks of existing unidirectional consistency restorers}
In terminology for transformations, a \gls{consistency preservation rule} that restores consistency of models according to a \gls{consistency relation} in one direction is called \emph{directional transformation}~\cite{stevens2010sosym} or \emph{consistency restorer}~\cite{stevens2020BidirectionalTransformationLarge-SoSym}.
Definitions of that terminology do usually not consider changes but only states of models and simply define a preservation rule for metamodel $\metamodel{M}{1}$ and $\metamodel{M}{2}$ that modifies the instance of $\metamodel{M}{2}$ to restore consistency as $\consistencypreservationrule{}: \metamodelinstanceset{M}{1} \times \metamodelinstanceset{M}{2} \rightarrow \metamodelinstanceset{M}{2}$.
This notion, however, has two properties that imply essential drawbacks:
\begin{properdescription}
    \item[State-based:] No information about the performed changes that led to the inconsistent state are given. This means that the specification is not aware of how the inconsistent state was reached.
    \item[Unidirectional:] The unidirectionality of the specification always requires to only update one model to restore consistency.
\end{properdescription}
State-based transformations always suffer from the problem that it is unknown which changes were made that led to an inconsistent state and reconstructing them from the difference between two states is only a heuristic approximation~\cite{diskin2011StateToDeltaSymmetric-MODEDLS}.
This, for example, includes that information about elements which were moved or renamed can potentially not be reconstructed, leading to elements that are deleted and created anew, losing all information that was potentially added to them.
Unidirectionality may be reasonable when assuming that only one of the models was modified. In that case it is sufficient to update the other model to restore consistency.
With a modular specification of consistency preservation, however, several \glspl{consistency preservation rule} modifying the same models may need to be executed.
This can be seen in the example in \autoref{todo}\todo{add graphics and explanation for that}.
In consequence, the rules need to be able to deal with changes performed in both of the input models and, consequentially, need to update both models to reflect the changes in the other.

\mnote{Synchronizing consistency preservation rules circument drawbacks}
To be able to combine several \glspl{consistency preservation rule} without the discussed drawbacks, we define a \emph{synchronizing} rather than a unidirectional notion of them
Those rules are able to react to changes in both models and produce changes in both models again.
To precisely define this behavior, we first introduce a notion of \emph{changes} and afterwards of \emph{\glspl{consistency preservation rule}}.

\begin{definition}[Change]
    Given a metamodel $\metamodel{M}{}$, a change $\change{\metamodel{M}{}}$ is a function that takes an instance of that metamodel and returns another one:
    \begin{align*}
        \change{\metamodel{M}{}}: \metamodelinstanceset{M}{} \rightarrow \metamodelinstanceset{M}{}
    \end{align*}
    It encodes any kind of modification, which may be just an element addition, or removal, an attribute change and so on, or any composition of changes.
    We denote the identity change, i.e., the change that always returns the input model, as $\identitychange$:
    \begin{align*}
        \identitychange(x) \equalsperdefinition x
    \end{align*}
    We denote the universe of all changes in $\metamodel{M}{}$, i.e., all subsets of $\metamodelinstanceset{M}{} \times \metamodelinstanceset{M}{}$ that are functional, as 
    \begin{align*}
        \changeuniverse{\metamodel{M}{}} \equalsperdefinition \setted{\change{\metamodel{M}{}} \mid \change{\metamodel{M}{}} \subseteq \metamodelinstanceset{M}{} \times \metamodelinstanceset{M}{} \land
        (\tupled{\model{m}{1}, \model{m}{2}}, \tupled{\model{m}{1}, \model{m}{3}} \in \change{\metamodel{M}{}} \Rightarrow \model{mc}{2} = \model{m}{3})}
    \end{align*}
    For a given metamodel tuple $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$, we denote the set of all tuples of changes in the instances tuples of 
    $\metamodeltuple{M}$, i.e. in $\metamodeltupleinstanceset{M}$, as $\changeuniverse{\metamodeltuple{M}}$:
    \begin{align*}
        \changeuniverse{\metamodeltuple{M}} \equalsperdefinition \setted{ \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \mid \forall i \in \setted{1,\dots,n} : \change{\metamodel{M}{i}} \in \changeuniverse{\metamodel{M}{i}} } 
    \end{align*}
\end{definition}

\mnote{Behavior of unapplicable change is undefined}
For us, it does not matter how the function describing a change behaves in cases, in which the encoded change cannot be applied, e.g., because the changed or removed element does not exist. The function may do nothing for those models, i.e., return the identical model, or even be undefined for those model, i.e., be partial.
\todoLater{Check whether this behavior is correct.}

% \begin{definition}[\ModelLevelConsistencyPreservationRule]
%     Let $\metamodel{M}{1}, \metamodel{M}{2}$ be two metamodels and $\consistencyrelation{CR}{} \subseteq \metamodelinstanceset{M}{1} \times \metamodelinstanceset{M}{2}$ a binary \modellevelconsistencyrelation between them.
%     A \emph{\modellevelconsistencypreservationrule} $\consistencypreservationrule{\consistencyrelation{CR}{}}$ for the relation $\consistencypreservationrule{\consistencyrelation{CR}{}}$ is a function:
%     \begin{align*}
%         \consistencypreservationrule{\consistencyrelation{CR}{}} : (\metamodelinstanceset{M}{1}, \metamodelinstanceset{M}{2}, \change{\metamodel{M}{1}}) \rightarrow \change{\metamodel{M}{2}}
%     \end{align*}
%     It takes two consistent models and a change in the first one and returns a change in the second one.
%     We call a \modellevelconsistencypreservationrule \emph{correct} w.r.t. $\consistencyrelation{CR}{}$ if the resulting models when applying the input and output change are consistent to $\consistencyrelation{CR}{}$ again:
%     \begin{align*}
%         &
%         \forall \model{m}{1} \in \metamodelinstanceset{M}{1}, \model{m}{2} \in \metamodelinstanceset{M}{2} :
%         \tupled{\model{m}{1}, \model{m}{2}} \in \consistencyrelation{CR}{} \Rightarrow\\
%         & \formulaskip
%         \forall \change{\metamodel{M}{1}} \in \changeuniverse{\metamodel{M}{1}} :
%         \exists \change{\metamodel{M}{2}} \in \changeuniverse{\metamodel{M}{2}} :\\
%         & \formulaskip
%         \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{1}, \model{m}{2}, \change{\metamodel{M}{1}}) = \change{\metamodel{M}{2}} 
%         \land \tupled{\change{\metamodel{M}{1}}(\model{m}{1}), \change{\metamodel{M}{2}}(\model{m}{2})} \in \consistencyrelation{CR}{}
%     \end{align*}
% \end{definition}

\begin{definition}[\ModelLevelConsistencyPreservationRule]
    \label{def:consistencypreservationrule}
    Let $\metamodel{M}{1}, \metamodel{M}{2}$ be two metamodels and $\consistencyrelation{CR}{} \subseteq \metamodelinstanceset{M}{1} \times \metamodelinstanceset{M}{2}$ a binary \modellevelconsistencyrelation between them.
    A \emph{\modellevelconsistencypreservationrule} $\consistencypreservationrule{\consistencyrelation{CR}{}}$ for the relation $\consistencypreservationrule{\consistencyrelation{CR}{}}$ is a function:
    \begin{align*}
        \consistencypreservationrule{\consistencyrelation{CR}{}} : (\metamodelinstanceset{M}{1}, \metamodelinstanceset{M}{2}, \changeuniverse{\metamodel{M}{1}}, \changeuniverse{\metamodel{M}{2}}) \rightarrow (\changeuniverse{\metamodel{M}{1}}, \changeuniverse{\metamodel{M}{2}})
    \end{align*}
    %It takes two consistent models and a change in the first one and returns a change in the second one. 
\end{definition}

\mnote{Correctness notion of consistency preservation rules}
To consider a \modellevelconsistencypreservationrule \emph{correct}, it has to return changes that, when applied to the input models, result in models that are consistent according to the \modellevelconsistencyrelation for which the preservation rule is defined.
This conforms to the notion of correctness defined for bidirectional transformations~\cite{stevens2010sosym}.

\begin{definition}[\ModelLevelConsistencyPreservationRule Correctness]
    \label{def:consistencypreservationrulecorrectness}
    Let $\consistencypreservationrule{\consistencyrelation{CR}{}}$ be a \emph{\modellevelconsistencypreservationrule}.
    We call a \modellevelconsistencypreservationrule \emph{correct} if the resulting models when applying the generated changes are consistent to $\consistencyrelation{CR}{}$ again:
    \begin{align*}
        &
        \forall 
        \model{m}{1} \in \metamodelinstanceset{M}{1}, 
        \model{m}{2} \in \metamodelinstanceset{M}{2},
        \change{\metamodel{M}{1}} \in \changeuniverse{\metamodel{M}{1}},
        \change{\metamodel{M}{2}} \in \changeuniverse{\metamodel{M}{2}} :
        \tupled{\model{m}{1}, \model{m}{2}} \in \consistencyrelation{CR}{} \Rightarrow\\
        & \formulaskip
        \exists 
        \change{\metamodel{M}{1}}' \in \changeuniverse{\metamodel{M}{1}},
        \change{\metamodel{M}{2}}' \in \changeuniverse{\metamodel{M}{2}} :
        \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{1}, \model{m}{2}, \change{\metamodel{M}{1}}, \change{\metamodel{M}{2}}) = (\change{\metamodel{M}{1}}', \change{\metamodel{M}{2}}') \\
        & \formulaskip
        \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \change{\metamodel{M}{2}}'(\model{m}{2})} \in \consistencyrelation{CR}{}
    \end{align*}
\end{definition}

\mnote{No restriction to achieve \enquote{resonable} preservation rules}
This definition does not make any restrictions on how the input and output changes are related.
In fact, a valid (and especially correct) \gls{consistency preservation rule} could always return empty changes.
In consequence, the rule would simply revert all input changes to achieve a consistent state again.
Although this may not be the expected behavior, there is no reason to restrict this behavior in the definition.
Actually, the developer of the preservation rule should specify in a \emph{reasonable} way, such that is provides any expected behavior.

%A \modellevelconsistencypreservationrule is defined to restore consistency after a modification in a left model of the underlying \modellevelconsistencyrelation by creating a change for the right model. To consider consistency preservation rules that preserve consistency in the other direction, we regard the inverse of the consistency relation as well, denoted as $\inverseconsistencyrelation{CR}{} = \setted{\tupled{\model{m}{1}, \model{m}{2}} \mid \tupled{\model{m}{2}, \model{m}{1}} \in \consistencyrelation{CR}{}}$.

\mnote{Encapsulation of consistency relations and preservation rules in transformations.}
We already discussed that it is possible to define \glspl{consistency relation} and derive \glspl{consistency preservation rule} from them or to only define the \glspl{consistency preservation rule}, which then imply the \glspl{consistency relation} by their fixed points.
Anyway, in practice there will only be one of these specifications and the other is implied or derived.
We thus define a \emph{synchronizing transformation}, in extension to \emph{bidirectional transformations}~\cite{stevens2010sosym}, as an artifact that encapsulates a \modellevelconsistencyrelation together with a \modellevelconsistencypreservationrule, no matter which of them is defined and which is derived or implied.

\begin{definition}[Synchronizing Transformation]
    \label{def:synchronizingtransformation}
    Let $\consistencyrelation{CR}{}$ be a \modellevelconsistencyrelation and $\consistencypreservationrule{\consistencyrelation{CR}{}}$ a \modellevelconsistencypreservationrule that restores consistency according to that relation.
    A \emph{synchronizing transformation} is a pair $\transformation{T} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$.
\end{definition}

\begin{definition}[Synchronizing Transformation Correctness]
    \label{def:synchronizingtransformationcorrectness}
    We call a synchronizing transformation $\transformation{T} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$ if, and only if, $\consistencypreservationrule{\consistencyrelation{CR}{}}$ is correct according to \autoref{def:consistencypreservationrulecorrectness}.
\end{definition}

In the following, we will only refer to transformations rather than \glspl{consistency preservation rule} if the distinction is not necessary.
Although \autoref{def:synchronizingtransformationcorrectness} precisely defines when we consider a transformation correct, it is unclear how to define a transformation that fulfills such a correctness property.
This question was introduced as \researchquestionref{rq:correctness:synchronization} and an approach for that constitues our contribution \contributionref{contrib:correctness:synchronization}, which we discuss in \autoref{chap:synchronization}.


\subsection{Transformation Orchestration}

\mnote{Multiple transformations need orchestration}
Having multiple transformations between several metamodels requires their orchestration, i.e., the decision which transformation have to be executed in which order, if consistency between instances of those metamodels shall be preserved after changes.
We discussed that transformations, or more precisely their \glspl{consistency preservation rule}, may be executed independently and thus concurrently, which requires their results to be unified, or to execute them consecutively.
We already identified the drawbacks of a concurrent execution approach, including the necessity to define unification operators and the missing guarantee to be consistent to any consistency relation after such a unification.
This is why we follow the approach of consecutively executing transformations.

\mnote{Orchestration function to determine execution order}
To consecutively execute transformations, an order of their execution has to be determined.
While in practice a dynamic algorithm will be used to determine that order, from a theoretical perspective that algorithm realized a function that returns the order to execute the transformations in.
We call this an \emph{orchestration function} as it is responsible for orchestrating the execution of transformations.

\begin{definition}[Transformation Orchestration Function]
    Let $\transformationset{}$ be a set of transformations with \glspl{consistency relation} and according \glspl{consistency preservation rule} for metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
    A transformation \gls{orchestration function} $\orcfunction{\transformationset{T}}$ for these transformations is a function:
    \begin{align*}
        &
        \orcfunction{\transformationset{T}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow \transformationset{T}^{< \mathbb{N}}
    \end{align*}
    $\transformationset{T}^{< \mathbb{N}}$ denotes all finite sequences of transformations in $\transformationset{T}$, i.e., $\transformationset{T}^{< \mathbb{N}} = \emptyset \cup \transformationset{T}^1 \cup \transformationset{T}^2 \cup \dots$.
\end{definition}

% \begin{definition}[Consistency Preservation Orchestration Function]
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation orchestration function $\consistencyorcfunction{\consistencypreservationruleset{}}$ for these rules is a function:
%     \begin{align*}
%         &
%         \consistencyorcfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow \consistencypreservationruleset{}^{< \mathbb{N}}
%     \end{align*}
%     $\consistencypreservationruleset{}^{< \mathbb{N}}$ denotes all finite sequences of consistency preservation rules in $\consistencypreservationruleset{}$, i.e., $\consistencypreservationruleset{}^{< \mathbb{N}} = \emptyset \cup \consistencypreservationruleset{}^1 \cup \consistencypreservationruleset{}^2 \cup \dots$.
% \end{definition}

\mnote{Orchestration function does not guarantee consistent result}
According to this definition, the orchestration functions returns a sequence of transformations and determines that their \modellevelconsistencypreservationrules need to be executed in the given order. 
This especially includes that transformations may occur more than once in such sequence.

\mnote{There is not always an orchestration with a consistent result}
It is obvious that without further restrictions to the transformations it is possible that for given transformations, models and changes to them an orchestration function cannot find an execution order that returns a consistent tuple of models after certain changes. 
Consider the example in \autoref{fig:correctness:no_execution_order}. There exists no execution order for any input value that terminates. The transformations will always increase the value, although the defined relations could be fulfilled for the input value, but the transformations never find that solution.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/correctness/formal/divergence_example.png}
    \caption{Example for divergence}
    \label{fig:correctness:no_execution_order}
\end{figure}

\mnote{Restriction to transformations are necessary to decide the orchestration problem}
We will discuss in \autoref{chap:orchestration} in detail whether we can find restrictions for the transformations that ensure that an orchestration that reveals a consistent result always exists.
We will also prove that without further restrictions the decision problem whether an orchestration exists that leads to a consistent result is undecidable.
Due to these degrees of freedom, the definition does not further restrict that an orchestration of transformations has to lead to a consistent result.

\mnote{Application function to make process of applying transformations explicit}
An \gls{orchestration function} does only determine an order of transformations.
Intuitively speaking, consistency for given models and changes to them can be preserved by requesting an orchestration from that function and executing the transformations in the given order.
We make this process explicit by defining an \emph{\gls{application function}} that is able to perform consistency preservation based on given transformations, an orchestration function for them and the actual models and changes.

\mnote{Simplify transformation concatenation by a generalization function}
Before defining that \gls{application function}, we first need to define an auxiliary function to concatenate transformations, more precisely their contained \glspl{consistency preservation rule}.
\Glspl{consistency preservation rule} according to \autoref{def:consistencypreservationrule} are restricted to the two metamodels they are defined for.
Additionally, they require initial models and changes as input, but only return changes.
For these two reasons, the functions describing the preservation rules cannot be easily concatenated.
This, however, is necessary to formally describe their consecutive execution.
We define a \emph{generalization function} for transformations, which generalizes them to arbitrary sets of metamodels and a conforming signature for their input and output, which eases the description of their concatenation.

\begin{definition}[Transformation Generalization Function]
    Let $\transformation{t} = \tupled{\consistencyrelation{CR}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$ be a transformation for metamodels $\metamodel{M}{i}, \metamodel{M}{k}$.
    Let $\metamodeltuple{M} = \tupled{\metamodel{M}{1}, \dots, \metamodel{M}{i}, \dots, \metamodel{M}{k}, \dots, \metamodel{M}{n}}$ be a tuple of metamodels containing $\metamodel{M}{i}$ and $\metamodel{M}{k}$.
    A transformation generalization function $\generalizationfunction{\metamodeltuple{M},\transformation{t}}$ for metamodels $\metamodeltuple{M}$ and transformation $\transformation{t}$ is a function:
    \begin{align*}
        \generalizationfunction{\metamodeltuple{M},\transformation{t}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}})
    \end{align*}
    It generalizes the \modellevelconsistencypreservationrule $\consistencypreservationrule{\consistencyrelation{CR}{}}$ of transformation $\transformation{t}$ such that it can be applied to changes in $\metamodeltuple{M}$ instead of $\metamodel{M}{i}$ and $\metamodel{M}{k}$, i.e. it applies the changes delivered by $\consistencypreservationrule{\consistencyrelation{CR}{}}$ for the relevant models to the given change tuple.
    Let $\modeltuple{m} \in \metamodeltupleinstanceset{M}$ be a model tuple and $\changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{i}}, \dots, \change{\metamodel{M}{k}}, \dots, \change{\metamodel{M}{n}}}$ a change tuple.
    We define $\tupled{\change{\metamodel{M}{i}}', \change{\metamodel{M}{k}}'} \equalsperdefinition \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{i}, \model{m}{k}, \change{\metamodel{M}{i}}, \change{\metamodel{M}{k}})$.
    Then the generalization function is defined as:
    \begin{align*}
        \generalizationfunction{\metamodeltuple{M},\transformation{t}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) =
        (\modeltuple{m}, \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{i}}' \concatfunction \change{\metamodel{M}{i}}, \dots, \change{\metamodel{M}{k}}' \concatfunction \change{\metamodel{M}{k}}, \dots, \change{\metamodel{M}{n}}})
    \end{align*}
\end{definition}

% \begin{definition}[\ModelLevelConsistencyPreservationRule Generalization Function]
%     Let $\consistencypreservationrule{\consistencyrelation{CR}{}}$ be a \modellevelconsistencypreservationrule for metamodels $\metamodel{M}{i}, \metamodel{M}{k}$.
%     Let $\metamodeltuple{M} = \tupled{\metamodel{M}{1}, \dots, \metamodel{M}{i}, \dots, \metamodel{M}{k}, \dots, \metamodel{M}{n}}$ be a tuple of metamodels containing $\metamodel{M}{i}$ and $\metamodel{M}{k}$.
%     A \modellevelconsistencypreservationrule generalization function $\cprgeneralizationfunction{\consistencypreservationrule{\consistencyrelation{CR}{}}}$ is a function:
%     \begin{align*}
%         \cprgeneralizationfunction{\consistencypreservationrule{\consistencyrelation{CR}{}}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}})
%     \end{align*}
%     It generalizes $\consistencypreservationrule{\consistencyrelation{CR}{}}$ such that it can be applied to changes in $\metamodeltuple{M}$ instead of $\metamodel{M}{i}$ and $\metamodel{M}{k}$, i.e. it applies the changes delivered by $\consistencypreservationrule{\consistencyrelation{CR}{}}$ for the relevant models to the given change tuple.
%     Let $\modeltuple{m} \in \metamodeltupleinstanceset{M}$ be a model tuple and $\changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{i}}, \dots, \change{\metamodel{M}{k}}, \dots, \change{\metamodel{M}{n}}}$ a change tuple.
%     We define $\tupled{\change{m}{i}', \change{m}{k}'} \equalsperdefinition \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{i}, \model{m}{k}, \change{\metamodel{M}{i}}, \change{\metamodel{M}{k}})$.
%     Then the generalization function is defined as:
%     \begin{align*}
%         \cprgeneralizationfunction{\consistencypreservationrule{\consistencyrelation{CR}{}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) =
%         (\modeltuple{m}, \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{i}}' \concatfunction \change{\metamodel{M}{i}}, \dots, \change{\metamodel{M}{k}}' \concatfunction \change{\metamodel{M}{k}}, \dots, \change{\metamodel{M}{n}}})
%     \end{align*}
% \end{definition}

\mnote{Generalization function is universally defined}
The generalization function is a universally-defined auxiliary function only necessary only necessary to formalize the concepts.
It must neither be defined individually for a specific transformation, nor must it be explicitly specified by a developer of transformations at all.

\mnote{Orchestration or application funciton must deal with unresolvable cases}
Finally, either the orchestration function or an application function must also be able to reflect the cases in which no execution order of transformation can be found that restores consistency.
In accordance to the terminology of \textcite{stevens2020BidirectionalTransformationLarge-SoSym}, we call those cases \emph{unresolvable}.
From a theoretical perspective, it does not make a difference whether the orchestration or the application function makes that decision. 
Finally, the orchestration function could also directly be encoded into the application function from a theoretical perspective.
However, from a practical perspective we may want to be able to find an execution order although there is no order that results in a consistent state, to be able to find out why it is not possible to restore consistency, e.g., which transformation induces that problem.

\mnote{An application function is partial and applies transformations}
We define a transformation \gls{application function} that applies transformations to a given set of models and changes according to an order delivered by an \gls{orchestration function}.
This function is partial to allow it to indicate that no result with consistent models could be found.
We indicate those cases with the result $\bot$.

\begin{definition}[Transformation Application Function]
    Let $\transformationset{T}$ be a set of synchronizing transformation for consistency relation $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$ and $\orcfunction{\transformationset{T}}$ an orchestration function for them.
    A transformation \gls{application function} $\appfunction{\orcfunction{\transformationset{T}}}$ for these rules is a partial function:
    \begin{align*}
        &
        \appfunction{\orcfunction{\transformationset{T}}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow \metamodeltupleinstanceset{M} \cup \setted{\bot}
    \end{align*}
    The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. It is partial, because it is allowed to return $\bot$ especially for inconsistent input models but potentially also in other cases. It has to fulfill the following conditions:
    \begin{align*}
        &
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
        & \formulaskip
        \big( 
        %\appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \bot \\
        %& \formulaskip 
        %\lor
            \exists \modeltuple{m'} \in \metamodeltupleinstanceset{M} : 
            \appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \modeltuple{m'} \Rightarrow\\
            & \formulaskip \formulaskip
            \exists \transformation{t}_{1}, \dots, \transformation{t}_{m} \in \transformationset{T} :
            \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
            & \formulaskip \formulaskip \formulaskip
            \orcfunction{\transformationset{T}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \tupled{\transformation{t}_{1}, \dots, \transformation{t}_{m}} \\
            & \formulaskip \formulaskip \formulaskip
            \land \generalizationfunction{\metamodeltuple{M},\transformation{t}_{1}} \concatfunction \dots \concatfunction \generalizationfunction{\metamodeltuple{M},\transformation{t}_{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}')\\
            & \formulaskip \formulaskip \formulaskip
            \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'}
        \big)
    \end{align*}
\end{definition}

\mnote{A weak notion of correctness, because of orchestration undecidability}
While the previous definition does not restrict in which cases $\bot$ and in which an actual tuple of models is returned, we define when we consider an \gls{application function} \emph{correct}.
Correctness can be defined in several ways.
For example, we might say that the function is correct if it always returns a consistent tuple of models when there is an order of transformations that leads to those consistent models.
As we will see later, this is, however, generally impossible, because that decision problem is undecidable.
In consequence, the \gls{orchestration function} and \gls{application function} need to operate conservatively, i.e., return $\bot$ although there might be a sequence of transformations whose application leads to consistent models.
As an alternative, we might require the function to always return consistent models when the \gls{orchestration function} delivers a sequence of transformations whose application leads to a consistent tuple of models.
Since we have to deal with conservativeness anyway, this, however, does not provide any benefits.
In consequence, we define correctness as the property that if a tuple of models is returned, it must be consistent.

\begin{definition}[Transformation Application Function Correctness]
    \label{def:applicationfunctioncorrectness}
    Let $\appfunction{\orcfunction{\transformationset{T}}}$ be an application function for an orchestration function $\orcfunction{\transformationset{T}}$ for transformations $\transformationset{T}$.
    Let $\consistencyrelationset{CR}$ be the set of \glspl{consistency relation} for which the transformations in $\transformationset{T}$ are defined.
    We say that $\appfunction{\orcfunction{\transformationset{T}}}$ is \emph{correct} if its result is either $\bot$ or consistent to $\consistencyrelationset{CR}{}$:
    \begin{align*}
        &
        \appfunction{\orcfunction{\transformationset{T}}} \mathtext{is correct} \equivalentperdefinition \\
        & \formulaskip
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
        & \formulaskip
        \appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \bot \lor \appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \consistenttomath \consistencyrelationset{CR}
    \end{align*}
\end{definition}
% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$ and $\consistencyorcfunction{\consistencypreservationruleset{}}$ an orchestration function for the consistency preservation rules.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is a partial function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencyorcfunction{\consistencypreservationruleset{}}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow \metamodeltupleinstanceset{M} \cup \setted{\bot}
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. It is partial, because it is allowed to return $\bot$ especially for inconsistent input models but potentially also in other cases. It has to fulfill the following conditions:
%     \begin{align*}
%         &
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \big( \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \bot \\
%         & \formulaskip 
%         \lor
%             \exists \modeltuple{m'} \in \metamodeltupleinstanceset{M} : 
%             \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \modeltuple{m'} \land\\
%             & \formulaskip \formulaskip
%             \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : %\\
%             %& \formulaskip \formulaskip
%             \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%             & \formulaskip \formulaskip
%             \consistencyorcfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \tupled{\consistencypreservationrule{1}, \dots, \consistencypreservationrule{m}} \\
%             & \formulaskip \formulaskip
%             \land \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}')\\
%             & \formulaskip \formulaskip
%             \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'}
%         \big)
%     \end{align*}
%     We say that $\consistencyappfunction{\consistencyorcfunction{\consistencypreservationruleset{}}}$ is \emph{correct} if its result is either $\bot$ or consistent to $\consistencyrelation{CR}{}$:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} \mathtext{is correct} \equivalentperdefinition \\
%         & \formulaskip
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \bot \lor \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \consistenttomath \consistencyrelationset{CR}
%     \end{align*}
% \end{definition}

% The definition of the application function basically ensures that the function either returns $\bot$ or executes the \modellevelconsistencypreservationrules given by the orchestration function to retrieve a changes tuple of models.
% Actually, we want to have a notion of \emph{correctness}, because the function should not return a tuple of models that is not consistent.

% \begin{definition}[Correct Consistency Preservation Application Function]
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$ and $\consistencyorcfunction{\consistencypreservationruleset{}}$ an orchestration function for the consistency preservation rules.
%     We say that:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} \mathtext{is correct} \equivalentperdefinition \\
%         & \formulaskip
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \bot \lor \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \consistenttomath \consistencyrelationset{CR}
%     \end{align*}
% \end{definition}

\mnote{Conservativeness more relevant than correctness}
This, in fact, is a rather weak notion of correctness. 
Actually, an \gls{application function} that always return $\bot$ is correct according to that definition.
Due to the fact that the orchestration and application function have to operate conservatively, a binary correctness notion is not that relevant anyway.
Rather the degree of conservativeness and how to improve it is of special interest.
The question how such an orchestration can or should like it was introduced as \researchquestionref{rq:correctness:orchestration} and the degrees of freedom as well as a concrete approach will be presented as contribution \contributionref{contrib:correctness:orchestration} in \autoref{chap:orchestration}.


\subsection{Transformation Networks}

\mnote{Definition of transformation networks}
Based on the previous definitions of transformations, orchestration and application functions, we define what we consider a \emph{transformation network} and when we consider it \emph{correct}.
A transformation network is composed of transformations, an orchestration and an application function.
Although we define these artifacts specifically for one transformation network, i.e., an orchestration and application function according to their definitions is specific for one set of transformations, the goal will be to find an orchestration and application function that is independent from the actual transformations and the networks.

\todo{Maybe also metamodels in transformation and networks?}
\begin{definition}[Transformation Network]
    \label{def:transformationnetwork}
    Let $\transformationset{T}$ be a set of transformations, $\orcfunction{\transformationset{T}}$ an \gls{orchestration function} for these transformations and $\appfunction{\orcfunction{\transformationset{T}}}$ an \gls{application function}.
    A transformation network $\transformationnetwork{N}$ is a triple:
    \begin{align*}
        \transformationnetwork{N} = \tupled{\transformationset{T}, \orcfunction{\transformationset{T}}, \appfunction{\orcfunction{\transformationset{T}}}}
    \end{align*}
\end{definition}

\mnote{Correctness of transformation networks}
Correctness of a transformation network is given by correctness of both the individual transformation as well as the application function, according to \autoref{def:synchronizingtransformationcorrectness} and \autoref{def:applicationfunctioncorrectness}.
We will say that the transformations ensure \emph{local consistency}, because they are able to achieve consistency locally for two models, whereas the application function achieves \emph{global consistency} by applying the individual transformations in a ways such that all models are consistent according to all transformation afterwards.

\begin{definition}[Transformation Network Correctness]
    \label{def:transformationnetworkcorrectness}
    Let $\transformationnetwork{N} = \tupled{\transformationset{T}, \orcfunction{\transformationset{T}}, \appfunction{\orcfunction{\transformationset{T}}}}$ be a transformation network.
    We say that:
    \begin{align*}
        & 
        \transformationnetwork{N} \mathtext{is correct} \equivalentperdefinition \\
        & \formulaskip
        \forall \transformation{T} \in \transformationset{T} : \transformation{T} \mathtext{is correct} \land \appfunction{\orcfunction{\transformationset{T}}} \mathtext{is correct}
    \end{align*}
\end{definition}

\mnote{Conservativeness and compatibility in addition to correctness}
We have already indicated that we will show that the application function has to be conservative, which is why correctness is an essential property, but not the most interesting one to achieve.
Additionally, we already suggested that the consistency relations of the transformations are considered correct by definition, as there is no other specification to which they have to be correct, but we will discuss a notion of \emph{compatibility} to reflect when those relations contain unintended contradictions.
In summary, we made the following insight in this chapter.

\begin{insight}[Correctness Notion]
    A reasonable notion of correctness for networks of modular, independently developed transformations consists of correctness of the single transformations, which need to be synchronizing, and correctness of the application function that determines an execution order of the transformations.
    The more important property than correctness of the application function is its degree of conservativeness.
    Additionally, although theoretically not relevant for correctness, the relations defining when models are considered consistent have to fulfill some notion of compatibility to be useful.
\end{insight}

\mnote{Outlook: achieving correct transformation networks}
In the following chapters, we will thus define such a notion of compatibility, discuss how correctness of the individual synchronizing transformations can be achieved and finally how a correct and appropriate application function to perform the orchestration can be defined.
In summary, these following contributions together will allow to develop what we defined as a \emph{correct} transformation network.




% \section{Summary}

% Central Insights:
% \begin{itemize}
%     \item In networks, we need compatible consistency relations -> first RQ
%     \item In networks, we need synchronizing rather than bidirectional transformations -> second RQ
%     \item In networks, we need orchestration functions -> third RQ
%     \item Correctness is not the problem, optimality is the problem
%     \item We can only check dynamically whether a consistent state was reached due to Halting Problem. We cannot guarantee to always find a consistent state
% \end{itemize}



%%% THIS VERSION MAKES ORCHESTRATION ON ITS OWN AND DEFINES THE REQUIREMENTS FOR THAT. IT MAY REQUIRE THE RESULT TO BE CONSISTENT OR NOT
% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is a partial function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M})
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. It is partial, because it is only defined for consistent input model tuples and may not return a result for all possible changes to any model. It has to fulfill the following conditions:
%     \begin{align*}
%         &
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \exists \modeltuple{m'} \in \metamodeltupleinstanceset{M} :
%         \modeltuple{m'} = \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \\
%         %\land \modeltuple{m'} \consistenttomath \consistencyrelationset{CR} \\
%         & \formulaskip
%         \land \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : 
%         \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%         & \formulaskip \formulaskip 
%         \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}')\\
%         & \formulaskip \formulaskip
%         \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'}
%     \end{align*}
% \end{definition}


% It is obvious that we can define consistency preservation rules for which no execution order can be specified that returns a consistent tuple of models after certain changes. Consider the example in \autoref{fig:formal:noexecutionorder}. There exists no execution order for any input value that terminates. The transformations will always increase the value, although the defined relations could be fulfilled for the input value, but the transformations never find that solution.

% \begin{figure}
%     \centering
%     \includegraphics[width=\textwidth]{figures/correctness/formal/divergence_example.png}
%     \caption{Example for divergence}
%     \label{fig:formal:noexecutionorder}
% \end{figure}

% Although we will discuss restrictions to relations and transformations that reduce the chance that no solution can be found, it will not be possible to ensure that such a solution can always be found. This is due to the reason that transformations can perform arbitrary changes given the transformations Turing-completeness, which should not be restricted, because it is unclear which restrictions could be made without forbidding scenarios that should actually we supported. Thus, we assume that transformations are Turing complete.

% Finally, this makes it necessary that a function that applies \modellevelconsistencypreservationrules may not find an execution order that returns a consistent model, thus is should be able to also return $\bot$ as an indicator for that situation.

% We first give a basic definition for such a function without further specifying in which cases the function is expected to return a result other than $\bot$.

% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M})
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. Thus, it has to fulfill the following conditions:
%     {\setlength{\mathindent}{0em}
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = 
%         \begin{cases}
%             \modeltuple{m'}, & \begin{array}{l@{}}
%                 \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%                 \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : \\
%                 \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}') \\
%                 \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'} 
%             \end{array} \\
%             \bot, & otherwise
%         \end{cases}
%     \end{align*}
%     }
% \end{definition}

% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M})
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. Thus, it has to fulfill the following conditions:
%     {\setlength{\mathindent}{1em}
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = 
%         \begin{cases}
%             \modeltuple{m'}, & \begin{array}{l@{}}
%                 \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%                 \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : \\
%                 \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}') \\
%                 \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'} 
%             \end{array} \\
%             \bot, & otherwise
%         \end{cases}
%     \end{align*}
%     }
% \end{definition}



% \begin{definition}[Correct Consistency Preservation Application Function]
%     Let $\consistencyappfunction{\consistencypreservationruleset{}}$ be a consistency preservation application function for a set of \modellevelconsistencypreservationrules $\consistencypreservationruleset{}$ for a set of \modellevelconsistencyrelations $\consistencyrelationset{CR}$.
%     We say that:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} \mathtext{is correct} \equivalentperdefinition \\
%         & \formulaskip
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \consistenttomath \consistencyrelationset{CR}
%     \end{align*}
% \end{definition}




%Now it is obvious that the consistency preservation rules can actually do anything to achieve consistency, including returning always the same set of models that is consistent, although that may not be expected. We will discuss later which reasonable assumptions can be made to the behavior to on the hand not restrict the possibilities of the transformation developer and on the other hand be able to ensure some properties of the transformations and their execution.


%Two levels of correctness:
%\begin{enumerate}
    %\item Local correctness: a consistency relation is correct to the global relation and the CPR is to the relation, i.e. given two models and changes in them, the transformation can produce a change that restores consistency regarding the global consistency relation of these two models (i.e. there are some other models with which these two models would be consistent regarding the global specification) --> a network is locally correct, if this property is fulfilled
    %\item Global correctness: the binary relations together are equal to the global one and the execution function is able to find consistency models after a change to initially consistent models --> network is globally correct, if this property is fulfilled
%\end{enumerate}
%Potentiell ist lokale Korrektheit (zumindest einer CPR zu ihrer CR per Konstruktion) herstellbar -- das war auch das Ergebnis bisheriger Studien --, eventuell auch von einer CR zu einer globalen CR, obwohl die ja eigentlich meist nicht existiert, daher nehmen wir das als gegeben an.
%Dann zeigen, dass die globale Beziehung der Relationen nicht äquivalent ist zu den einzelnen lokalen, daher kommt hier zusätzliche Komplexität rein (Kompatibilitätsbegriff).
%Final muss noch die Ausführungsfunktion korrekt sein, hier aber Problem der Turing-Vollständigkeit. 
%Daher Einschränkungen an Transformationen finden bzw. ingenieurmäßige Ausführungsreihenfolge festlegen, die möglichst oft richtige Lösungen findet und sonst konservativ mit einem Fehler terminiert.


% \textbf{On top of ordinary bx correctness:}
% \begin{itemize}
    %\item Transformations need to be synchronizing
    %\item Consistency relations need to fulfill a notion of correctness
    %\item Exkurs:
    % \begin{itemize}
    % %\item Is compatibility a subclass of correctness? Is every correct set of relations compatible as well?
    % \item Problematisch: unser Konsistenzbegriff für Relationen (feingranulare Relationen) schließt keine Modelle aus, der Konsistenzbegriff hier aber schon. Wie realisiere ich die feingranularen Relationen, die dafür sorgen, dass nur genau ein Tupel von Modellen konsistent ist?
    % \item Wir müssen bei der Ableitung unseres Kompatibilitätsbegriffes erklären, dass bei uns der vollständige Ausschluss bestimmter Modelle nicht Teil einer feingranularen Konsistenzrelation sein darf, sondern Teil einer weiteren Spezifikation, die angibt, welche Modelle überhaupt valide sind. Denn so ist es in Transformationssprachen tatsächlich auch.
    % \end{itemize}
    %\item Execution function needs to be defined, which potentially induces requirements to the transformations.
% \end{itemize}


% Voraussetzungen:
% \begin{itemize}
%     \item Relationen müssen korrekt sein, d.h. sie müssen bzgl. einer globalen (meist eher implizit bekannten) n-ären Relation zwischen allen Modellen identisch sein. Eine n-äre Relation lässt sich nicht immer zerlegen (siehe Stevens), aber wir nehmen das an.
%     \item Die einzelne Transformation muss bzgl. ihrer Relation korrekt sein, d.h. sie muss bei Änderungen in beiden Modellen ein zur Relation konsistentes Modell liefern.
% \end{itemize}

%Ebenen der Korrektheit:
%\begin{itemize}
    %\item Relationen müssen korrekt sein, d.h. gegeben eine Nutzeränderung muss es überhaupt möglich sein eine konsistente Menge an Modellen zu finden. Wenn Transformationen etwas beliebigen tun dürfen geht das immer. Wir nehmen an, dass eine Nutzeränderung nicht rückgängig gemacht werden soll (bzw. wenn sie rückgängig gemacht werden würde eigentlich die Änderung invalide war, d.h. keine Konsistenz im Netzwerk hergestellt werden kann). Daher sind Relationen nur korrekt, wenn für fixierte Elemente, die durch eine Nutzeränderung entstehen können, eine Modellmenge abgeleitet werden kann, die bzgl. der Relationen konsistent ist. D.h. gegeben einige Elemente muss es eine Modellmenge geben, die in allen Relationen liegt und die diese Elemente enthält (-> Kompatibilitätsbegriff). Wir betrachten in Kapitel ?, wie man Kompatibilität präzise definieren und feststellen/garantieren kann.\\
    %Resultat: Gegeben eine Änderung ist es möglich eine Transformation anzugeben, die aus der Änderung ein konsistentes Modell produziert.
    %\item Einzelne Transformationen müssen korrekt sein: Wir fordern Korrektheit der Transformation sowieso. Allerdings machen in einem Netzwerk verschiedene Transformationen Änderungen an allen Modellen, d.h. wir müssen nicht den "normalen" Transformationsfall unterstützen, dass Deltas in einem Modell ins andere übertragen werden, um Konsistenz herzustellen, sondern die Transformationen müssen \emph{synchronisierend} sein, also Deltas in beiden Modelle annehmen und dann Konsistenz herstellen. Wir definieren diese Synchronisationseigenschaft und betrachten in Kapitel ?, welcher zusätzlichen Anforderungen sich dadurch bzgl. EMOF-Modellen ergeben. Der Input sind Deltas in zwei Modellen, und einzelne Deltas sind potentiell als "authoritative" definiert, was bedeutet, dass die erzeugten/geänderten Elemente nicht noch einmal geändert/gelöscht werden dürfen. Das realisiert die Anforderung, dass Nutzeränderungen nicht rückgängig gemacht werden dürfen. \\
    %Resultat: Gegeben Änderungen in zwei Modellen (mit potentiell authoritativen Änderungen) gibt die Transformation ein konsistentes (bzgl. der Konsistenzrelation) Modellpaar zurück. 
    %\item Korrektheit der Anwendungsfunktion: Die Anwendungsfunktion muss die Transformationen in einer 
%\end{itemize}


% \todo{Überlegen, wo hier die Definition von (undirektionalen Relationen) rein muss.}
% Präzisere Eigenschaften:
% \begin{itemize} 
%     \item Synchronisationseigenschaft: Eine Transformation kann mit Änderungen an mehreren Modellen umgehen, d.h. gegeben zwei konsistente Modelle + Änderungen an beiden resultiert in zwei Modellen, die konsistent bzgl. der Relation(en) zwischen den Metamodellen sind
%     \item 
% \end{itemize}  

% \begin{itemize}
%     \item Kompatibilität entsprechend Modularisierungsebene
%     \item Synchronisation auf Operationalisierungsebene: Abwägen, dass eine Transformation verschiedene Zustände sehen könnte, auf denen sie ausgeführt wird. Aber letztendlich muss sie damit klarkommen, dass zwei Modelle geändert wurden. 
% \end{itemize}

%TODO:
%\begin{itemize}
    %\item Authoritative Modelle (bzw. eher authoritative Regionen) diskutieren (Verweis Stevens)
%\end{itemize}



% \section{Local Correctness}

% Simple solution: we define a transformation which normatively implies a relation, thus it is correct by construction. From a theoretical perspective this is easy to reach, from a practical it is not.
% However, in contrast to our definition of synchronizing transformations, ordinary transformations are only able to process changes in one model and update the other accordingly. Together with the assumption that both models were consistent before does not fit with our scenario, because if one model is modified, the other may be modified as well by another transformation across another path, before a transformation is executed. Thus, both models may have been modified.
% We consider the following situation: Models A and B were consistent. Model A was changed an we have the changes at hand. Additionally, B was modified because there were other changes propagated through the network. 
% We distinguish all cases of modifications to B that may have violated a consistency relation between A and B (according to our fine-grained consistency notion) and consider what we have to do there (e.g. find-or-create-pattern).
% Put empirical analysis here.


% \section{Correct APP function}

% We make the following approach: Always assume there is a solution and start executing the transformation (for now in any order). Finally, the network has to terminate at a fixed point. We investigate, what the reasons may be that it does not try to avoid them.

% These reasons can lie in the relations:
% - relations cannot be completely unfulfillable, as the empty models are always consistent, thus there can always be CPRs that result in a consistent set of models
% - however, if relations contain pairs that can never be in any consistent model tuple they improve proneness to errors, because a CPR may return that pair, which will never fit to any result of any other transformation. Thus, this should not be allowed -> compatibility

% These reasons can also lie in the transformations:
% - Transformations can make choices and they make choices that are always incompatible to other (refer to example)

% Essentially there are two problems: alternation and divergence


% \subsection{Other thought}
% If each element occurs in each relation only once (so always 1:1 mappings) and if we have compatibility, then any transformation order would return exactly the one model tuple that fits.
% However: In that case we would have confluence, every information must directly be available in B from A without a transitive propagation over C. This is not what we want. So there must in general be more than one option a transformation is fine with that to reflect the information that another transformation may add or change.


%\todo{Hippocraticness is not necessary but needs to be discussed}

% Goal:
% - Find a solution in as much cases as possible, abort in the others (conservatively)
% - To do so: reduce cases in which there is no such function
% - To do so: ensure that relations are defined in a way such that they do not allow a locally correct set of CPRs that has no APP solution. If there is a pair of models (or elements of a fine-grained relation) in a relation, a CPR may return it. But if there is no consistent tuple of models containing these two, it does not make any sense to consider these elements (even worse, if we have monotony, adding these elements makes the network unsolvable). For that reason, we need compatibility.
