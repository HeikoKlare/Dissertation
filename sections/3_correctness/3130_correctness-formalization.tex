%%
%% FORMALIZATION
%%
\section{A Formal Notion of Transformation Networks}
\label{chap:correctness:formalization}

\mnote{Formalization of transformation networks and correctness}
We have so far discussed a general notion of consistency and its preservation with a focus on a modular way of specifying it.
This notion was introduced in a rather informal way to first be able to discuss correctness notions and determine which notion is relevant for the considerations in this thesis.
In the following, we define a formal notion of consistency and its preservation, based on the informal explanation given before.
It extends the one we have presented in previous work~\owncite{klare2021Vitruv-JSS}.
We also give a precise definition of notions for correctness between the artifacts of a modular specification.
Furthermore, we now focus on transformation-based approaches, i.e., we consider specifications that transform changes within one or more models into changes in one or more other models, as a specialization of the general notion for consistency preservation used before.

%Allgemeine Definition Transformationsnetzwerke:
%\begin{itemize}
    %\item Definition Transformation aus Relation und Wiederherstellungsroutinen; Routinen nehmen n Modelle und n Deltasequenzen (eine pro Modell) und liefern n Deltasequenzen zurück.
    %\item Im Allgemeinen könnte eine Transformation beliebige dieser Deltasequenzen modifizieren. Wir verlangen jedoch, dass eine Transformation nur Deltas anhängt, also die Sequenzen länger werden
    %\item Genauer beschränken wir auch, welche Sequenzen eine Transformation sehen und ändern darf, genau gesagt darf sie die Sequenzen von zwei Modellen sehen und eine davon verlängern.
    %\item Hier kommt bereits der Unterschied zu bisherigen Transformationen, denn die sehen nur Deltas an einem Modell und erzeugen Deltas an dem anderen. Das ist bei uns schon gänzlich anders. Bidirektionale Transformationen unterstützen das im Übrigen auch nicht, sondern sind nur Spezifikationen, aus denen sich Wiederherstellungsroutinen für beide Richtungen ableiten lassen (siehe Stevens 2010)
    %\item Relationen in erster Instanz auf Modellebene (also bzgl. ganzer Modelle, nicht einzelner Modellelemente) definieren
    %\item Direkt als multidirektionale Transformation definieren, also beliebig viele geändert Ein- und Ausgabemodelle (oder jeweils nur eins?)
    %\item Korrektheit einer Transformation (nach Stevens) definieren!
    %item Versuchen den Konkatenationsoperator zu definieren ohne dass er alle Metamodelle referenzieren muss (also Transformation wählt aus einer großen Eingabemenge relevanten Modelle aus, ändert relevante und dann fügt der Operator sie in die große Menge ein)
    %\item Definition Transformationsnetzwerk als Tupel aus Metamodellen, Transformationen und einer Ausführungsfunktion. 
    %\item Die Ausführungsfunktion führt für eine gegebene Änderung eine Auswahl der Transformationen nacheinander aus.
    %\item Korrektheit eines Netzwerkes definieren: Die Ausführungsfunktion erzeugt eine Transformationssequenz, die angewendet auf eine Änderung für alle Änderungen ein korrektes Ergebnisse produziert, d.h. die Modelle sind konsistent bzgl. allen Konsistenzrelationen.
%\end{itemize}


\subsection{Modular Consistency Specification}

\mnote{Extensional specifications are relations}
As discussed informally before, an extensional specification of consistency defines a relation between models by enumerating all tuples of models that are considered consistent.

\begin{definition}[\ModelLevelConsistencyRelation]
    \label{def:modellevelconsistencyrelation}
    Given a tuple of metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$, a \emph{\modellevelconsistencyrelation} $\consistencyrelation{CR}{}$ is a relation for instances of the metamodels $\consistencyrelation{CR}{} \subseteq \metamodeltupleinstanceset{M} = \metamodelinstanceset{M}{1} \times \dots \times \metamodelinstanceset{M}{n}$.

    For a tuple of models $\modeltuple{m} \in \metamodeltupleinstanceset{M}$, we say that:
    \begin{align*}
        \modeltuple{m} \consistenttomath \consistencyrelation{CR}{} \equivalentperdefinition \modeltuple{m} \in \consistencyrelation{CR}{}
    \end{align*}
    Otherwise, we call $\modeltuple{m} \inconsistenttomath \consistencyrelation{CR}{}$.
\end{definition}

\mnote{Start with coarse-grained model-level relations}
We consider a tuple of models consistent if the consistency relation contains it.
This conforms to existing consistency definitions for bidirectional transformations~\cite{stevens2010sosym}.
We denote this kind of consistency relation as \emph{model-level}, because we later need to refine the notion of consistency relations to the level of \metaclasses and distinguish them.

\mnote{Modular notions of consistency}
If a single relation describes consistency between all relevant models, consistency is defined by means of model tuples being contained in that relation. We call such a relation \emph{monolithic}.
If a relation only defines consistency between some of the relevant models and the global consistency relation is defined by a combination of several such relations, we need an explicit definition of such a \emph{modular} notion of consistency.
For the sake of simplicity, we focus on \emph{binary} relations as a modular representation of consistency.

\begin{definition}[Model-Level Consistency] 
    \label{def:modellevelconsistency}
    Let $\metamodeltuple{M} =  \tupled{\metamodelsequence{M}{n}}$ be metamodels and let $\consistencyrelation{CR}{i,k} \subseteq \metamodelinstanceset{M}{i} \times \metamodelinstanceset{M}{k}$ be a binary \modellevelconsistencyrelation for $\metamodel{M}{i}, \metamodel{M}{k} \in \metamodeltuple{M}$. 
    We say that a model tuple $\modeltuple{m} = \tupled{\model{m}{1}, \dots, \model{m}{n}} \in \metamodeltupleinstanceset{M}{}$ is \emph{consistent to} $\consistencyrelation{CR}{i,k}$ if, and only if, the instances of $\metamodel{M}{i}$ and $\metamodel{M}{k}$ are in that relation:
    \begin{align*} 
        &
        \modeltuple{m} \consistenttomath \consistencyrelation{CR}{i,k} \equivalentperdefinition 
        \tupled{\model{m}{i},\model{m}{k}} \in \consistencyrelation{CR}{i,k}
    \end{align*}
    For a set of binary \modellevelconsistencyrelations $\consistencyrelationset{CR}$ for metamodels $\metamodeltuple{M}$, we say that a tuple of models $\modeltuple{m} \in \metamodeltupleinstanceset{M}{}$ is \emph{consistent to} $\consistencyrelationset{CR}$ if, and only if, it is consistent to each consistency relation in that set:
    \begin{align*} 
        &
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \equivalentperdefinition
        \forall \consistencyrelation{CR}{} \in \consistencyrelationset{CR} : \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}
    \end{align*}
\end{definition}

\mnote{Exemplary binary relations}
The definition states that models are consistent to a set of \modellevelconsistencyrelations if they are consistent to each relation in that set.
Consider, for example, for $\model{m}{i} \in \metamodelinstanceset{M}{i}$ the relations $\consistencyrelation{CR}{1} = \setted{\tupled{\model{m}{1}, \model{m}{2}}}$, $\consistencyrelation{CR}{2} = \setted{\tupled{\model{m}{2},\model{m}{3}}}$, and $\consistencyrelation{CR}{3} = \setted{\tupled{\model{m}{1}, \model{m}{3}}}$. Then the model tuple $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}$ is consistent to these relations.
These consistency relations are equivalent to a monolithic relation $\consistencyrelation{CR}{} = \setted{\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}}$, because a model tuple $\modeltuple{m}$ is consistent to $\consistencyrelation{CR}{}$ exactly when it is consistent to $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$.

\mnote{Relation uniqueness assumption}
For reasons of simplicity, we assume only one consistency relation between each pair of metamodels.
This also includes that there are no two consistency relations $\consistencyrelation{CR}{i,j}$ and $\consistencyrelation{CR}{j,i}$ for metamodels $\metamodel{M}{i}$ and $\metamodel{M}{j}$, which means that the relations do not have a direction.
This assumption is without loss of generality, because two relations between the same metamodels are, independent from their direction, equivalent to only considering their intersection, i.e., only the model pairs that are considered consistent by both relations.

% \subsection{Expressiveness of Modular Consistency Specifications}
% \label{chap:correctness:formalization:expressiveness}

\mnote{Expressiveness of modular specifications}
Although in the preceding exemplary case the binary relations are equivalent to a monolithic relation, such an equivalence is not always given. In general, two interesting insights come along with the definition of consistency based on modular relations. First, expressiveness of defining consistency modularly by a set of relations is not equivalent to defining one monolithic relation. Second, a modular definition of consistency can easily contain contradictions, which can lead to an empty tuple of consistent models.

\begin{figure}
    \centering
    \input{figures/correctness/notion/binary_definable.tex}
    %\includegraphics[width=\textwidth]{figures/correctness/notion/binary_definable.png}
    \caption[Monolithic consistency relation that cannot be modularized]{A monolithic consistency relation that cannot be expressed by binary relations. Small circles denote models and blue, solid hyperedges relate tuples of consistent models.}
    \label{fig:correctness:binary_definable}
\end{figure}

\mnote{Binary relations reduce expressiveness}
Obviously, combining binary relations has not the same expressiveness as defining a monolithic relation.
For example, binary relations cannot express the monolithic relation $\consistencyrelation{CR}{} = \setted{\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}'}, \tupled{\model{m}{1}, \model{m}{2}', \model{m}{3}}, \tupled{\model{m}{1}', \model{m}{2}, \model{m}{3}}}$, as depicted in \autoref{fig:correctness:binary_definable}.
The binary relations necessarily need to contain $\tupled{\model{m}{1}, \model{m}{2}}$ because $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}'} \in \consistencyrelation{CR}{}$, $\tupled{\model{m}{1}, \model{m}{3}}$ because $\tupled{\model{m}{1}, \model{m}{2}', \model{m}{3}} \in \consistencyrelation{CR}{}$, and $\tupled{\model{m}{2}, \model{m}{3}}$ because $\tupled{\model{m}{1}', \model{m}{2}, \model{m}{3}} \in \consistencyrelation{CR}{}$. 
However, this would mean that $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}$ is consistent to the binary relations although it is not consistent to the monolithic relation $\consistencyrelation{CR}{}$.
Thus, using sets of binary relations in contrast to a single monolithic relation reduces expressiveness.
\textcite{stevens2020BidirectionalTransformationLarge-SoSym} discusses the property of a multiary relation to be expressible by binary ones as \emph{binary-definable} in detail.
She proposes restrictions to binary relations that may be sufficient and still practical for expressing consistency, such as a notion of \emph{binary-implemented} relations.
We have reasoned the assumption that relations are specified independently and thus modularly, thus we have to accept these theoretic restrictions in expressiveness anyway.

\begin{figure}
    \centering
    \input{figures/correctness/notion/contradictions_example.tex}
    %\includegraphics[width=0.9\textwidth]{figures/correctness/notion/contradictions_example.png}
    \caption[Example for incompatible consistency relations]{Modular consistency relations, which together cannot be fulfilled (left) or which cannot be fulfilled for some of the consistent model pairs (right). Small circles denote models and (blue) lines relate consistent model pairs.}
    \label{fig:correctness:contradictions_example}
\end{figure}

\mnote{Contradictions of binary relations}
Additionally, it can easily occur that multiple binary relations can be fulfilled by certain models, but no tuple of models exists that is consistent to all of them. Consider the relations $\consistencyrelation{CR}{1} = \setted{\tupled{\model{m}{1}, \model{m}{2}}}$, $\consistencyrelation{CR}{2} = \setted{\tupled{\model{m}{2}, \model{m}{3}'}}$, and $\consistencyrelation{CR}{3} = \setted{\tupled{\model{m}{1}, \model{m}{3}}}$, which are also depicted at the left of \autoref{fig:correctness:contradictions_example}.
Although for each of these relations a consistent pair of models exists, which is exactly the one defined in each relation, no tuple of models exists that fulfills their combination.
This example illustrates the worst case, in which no consistent models exist for a set of relations.
In other cases, only for some models that are consistent according to one or some of the relations no model tuple may exist that is consistent to all relations.
Consider the relations $\consistencyrelation{CR}{1} = \setted{\tupled{\model{m}{1}, \model{m}{2}}}$, $\consistencyrelation{CR}{2} = \setted{\tupled{\model{m}{2}, \model{m}{3}}, \tupled{\model{m}{2}, \model{m}{3}'}}$, and $\consistencyrelation{CR}{3} = \setted{\tupled{\model{m}{1}, \model{m}{3}}}$, which are also depicted at the right of \autoref{fig:correctness:contradictions_example}.
In this case, the tuple $\tupled{\model{m}{1}, \model{m}{2}, \model{m}{3}}$ is considered consistent to the relations, but although $\tupled{\model{m}{2}, \model{m}{3}'} \in \consistencyrelation{CR}{2}$ there exists no consistent model tuple containing $\model{m}{3}$, i.e., there is no $\model{m}{1}^* \in \metamodelinstanceset{M}{1}$ such that $\tupled{\model{m}{1}^*, \model{m}{2}, \model{m}{3}'}$ is consistent to all relations.

\mnote{Forbidden models through relations}
It is easy to see that one monolithic relation can be equally represented by an arbitrary number of sets of binary relations by simply adding model pairs to these binary relations that are never consistent to the other relations, like we have seen for the pair $\tupled{\model{m}{2}, \model{m}{3}'}$ in the previous example.
This means that the combination of relations can lead to the situation that some models are actually forbidden (like $\model{m}{3}'$ in the example before) due to the combination of consistency relations.
Whether such a situation is intended can eventually depend on the semantics of the models and relations, but we will discuss which situations are unintended in general.
We have informally discussed this as a notion of \emph{compatibility}, for which we investigate in \autoref{chap:compatibility} how far this behavior should be expected.


\subsection{Incremental Consistency Preservation}
\label{chap:correctness:formalization:incremental_inductive}

\mnote{Preserving consistency}
While the previous discussion only concerned when models are considered consistent, it is of particular interest to ensure that consistency of models is preserved.
We informally introduced such specifications as consistency preservation rules.
In the following, we will restrict ourselves to \emph{incremental} and \emph{inductive} consistency preservation and give a precise definition for that.
This means that we make the following assumptions to the process.
\begin{properdescription}
    \item[Information Preservation (Incrementality):] After a change to one model, the others are not generated from scratch but updated according to the performed changes. This ensures that information that cannot be generated but was added by users to the other models is preserved.
    \item[Consistency Assumption (Induction):] We assume models to be consistent before a change is processed by consistency preservation rules. Otherwise, the preservation rules would need to be able to handle arbitrary states of the models and intentions of performed changes could not be incorporated to restore consistency.
\end{properdescription}
Incrementality is an essential requirement whenever consistency shall be preserved to avoid information loss. Otherwise, if for example Java code is always generated anew after changes to a \gls{UML} model instead of adapting it incrementally, all implementations of methods in Java get lost every time the \gls{UML} model is changed.
Inductivity, on the other hand, may not be necessary, as consistency preservation rules could also be defined to restore consistency from arbitrarily inconsistent states.
We, however, make this assumption to avoid requiring from the consistency preservation rules that they need to be able to process an inconsistent state without knowing which changes introduced it.
From a theoretical point of view, we could omit that requirement, but this would make the specification of consistency preservation rules impractically complicated, such that omitting that requirement is not practically relevant anyway.

\mnote{Monolithic and modular consistency preservation}
Like we have discussed for consistency preservation rules in general, incremental preservation rules can be realized in an either monolithic or modular way.
A monolithic consistency preservation rule takes a tuple of models that is consistent to a consistency relation and a change to these models, and it returns a tuple of models that is consistent again.
In a modular specification of consistency preservation rules, a set of such rules is given of which each preserves consistency of a subset of the given models according to a modular consistency relation.
In our case, we consider such rules for two models, each of them restoring consistency according to a binary consistency relation.

\mnote{Drawbacks of existing consistency preservation approaches}
In existing terminology for transformations, a consistency preservation rule that restores consistency of models according to a consistency relation in one direction is called \emph{directional transformation}~\cite{stevens2010sosym} or \emph{consistency restorer}~\cite{stevens2020BidirectionalTransformationLarge-SoSym}.
That terminology usually considers model states instead of changes and defines a consistency preservation rule $\consistencypreservationrule{}$ for metamodels $\metamodel{M}{1}$ and $\metamodel{M}{2}$ to modify the instance of $\metamodel{M}{2}$ for restoring consistency as:
\begin{align*}
    \consistencypreservationrule{}: \metamodelinstanceset{M}{1} \times \metamodelinstanceset{M}{2} \rightarrow \metamodelinstanceset{M}{2}
\end{align*}
This notion, however, has two properties that imply essential drawbacks:
\begin{properdescription}
    \item[State-Based:] Information about the performed changes that led to the inconsistent state is missing. Thus the specification is not aware of how the inconsistent state was reached.
    \item[Unidirectional:] The specification is unidirectional, which always requires to only update one model to restore consistency.
\end{properdescription}
State-based transformations suffer from not knowing which changes were made that led to an inconsistent state, and reconstructing them from the difference between two states is only a heuristic approximation~\cite{diskin2011StateToDeltaSymmetric-MODELS}.
This, for example, includes that information about elements that were moved or renamed can potentially not be reconstructed, leading to elements that are deleted and created anew and losing all information that was potentially added to them.
Unidirectionality may be reasonable when assuming that only one of the models was modified. In that case, it is sufficient to update the other model to restore consistency.
With a modular specification of consistency preservation, however, several consistency preservation rules modifying the same models may need to be executed.

\begin{figure}
    \centering
    \input{figures/correctness/notion/not_unidirectional.tex}
    %\includegraphics[width=0.7\textwidth]{figures/correctness/notion/not_unidirectional.png}
    \caption[Unidirectional consistency preservation in networks]{Execution of consistency preservation rules of which at least one cannot be unidirectional, because both involved models (circles) have been modified by a user or other consistency preservation rules.}
    \label{fig:correctness:unidirectionality_example}
\end{figure}

\mnote{Counterexample for unidirectionality}
\autoref{fig:correctness:unidirectionality_example} depicts an example in which unidirectional consistency preservation rules cannot be applied when used in combination with other such rules.
If the depicted consistency preservation rules $\consistencypreservationrule{1}$ and $\consistencypreservationrule{2}$ are executed first, $\consistencypreservationrule{3}$ cannot be unidirectional, because both involved models $\model{m}{1}$ and $\model{m}{3}$ have been modified by either the user or another consistency preservation rule.
Thus, it is, in general, not possible to only consider changes in one model and unidirectionally propagate them to the other model.
In consequence, the preservation rules need to be able to deal with changes performed in both models and, consequentially, need to update both models to reflect the changes in each other.

\mnote{Synchronizing consistency preservation rules}
To be able to combine several consistency preservation rules without the discussed drawbacks, we define a \emph{synchronizing} rather than a unidirectional notion of them.
Those rules can react to changes in both models and produce changes in both models again.
This is sometimes also called the capability of handling \emph{concurrent} modifications (e.g.~\cite{leblebici2014IncrementalTGGSurvey-GTVMT}).
To precisely define this behavior, we introduce a notion of \emph{changes} and \emph{consistency preservation rules}, which we also refer to as \emph{synchronizing} consistency preservation rules.

\mnote{Changes as functions}
As motivated before, we base our notion of consistency preservation on changes to explicitly express how an inconsistent state was derived from a previously consistent one.
We consider these changes as functions that take a model and return a new one.
They are not restricted to a specific model but defined for all instances of a metamodel, because a change is supposed to represent how specific elements are modified, such as adding, removing or modifying them.
Thus, they can be applied to any models containing these affected elements.
This is also how actual implementations, such as the one in the \gls{EMF} behave.
When elements affected by a change are not present in a model, applying the change may fail.
For that reason, we consider the function describing a change to be partial.
We denote partiality by returning $\bot$ for inputs the function is undefined for.
\begin{definition}[Change]
    \label{def:change}
    Given a metamodel $\metamodel{M}{}$, a change $\change{\metamodel{M}{}}$ is a partial function that takes an instance of that metamodel and returns another one or $\bot$:
    \begin{align*}
        \change{\metamodel{M}{}}: \metamodelinstanceset{M}{} \rightarrow \metamodelinstanceset{M}{} \cup \setted{\bot}
    \end{align*}
    We denote the identity change, i.e., the one always returning the input model, as $\identitychange$:
    \begin{align*}
        \identitychange(x) \equalsperdefinition x
    \end{align*}
    We denote the universe of all changes in $\metamodel{M}{}$, i.e., all injective subsets of $\metamodelinstanceset{M}{} \times \metamodelinstanceset{M}{}$, as:
    \begin{align*}
        \changeuniverse{\metamodel{M}{}} \equalsperdefinition \setted{\change{\metamodel{M}{}} \subseteq \metamodelinstanceset{M}{} \times \metamodelinstanceset{M}{} \mid
        \forall \tupled{\model{m}{1}, \model{m}{2}}, \tupled{\model{m}{1}, \model{m}{2}'} \in \change{\metamodel{M}{}} : \model{m}{2} = \model{m}{2}'}
    \end{align*}
\end{definition}
\begin{definition}[Change Tuple]
    \label{def:changetuple}
    For a given metamodel tuple $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$, we denote a tuple of changes to an instance of each metamodel as:
    \begin{align*}
        \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodel{M}{1}} \times \dots \times \changeuniverse{\metamodel{M}{n}}
    \end{align*}
    We define the universe of change tuples in instance tuples of 
    $\metamodeltuple{M}$ as:
    \begin{align*}
        \changeuniverse{\metamodeltuple{M}} \equalsperdefinition \changeuniverse{\metamodel{M}{1}} \times \dots \times \changeuniverse{\metamodel{M}{n}}
    \end{align*}
    We define the application of a change tuple $\changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}}$ to a model tuple $\modeltuple{m} = \tupled{\modelsequence{m}{n}} \in \metamodeltupleinstanceset{M}$ as the element-wise application:
    \begin{align*}
        \changetuple{\metamodeltuple{M}}(\modeltuple{m}) \equalsperdefinition \tupled{\change{\metamodel{M}{1}}(\model{m}{1}), \dots, \change{\metamodel{M}{n}}(\model{m}{n})}
    \end{align*}
\end{definition}

\mnote{Change behavior}
For us, it does not matter how the function behaves in cases in which the encoded change cannot be applied, e.g., because the changed or removed element does not exist. The function may do nothing, i.e., return the identical model, or even be undefined for those models, i.e., be partial and return $\bot$.
%
%\mnote{Reasonable change behavior}
In fact, we do not restrict the actual behavior of a change in any way.
It may return an empty model regardless of the input, or it may perform arbitrary changes to different models instead of affecting only specific elements.
Since we do not need such restrictions, they are not reflected in the formalism.

\mnote{Consistency preservation rules}
With that notion of changes, we can define consistency preservation rules as functions that receive two models and changes to them, and that return new changes to both models.
While the general definition does not prescribe this, we assume the resulting changes to include the input changes such that not both of them have to be executed consecutively.
This will also be reflected by a correctness notion for such rules.

\begin{definition}[Consistency Preservation Rule]
    \label{def:consistencypreservationrule}
    Let $\consistencyrelation{CR}{} \subseteq \metamodelinstanceset{M}{1} \times \metamodelinstanceset{M}{2}$ be a binary \modellevelconsistencyrelation between metamodels $\metamodel{M}{1}$ and $\metamodel{M}{2}$.
    A \emph{consistency preservation rule} $\consistencypreservationrule{\consistencyrelation{CR}{}}$ for the relation $\consistencyrelation{CR}{}$ is a function:
    \begin{align*}
        \consistencypreservationrule{\consistencyrelation{CR}{}} : (\metamodelinstanceset{M}{1}, \metamodelinstanceset{M}{2}, \changeuniverse{\metamodel{M}{1}}, \changeuniverse{\metamodel{M}{2}}) \rightarrow (\changeuniverse{\metamodel{M}{1}}, \changeuniverse{\metamodel{M}{2}}) \cup \setted{\bot}
    \end{align*}
\end{definition}

\mnote{Partial consistency preservation rules}
For reasons of practical applicability, the rules need to be partial, as we may not want to require them to be able to process arbitrary models and changes.
Like for changes, we denote this partiality by allowing the function to return $\bot$.
First, this is because we do not require it to produce changes when the input models were not consistent.
Second, even if the input models are consistent, it may not be possible to preserve consistency for the given changes.
For example, if conflicting changes in both changes are made, i.e., changes that require one of them to be reverted, it may be desired that the consistency preservation rule does not return an unexpected result but to indicate a failure by returning $\bot$.
Our formalism does not restrict such a behavior, in fact it even allows to always return the same changes or to return changes that always deliver empty models.
Finally, it is up to the developer to define reasonable consistency preservation rules and to define in which cases the function does not return a result.

\mnote{Conformance to existing definitions}
This notion of synchronizing consistency preservation conforms to the definition of \emph{synchronizers} given by \textcite{xiong2013SynchronizingConcurrentUpdates-SoSym}, which also reflect the case that both models have been modified and can be updated by the consistency preservation rule.
They do, however, encode the changes in terms of new model states rather than explicit changes.

\mnote{Correctness notion}
To consider a consistency preservation rule \emph{correct}, it has to return changes that, when applied to the input models, result in models that are consistent according to the \modellevelconsistencyrelation for which the preservation rule is defined.
This conforms to the notion of correctness defined for bidirectional transformations~\cite{stevens2010sosym} and the notion of consistency given for synchronizers by \textcite{xiong2013SynchronizingConcurrentUpdates-SoSym}.

\begin{definition}[Consistency Preservation Rule Correctness]
    \label{def:consistencypreservationrulecorrectness}
    We call a consistency preservation rule $\consistencypreservationrule{\consistencyrelation{CR}{}}$ \emph{correct} if, and only if, it either returns $\bot$ or changes that applied to the input models yield models that are consistent to $\consistencyrelation{CR}{}$:
    \begin{align*} &
        \consistencypreservationrule{\consistencyrelation{CR}{}} \correctmath \equivalentperdefinition
        \forall 
        \model{m}{1} \in \metamodelinstanceset{M}{1}, 
        \model{m}{2} \in \metamodelinstanceset{M}{2},
        \change{\metamodel{M}{1}} \in \changeuniverse{\metamodel{M}{1}},
        \change{\metamodel{M}{2}} \in \changeuniverse{\metamodel{M}{2}} : \\
        & \formulaskip
        \bigl( \exists 
        \change{\metamodel{M}{1}}' \in \changeuniverse{\metamodel{M}{1}},
        \change{\metamodel{M}{2}}' \in \changeuniverse{\metamodel{M}{2}} :
        \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{1}, \model{m}{2}, \change{\metamodel{M}{1}}, \change{\metamodel{M}{2}}) = (\change{\metamodel{M}{1}}', \change{\metamodel{M}{2}}') \\
        & \formulaskip\formulaskip
        \Rightarrow
        \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \change{\metamodel{M}{2}}'(\model{m}{2})} \consistenttomath \consistencyrelation{CR}{} \bigr)
    \end{align*}
\end{definition}

\mnote{Reasonable consistency preservation rules}
This definition does not restrict how the input and output changes are related.
In fact, a valid (and especially correct) consistency preservation rule could always return identity changes.
In consequence, the rule would simply revert all input changes to achieve a consistent state.
Although this may not be the expected behavior, there is no reason to restrict this behavior by definition.
Actually, the developer should specify a preservation rule in a \emph{reasonable} way, such that it defines an expected behavior.

\mnote{Transformations}
We have discussed that consistency preservation rules can be derived from consistency relations and that consistency preservation rules can imply the consistency relations by their image, i.e., the set of all models that can be derived by applying the consistency preservation rule to any models and changes for which it is defined.
In practice there will only be one of these specifications and the other is implied or derived.
We thus define a \emph{synchronizing transformation}, in extension to \emph{bidirectional transformations}~\cite{stevens2010sosym}, as an artifact that encapsulates a \modellevelconsistencyrelation together with a consistency preservation rule, no matter which of them is defined and which is derived or implied.

\begin{definition}[Synchronizing Transformation]
    \label{def:synchronizingtransformation}
    Let $\consistencyrelation{CR}{}$ be a \modellevelconsistencyrelation and $\consistencypreservationrule{\consistencyrelation{CR}{}}$ a consistency preservation rule that restores consistency according to that relation.
    A \emph{synchronizing transformation} is a pair $\transformation{t} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$.
\end{definition}

\mnote{Transformation correctness}
We also use the short term \emph{transformation} for a synchronizing transformation.
Correctness of a transformation is then given by correctness of its consistency preservation rule.

\begin{definition}[Synchronizing Transformation Correctness]
    \label{def:synchronizingtransformationcorrectness}
    Let $\transformation{t} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$ be a synchronizing transformation.
    We say that $\transformation{t}$ is \emph{correct} if, and only if, $\consistencypreservationrule{\consistencyrelation{CR}{}}$ is correct according to \autoref{def:consistencypreservationrulecorrectness}:
    \begin{align*}
        &
        \transformation{t} \correctmath \equivalentperdefinition \consistencypreservationrule{\consistencyrelation{CR}{}} \correctmath
    \end{align*}
\end{definition}

\mnote{Hippocraticness}
Transformations are usually expected to by \emph{hippocratic}~\cite{stevens2010sosym}.
This means that a transformation, or more precisely its consistency preservation rule, does not perform any changes if the input changes applied to the input models already yield consistent models.
We define the application of hippocraticness to synchronizing transformations as follows.
\begin{definition}[Hippocratic Synchronizing Transformation]
    \label{def:hippocratictransformation}
    Let $\transformation{t} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$ be a transformation for metamodels $\metamodel{M}{1}$ and $\metamodel{M}{2}$.
    We say that $\transformation{t}$ is \emph{hippocratic} if, and only if, it returns the input changes if their application to the input models yields consistent models:
    \parameterizeformat{
    \begin{align*}
        &
        \transformation{t} \mathtextspacearound{hippocractic} \equivalentperdefinition
        \forall
        \model{m}{1} \in \metamodelinstanceset{M}{1}, \model{m}{2} \in \metamodelinstanceset{M}{2}, 
        \change{\metamodel{M}{1}} \in \changeuniverse{\metamodel{M}{2}}, \change{\metamodel{M}{2}} \in \changeuniverse{\metamodel{M}{2}} : \\
        & #1 #2
        \tupled{\change{\metamodel{M}{1}}(\model{m}{1}), \change{\metamodel{M}{2}}(\model{m}{2})} \in \consistencyrelation{CR}{} \Rightarrow \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{1}, \model{m}{2}, \change{\metamodel{M}{1}}, \change{\metamodel{M}{2}}) = (\change{\metamodel{M}{1}}, \change{\metamodel{M}{2}})
    \end{align*}
    }{\formulaskip}{\formulaskip[0.5em]}%
\end{definition}

\mnote{Benefits of hippocraticness}
Although hippocraticness is not a necessary requirement for our considerations in most cases, it is usually a desired property in practice~\cite{stevens2010sosym}.
One benefit of hippocraticness with regards to transformations is given if a transformation is only defined by its consistency preservation rule and thus implies the underlying consistency relation as its fixed points, as discussed in \autoref{chap:correctness:notions_consistency:declarative_imperative}.
Actually, a consistency preservation rule according to our definition does not have fixed points, because the signatures of definition and value set of the function are different due to the models only occurring in the definition set.
Transferred to our definition, the consistency relation is implied by iteratively applying the function to each pair of models and changes with the changes delivered by the function until they are not modified by the function anymore.
In case that the transformation is correct and hippocratic, it does always deliver changes that yield consistent models already upon its first execution and does not modify them upon further applications, thus the consistency relation is implied by applying the function to each pair of models and changes only once.

\mnote{Generalization to transformations}
In the following, we only refer to transformations rather than consistency relations and consistency preservation rules if the distinction is not necessary.
We thus also say that models are consistent to a transformation, which is supposed to mean that they are consistent to the consistency relation encapsulated by that transformation.

\begin{definition}[Consistency to Transformation]
    \label{def:consistencytransformation}
    Let $\transformation{t} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$ be a synchronizing transformation.
    We say that a tuple of models $\modeltuple{m}$ is \emph{consistent to} $\transformation{t}$ if, and only if, it is consistent to its consistency relation:
    \begin{align*}
        \modeltuple{m} \consistenttomath \transformation{t} \equivalentperdefinition \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}
    \end{align*}
    %
    For a set of transformations $\transformationset{T}$, we say that a model tuple $\modeltuple{m}$ is \emph{consistent to} $\transformationset{T}$ if, and only if, it is consistent to all transformations in it:
    \begin{align*}
        \modeltuple{m} \consistenttomath \transformationset{T} \equivalentperdefinition \forall \transformation{t} \in \transformationset{T} : \modeltuple{m} \consistenttomath \transformation{t}
    \end{align*}
\end{definition}

\mnote{Synchronization problem}
Although \autoref{def:synchronizingtransformationcorrectness} precisely defines correctness of a transformation, it is unclear how to define a transformation that fulfills that property.
In particular, most existing transformation languages are restricted to input changes to one model or to delivering changes to one model.
We thus discuss how we can achieve a correct synchronizing transformation with such a restricted formalism.
This question was introduced as \autoref{rq:correctness:synchronization}, and an approach for that constitutes our contribution \autoref{contrib:correctness:synchronization}, which we discuss in \autoref{chap:synchronization}.


\subsection{Transformation Orchestration}

\mnote{Multiple transformations need orchestration}
Preserving consistency between instances of multiple metamodels after changes with multiple transformations requires their orchestration, i.e., the decision in which order to execute them.
We have discussed in \autoref{chap:correctness:notions_consistency:preservation} that transformations, or more precisely their consistency preservation rules, may be executed independently, which requires their results to be unified, or to execute them consecutively.
We have identified the drawbacks of concurrent execution, including the necessity to define unification operators and the missing guarantee of consistency after unification.
This is why we follow the approach of consecutively executing transformations.

\mnote{Orchestration function to determine execution order}
To consecutively execute transformations, an execution order has to be determined.
While in practice a dynamic algorithm will determine that order, from a theoretical perspective that algorithm realizes a function that returns the execution order.
We call this an \emph{orchestration function}, as it is responsible for orchestrating the transformation execution.

\begin{definition}[Transformation Orchestration Function] \label{def:orchestrationfunction}
    Let $\transformationset{T}$ be a set of transformations for metamodels $\metamodeltuple{M}$.
    A transformation orchestration function $\orcfunction{\transformationset{T}}$ for these transformations is a function that delivers a sequence of transformations for given models and changes:
    \begin{align*}
        &
        \orcfunction{\transformationset{T}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow \transformationset{T}^{< \mathbb{N}}
    \end{align*}
    $\transformationset{T}^{< \mathbb{N}}$ denotes all finite sequences in $\transformationset{T}$, i.e., $\transformationset{T}^{< \mathbb{N}} \equalsperdefinition \bigcup_{i=0}^{\infty} \transformationset{T}^i$
\end{definition}

\mnote{Repetitions in orchestration}
The orchestration function returns a sequence of transformations and determines that their consistency preservation rules need to be executed in the given order. 
This especially includes that transformations may occur more than once in such a sequence.

\mnote{Existence of reasonable orchestrations}
Without further restrictions to the transformations, an orchestration function may not always find an execution order that yields a consistent model tuple for given transformations, models, and changes to them.
Such an order may not exist, because due to the transformations making local decisions to restore consistency for two models that are never consistent with the other transformations.
Additionally, even if such an order exists, it may not be possible to find it.
%
%\mnote{Decidability of existence of orchestration}
We discuss these problems in detail in \autoref{chap:orchestration} and prove that the decision problem whether an orchestration that leads to a consistent result exists is undecidable without further restrictions.
For that reason, the definition does not require that an orchestration of transformations has to lead to a consistent result.

\mnote{Explicit function for transformation application}
An orchestration function only determines an order of transformations.
Consistency for given models and changes can be preserved by requesting an orchestration from that function and executing the transformations in that order.
We make this process explicit by defining an \emph{application function} that performs consistency preservation based on given transformations, an orchestration function for them and the actual models and changes.

\mnote{Generalization function for transformation concatenation}
Before defining that application function, we first need to define an auxiliary function to concatenate transformations, more precisely their contained consistency preservation rules.
Consistency preservation rules according to \autoref{def:consistencypreservationrule} are restricted to the two metamodels they are defined for.
Additionally, they require initial models and changes as input, but only return changes.
For these two reasons, the functions describing the preservation rules cannot be easily concatenated.
This, however, is necessary to compose them to formally describe their consecutive execution.
We define a \emph{generalization function} for transformations, which generalizes them to arbitrary metamodel tuples and a conforming signature for their input and output, which eases the description of their concatenation.

\begin{definition}[Transformation Generalization Function]
    \label{def:generalizationfunction}
    Let $\metamodeltuple{M} = \tupled{\metamodel{M}{1}, \dots, \metamodel{M}{i}, \dots, \metamodel{M}{k}, \dots, \metamodel{M}{n}}$ be a metamodel tuple and let $\transformation{t} = \tupled{\consistencyrelation{CR}{}, \consistencypreservationrule{\consistencyrelation{CR}{}}}$ be a transformation for metamodels $\metamodel{M}{i}, \metamodel{M}{k}$.
    A transformation generalization function $\generalizationfunction{\metamodeltuple{M},\transformation{t}}$ for metamodels $\metamodeltuple{M}$ and transformation $\transformation{t}$ is a partial function:
    \begin{align*}
        \generalizationfunction{\metamodeltuple{M},\transformation{t}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \cup \setted{\bot}
    \end{align*}
    It generalizes the consistency preservation rule $\consistencypreservationrule{\consistencyrelation{CR}{}}$ of $\transformation{t}$ such that it can be applied to changes in $\metamodeltuple{M}$ instead of $\metamodel{M}{i}$ and $\metamodel{M}{k}$, i.e., it applies the changes delivered by $\consistencypreservationrule{\consistencyrelation{CR}{}}$ for the corresponding models to the given change tuple.
    Let $\modeltuple{m} \in \metamodeltupleinstanceset{M}$ be a model tuple and let $\changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{i}}, \dots, \change{\metamodel{M}{k}}, \dots, \change{\metamodel{M}{n}}}$ be a change tuple.
    We define $\tupled{\change{\metamodel{M}{i}}', \change{\metamodel{M}{k}}'} \equalsperdefinition \consistencypreservationrule{\consistencyrelation{CR}{}}(\model{m}{i}, \model{m}{k}, \change{\metamodel{M}{i}}, \change{\metamodel{M}{k}})$.
    Then we define:
    \parameterizeformat{
    \begin{align*}
        &
        \generalizationfunction{\metamodeltuple{M},\transformation{t}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}})
        #2
        \equalsperdefinition
        \begin{cases}
            \bot, & 
                \ifmath \tupled{\change{\metamodel{M}{i}}', \change{\metamodel{M}{k}}'} = \bot \\
            (\modeltuple{m}, \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{i}}', \dots, \change{\metamodel{M}{k}}', \dots, \change{\metamodel{M}{n}}}), & 
                \otherwisemath
        \end{cases}
    \end{align*}
    }{}{\\ & \formulaskip}
\end{definition}

\mnote{Partial and universal generalization function}
Like consistency preservation rules, a generalization function must be partial and return $\bot$ for inputs it is undefined for to reflect cases in which it cannot return a result.
This is a direct consequence of consistency preservation rules being partial, thus a generalization function is defined to return $\bot$ in the same cases as the consistency preservation rule it generalizes.
%
%\mnote{Generalization function is universal}
The generalization function is a universally-defined auxiliary function only necessary for formalizing the concepts.
It must neither be specialized for each transformation, nor must a transformation developer specify it at all.

\mnote{Dealing with unresolvable cases}
Finally, either the orchestration function or an application function must be able to reflect the cases in which no execution order of transformations that restores consistency can be found.
In accordance to existing terminology~\cite{stevens2020BidirectionalTransformationLarge-SoSym}, we call these cases \emph{unresolvable}.
From a theoretical perspective, it does not matter whether the orchestration or application function makes that decision, as the orchestration function could even be encoded into the application function.
From a practical perspective, however, we may want to determine an execution order even if there is no order that results in a consistent state.
This supports finding out why no such order is found, e.g., which transformation induces that problem.

\mnote{Application function}
We define a transformation application function that applies transformations to a given tuple of models and changes according to an order delivered by an orchestration function.
This function is partial to allow it to indicate that no result with consistent models could be found, e.g., because the input models were inconsistent or because a transformation within the orchestration delivered $\bot$.
We indicate those cases with the result $\bot$.

\begin{definition}[Transformation Application Function] \label{def:applicationfunction}
    Let $\transformationset{T}$ be a synchronizing transformations set for consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M}$ and $\orcfunction{\transformationset{T}}$ an orchestration function.
    A transformation application function $\appfunction{\orcfunction{\transformationset{T}}}$ for them is a partial function:
    \begin{align*}
        &
        \appfunction{\orcfunction{\transformationset{T}}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow \metamodeltupleinstanceset{M} \cup \setted{\bot}
    \end{align*}
    The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules of $\transformationset{t}$.
    Thus, it has to fulfill the following condition:
    \parameterizeformat{
    \begin{align*}
        &
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} \mid \modeltuple{m} \consistenttomath \consistencyrelationset{CR} : \forall \changetuple{\metamodeltuple{M}} \in \changeuniverse{\metamodeltuple{M}} : \\
        & #1 #2
        \big[
            \big(\exists \modeltuple{m'} \in \metamodeltupleinstanceset{M} : 
            \appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \modeltuple{m'} \big) \Rightarrow\\
            & #1 #2 \formulaskip
            \big(\exists \transformation{t}_{1}, \dots, \transformation{t}_{m} \in \transformationset{T} :
            \exists \changetuple{\metamodeltuple{M}}' \in \changeuniverse{\metamodeltuple{M}} :
            \orcfunction{\transformationset{T}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \sequenced{\transformation{t}_{1}, \dots, \transformation{t}_{m}} \\
            & #1 #2 \formulaskip
            \land \generalizationfunction{\metamodeltuple{M},\transformation{t}_{m}} \concatfunction \dots \concatfunction \generalizationfunction{\metamodeltuple{M},\transformation{t}_{1}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}') 
            \land \changetuple{\metamodeltuple{M}}'(\modeltuple{m}) = \modeltuple{m'}
        \big)\big]
    \end{align*}
    }{\formulaskip}{\formulaskip[0.5em]}%
\end{definition}

\mnote{Weak notion of correctness}
While the previous definition does not restrict in which cases $\bot$ and in which an actual tuple of models is returned, we define when we consider an application function \emph{correct}.
Correctness can be defined in several ways.
For example, we might say that the function is correct if it returns a consistent tuple of models whenever there is an order of transformations that leads to those consistent models.
As we will see later, this correctness notion is, however, inappropriate, because the underlying decision problem is undecidable.
In consequence, the application function needs to operate conservatively, i.e., it may return $\bot$ even if there is a sequence of transformations whose application leads to consistent models.
As an alternative, we might require the function to return consistent models whenever the orchestration function delivers a sequence of transformations whose application leads to a consistent tuple of models.
Since we have to deal with conservativeness anyway, this, however, does not provide any benefits.
In fact, the above discussed requirements encode a kind of \emph{optimality} for the functions, which we will specify more precisely in \autoref{chap:orchestration}.
For now, we stick to the simple notion of correctness that the application function does never return inconsistent models, i.e., if a tuple of models is returned, it must be consistent.

\begin{definition}[Transformation Application Function Correctness]
    \label{def:applicationfunctioncorrectness}
    Let $\appfunction{\orcfunction{\transformationset{T}}}$ be an application function for an orchestration function $\orcfunction{\transformationset{T}}$ for transformations $\transformationset{T}$.
    Let $\consistencyrelationset{CR}$ be the set of consistency relations of transformations in $\transformationset{T}$.
    We say that $\appfunction{\orcfunction{\transformationset{T}}}$ is \emph{correct} if, and only if, its result is either $\bot$ or consistent to $\consistencyrelationset{CR}{}$:
    \begin{align*}
        &
        \appfunction{\orcfunction{\transformationset{T}}} \correctmath \equivalentperdefinition
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} \mid \modeltuple{m} \consistenttomath \consistencyrelationset{CR} : \forall \changetuple{\metamodeltuple{M}} \in \changeuniverse{\metamodeltuple{M}} : \\
        & \formulaskip
        \appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = \bot \lor \appfunction{\orcfunction{\transformationset{T}}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \consistenttomath \consistencyrelationset{CR}
    \end{align*}
\end{definition}

\mnote{Conservativeness more relevant}
This is, in fact, a rather weak notion of correctness.
An application function that always returns $\bot$ is correct according to that definition.
Because the orchestration and application function have to operate conservatively, a binary correctness notion is less relevant than a gradual one anyway.
The question how to determine such an orchestration was introduced as \autoref{rq:correctness:orchestration}.
We present and discuss a concrete approach as contribution \autoref{contrib:correctness:orchestration} in \autoref{chap:orchestration}.


\subsection{Transformation Networks}

\mnote{Transformation networks}
Based on the previous definitions of transformations, orchestration and application functions, we define what we consider a \emph{transformation network} and when we consider it \emph{correct}.
A transformation network is composed of transformations, an orchestration and an application function.
Although we define these artifacts specifically for one transformation network, i.e., an orchestration and application function according to their definitions are specific for one set of transformations, the goal will be to find an orchestration and application function that is independent from the actual transformations.

\begin{definition}[Transformation Network]
    \label{def:transformationnetwork}
    Let $\transformationset{T}$ be a transformation set, $\orcfunction{\transformationset{T}}$ an orchestration function for these transformations, and $\appfunction{\orcfunction{\transformationset{T}}}$ an application function.
    A transformation network $\transformationnetwork{N}$ is a triple:
    \begin{align*}
        \transformationnetwork{N} \equalsperdefinition \tupled{\transformationset{T}, \orcfunction{\transformationset{T}}, \appfunction{\orcfunction{\transformationset{T}}}}
    \end{align*}
\end{definition}

\mnote{Correctness of transformation networks}
Correctness of a transformation network is given by correctness of the individual transformations and the application function, according to \autoref{def:synchronizingtransformationcorrectness} and \autoref{def:applicationfunctioncorrectness}.
%We say that the transformations ensure \emph{local consistency}, because they locally achieve consistency for two models, whereas the application function achieves \emph{global consistency} by applying the transformations such that all models are consistent to all transformations.

\begin{definition}[Transformation Network Correctness]
    \label{def:transformationnetworkcorrectness}
    Let $\transformationnetwork{N} = \tupled{\transformationset{T}, \orcfunction{\transformationset{T}}, \appfunction{\orcfunction{\transformationset{T}}}}$ be a transformation network.
    We say that $\transformationnetwork{N}$ is \emph{correct} if, and only if, its transformations in $\transformationset{T}$ and the application function $\appfunction{\orcfunction{\transformationset{T}}}$ are correct:
    \begin{align*}
        & 
       \transformationnetwork{N} \correctmath \equivalentperdefinition
        \forall \transformation{t} \in \transformationset{T} : \transformation{t} \correctmath \land \appfunction{\orcfunction{\transformationset{T}}} \correctmath
    \end{align*}
\end{definition}

\mnote{Conservativeness and compatibility}
We have already discussed that we will show that the application function has to operate conservatively, which is why correctness is an essential property but not the most interesting one to achieve.
Additionally, we discussed that the consistency relations of the transformations can be considered correct by definition, but that we will discuss a notion of \emph{compatibility} to reflect when those relations contain unintended contradictions.


%%% THIS VERSION MAKES ORCHESTRATION ON ITS OWN AND DEFINES THE REQUIREMENTS FOR THAT. IT MAY REQUIRE THE RESULT TO BE CONSISTENT OR NOT
% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is a partial function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M})
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. It is partial, because it is only defined for consistent input model tuples and may not return a result for all possible changes to any model. It has to fulfill the following conditions:
%     \begin{align*}
%         &
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \exists \modeltuple{m'} \in \metamodeltupleinstanceset{M} :
%         \modeltuple{m'} = \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \\
%         %\land \modeltuple{m'} \consistenttomath \consistencyrelationset{CR} \\
%         & \formulaskip
%         \land \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : 
%         \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%         & \formulaskip \formulaskip 
%         \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}')\\
%         & \formulaskip \formulaskip
%         \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'}
%     \end{align*}
% \end{definition}


% It is obvious that we can define consistency preservation rules for which no execution order can be specified that returns a consistent tuple of models after certain changes. Consider the example in \autoref{fig:formal:noexecutionorder}. There exists no execution order for any input value that terminates. The transformations will always increase the value, although the defined relations could be fulfilled for the input value, but the transformations never find that solution.

% \begin{figure}
%     \centering
%     \includegraphics[width=\textwidth]{figures/correctness/formal/divergence_example.png}
%     \caption{Example for divergence}
%     \label{fig:formal:noexecutionorder}
% \end{figure}

% Although we will discuss restrictions to relations and transformations that reduce the chance that no solution can be found, it will not be possible to ensure that such a solution can always be found. This is due to the reason that transformations can perform arbitrary changes given the transformations Turing-completeness, which should not be restricted, because it is unclear which restrictions could be made without forbidding scenarios that should actually we supported. Thus, we assume that transformations are Turing complete.

% Finally, this makes it necessary that a function that applies \modellevelconsistencypreservationrules may not find an execution order that returns a consistent model, thus is should be able to also return $\bot$ as an indicator for that situation.

% We first give a basic definition for such a function without further specifying in which cases the function is expected to return a result other than $\bot$.

% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M})
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. Thus, it has to fulfill the following conditions:
%     {\setlength{\mathindent}{0em}
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = 
%         \begin{cases}
%             \modeltuple{m'}, & \begin{array}{l@{}}
%                 \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%                 \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : \\
%                 \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}') \\
%                 \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'} 
%             \end{array} \\
%             \bot, & otherwise
%         \end{cases}
%     \end{align*}
%     }
% \end{definition}

% \begin{definition}[Consistency Preservation Application Function]
%     \todo{Define for transformations instead?}
%     Let $\consistencypreservationruleset{}$ be a set of consistency preservation rules for a set of consistency relations $\consistencyrelationset{CR}$ on metamodels $\metamodeltuple{M} = \tupled{\metamodelsequence{M}{n}}$.
%     A consistency preservation application function $\consistencyappfunction{\consistencypreservationruleset{}}$ for these rules is function:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} : (\metamodeltupleinstanceset{M}, \changeuniverse{\metamodeltuple{M}}) \rightarrow (\metamodeltupleinstanceset{M})
%     \end{align*}
%     The function takes a consistent tuple of models and a tuple of changes that was performed on them and returns a changed tuple of models by acquiring changes from the consistency preservation rules in $\consistencypreservationruleset{}$. Thus, it has to fulfill the following conditions:
%     {\setlength{\mathindent}{1em}
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = 
%         \begin{cases}
%             \modeltuple{m'}, & \begin{array}{l@{}}
%                 \exists \changetuple{\metamodeltuple{M}}' = \tupled{\change{\metamodel{M}{1}}', \dots, \change{\metamodel{M}{n}}'} \in \changeuniverse{\metamodeltuple{M}} :\\
%                 \exists \consistencypreservationrule{1}, \dots, \consistencypreservationrule{m} \in \consistencypreservationruleset{} : \\
%                 \cprgeneralizationfunction{\consistencypreservationrule{1}} \concatfunction \dots \concatfunction \cprgeneralizationfunction{\consistencypreservationrule{m}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) = (\modeltuple{m}, \changetuple{\metamodeltuple{M}}') \\
%                 \land \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}), \dots, \change{\metamodel{M}{n}}'(\model{m}{n})} = \modeltuple{m'} 
%             \end{array} \\
%             \bot, & otherwise
%         \end{cases}
%     \end{align*}
%     }
% \end{definition}



% \begin{definition}[Correct Consistency Preservation Application Function]
%     Let $\consistencyappfunction{\consistencypreservationruleset{}}$ be a consistency preservation application function for a set of \modellevelconsistencypreservationrules $\consistencypreservationruleset{}$ for a set of \modellevelconsistencyrelations $\consistencyrelationset{CR}$.
%     We say that:
%     \begin{align*}
%         &
%         \consistencyappfunction{\consistencypreservationruleset{}} \mathtext{is correct} \equivalentperdefinition \\
%         & \formulaskip
%         \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \forall \changetuple{\metamodeltuple{M}} = \tupled{\change{\metamodel{M}{1}}, \dots, \change{\metamodel{M}{n}}} \in \changeuniverse{\metamodeltuple{M}} :
%         \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow \\
%         & \formulaskip
%         \consistencyappfunction{\consistencypreservationruleset{}}(\modeltuple{m}, \changetuple{\metamodeltuple{M}}) \consistenttomath \consistencyrelationset{CR}
%     \end{align*}
% \end{definition}




%Now it is obvious that the consistency preservation rules can actually do anything to achieve consistency, including returning always the same set of models that is consistent, although that may not be expected. We will discuss later which reasonable assumptions can be made to the behavior to on the hand not restrict the possibilities of the transformation developer and on the other hand be able to ensure some properties of the transformations and their execution.


%Two levels of correctness:
%\begin{enumerate}
    %\item Local correctness: a consistency relation is correct to the global relation and the CPR is to the relation, i.e., given two models and changes in them, the transformation can produce a change that restores consistency regarding the global consistency relation of these two models (i.e., there are some other models with which these two models would be consistent regarding the global specification) --> a network is locally correct, if this property is fulfilled
    %\item Global correctness: the binary relations together are equal to the global one and the execution function is able to find consistency models after a change to initially consistent models --> network is globally correct, if this property is fulfilled
%\end{enumerate}
%Potentiell ist lokale Korrektheit (zumindest einer CPR zu ihrer CR per Konstruktion) herstellbar -- das war auch das Ergebnis bisheriger Studien --, eventuell auch von einer CR zu einer globalen CR, obwohl die ja eigentlich meist nicht existiert, daher nehmen wir das als gegeben an.
%Dann zeigen, dass die globale Beziehung der Relationen nicht äquivalent ist zu den einzelnen lokalen, daher kommt hier zusätzliche Komplexität rein (Kompatibilitätsbegriff).
%Final muss noch die Ausführungsfunktion korrekt sein, hier aber Problem der Turing-Vollständigkeit. 
%Daher Einschränkungen an Transformationen finden bzw. ingenieurmäßige Ausführungsreihenfolge festlegen, die möglichst oft richtige Lösungen findet und sonst konservativ mit einem Fehler terminiert.


% \textbf{On top of ordinary bx correctness:}
% \begin{itemize}
    %\item Transformations need to be synchronizing
    %\item Consistency relations need to fulfill a notion of correctness
    %\item Exkurs:
    % \begin{itemize}
    % %\item Is compatibility a subclass of correctness? Is every correct set of relations compatible as well?
    % \item Problematisch: unser Konsistenzbegriff für Relationen (feingranulare Relationen) schließt keine Modelle aus, der Konsistenzbegriff hier aber schon. Wie realisiere ich die feingranularen Relationen, die dafür sorgen, dass nur genau ein Tupel von Modellen konsistent ist?
    % \item Wir müssen bei der Ableitung unseres Kompatibilitätsbegriffes erklären, dass bei uns der vollständige Ausschluss bestimmter Modelle nicht Teil einer feingranularen Konsistenzrelation sein darf, sondern Teil einer weiteren Spezifikation, die angibt, welche Modelle überhaupt valide sind. Denn so ist es in Transformationssprachen tatsächlich auch.
    % \end{itemize}
    %\item Execution function needs to be defined, which potentially induces requirements to the transformations.
% \end{itemize}


% Voraussetzungen:
% \begin{itemize}
%     \item Relationen müssen korrekt sein, d.h. sie müssen bzgl. einer globalen (meist eher implizit bekannten) n-stelligen Relation zwischen allen Modellen identisch sein. Eine n-stellige Relation lässt sich nicht immer zerlegen (siehe Stevens), aber wir nehmen das an.
%     \item Die einzelne Transformation muss bzgl. ihrer Relation korrekt sein, d.h. sie muss bei Änderungen in beiden Modellen ein zur Relation konsistentes Modell liefern.
% \end{itemize}

%Ebenen der Korrektheit:
%\begin{itemize}
    %\item Relationen müssen korrekt sein, d.h. gegeben eine Nutzeränderung muss es überhaupt möglich sein eine konsistente Menge an Modellen zu finden. Wenn Transformationen etwas beliebigen tun dürfen geht das immer. Wir nehmen an, dass eine Nutzeränderung nicht rückgängig gemacht werden soll (bzw. wenn sie rückgängig gemacht werden würde eigentlich die Änderung invalide war, d.h. keine Konsistenz im Netzwerk hergestellt werden kann). Daher sind Relationen nur korrekt, wenn für fixierte Elemente, die durch eine Nutzeränderung entstehen können, eine Modellmenge abgeleitet werden kann, die bzgl. der Relationen konsistent ist. D.h. gegeben einige Elemente muss es eine Modellmenge geben, die in allen Relationen liegt und die diese Elemente enthält (-> Kompatibilitätsbegriff). Wir betrachten in Kapitel ?, wie man Kompatibilität präzise definieren und feststellen/garantieren kann.\\
    %Resultat: Gegeben eine Änderung ist es möglich eine Transformation anzugeben, die aus der Änderung ein konsistentes Modell produziert.
    %\item Einzelne Transformationen müssen korrekt sein: Wir fordern Korrektheit der Transformation sowieso. Allerdings machen in einem Netzwerk verschiedene Transformationen Änderungen an allen Modellen, d.h. wir müssen nicht den "normalen" Transformationsfall unterstützen, dass Deltas in einem Modell ins andere übertragen werden, um Konsistenz herzustellen, sondern die Transformationen müssen \emph{synchronisierend} sein, also Deltas in beiden Modelle annehmen und dann Konsistenz herstellen. Wir definieren diese Synchronisationseigenschaft und betrachten in Kapitel ?, welcher zusätzlichen Anforderungen sich dadurch bzgl. EMOF-Modellen ergeben. Der Input sind Deltas in zwei Modellen, und einzelne Deltas sind potentiell als "authoritative" definiert, was bedeutet, dass die erzeugten/geänderten Elemente nicht noch einmal geändert/gelöscht werden dürfen. Das realisiert die Anforderung, dass Nutzeränderungen nicht rückgängig gemacht werden dürfen. \\
    %Resultat: Gegeben Änderungen in zwei Modellen (mit potentiell authoritativen Änderungen) gibt die Transformation ein konsistentes (bzgl. der Konsistenzrelation) Modellpaar zurück. 
    %\item Korrektheit der Anwendungsfunktion: Die Anwendungsfunktion muss die Transformationen in einer 
%\end{itemize}


% \todo{Überlegen, wo hier die Definition von (undirektionalen Relationen) rein muss.}
% Präzisere Eigenschaften:
% \begin{itemize} 
%     \item Synchronisationseigenschaft: Eine Transformation kann mit Änderungen an mehreren Modellen umgehen, d.h. gegeben zwei konsistente Modelle + Änderungen an beiden resultiert in zwei Modellen, die konsistent bzgl. der Relation(en) zwischen den Metamodellen sind
%     \item 
% \end{itemize}  

% \begin{itemize}
%     \item Kompatibilität entsprechend Modularisierungsebene
%     \item Synchronisation auf Operationalisierung-Ebene: Abwägen, dass eine Transformation verschiedene Zustände sehen könnte, auf denen sie ausgeführt wird. Aber letztendlich muss sie damit klarkommen, dass zwei Modelle geändert wurden. 
% \end{itemize}

%TODO:
%\begin{itemize}
    %\item Authoritative Modelle (bzw. eher authoritative Regionen) diskutieren (Verweis Stevens)
%\end{itemize}



% \section{Local Correctness}

% Simple solution: we define a transformation which normatively implies a relation, thus it is correct by construction. From a theoretical perspective this is easy to reach, from a practical it is not.
% However, in contrast to our definition of synchronizing transformations, ordinary transformations are only able to process changes in one model and update the other accordingly. Together with the assumption that both models were consistent before does not fit with our scenario, because if one model is modified, the other may be modified as well by another transformation across another path, before a transformation is executed. Thus, both models may have been modified.
% We consider the following situation: Models A and B were consistent. Model A was changed an we have the changes at hand. Additionally, B was modified because there were other changes propagated through the network. 
% We distinguish all cases of modifications to B that may have violated a consistency relation between A and B (according to our fine-grained consistency notion) and consider what we have to do there (e.g., find-or-create-pattern).
% Put empirical analysis here.


% \section{Correct APP function}

% We make the following approach: Always assume there is a solution and start executing the transformation (for now in any order). Finally, the network has to terminate at a fixed point. We investigate, what the reasons may be that it does not try to avoid them.

% These reasons can lie in the relations:
% - relations cannot be completely unfulfillable, as the empty models are always consistent, thus there can always be CPRs that result in a consistent set of models
% - however, if relations contain pairs that can never be in any consistent model tuple they improve proneness to errors, because a CPR may return that pair, which will never fit to any result of any other transformation. Thus, this should not be allowed -> compatibility

% These reasons can also lie in the transformations:
% - Transformations can make choices and they make choices that are always incompatible to other (refer to example)

% Essentially there are two problems: alternation and divergence


% \subsection{Other thought}
% If each element occurs in each relation only once (so always 1:1 mappings) and if we have compatibility, then any transformation order would return exactly the one model tuple that fits.
% However: In that case we would have confluence, every information must directly be available in B from A without a transitive propagation over C. This is not what we want. So there must in general be more than one option a transformation is fine with that to reflect the information that another transformation may add or change.


%\todo{Hippocraticness is not necessary but needs to be discussed}

% Goal:
% - Find a solution in as much cases as possible, abort in the others (conservatively)
% - To do so: reduce cases in which there is no such function
% - To do so: ensure that relations are defined in a way such that they do not allow a locally correct set of CPRs that has no APP solution. If there is a pair of models (or elements of a fine-grained relation) in a relation, a CPR may return it. But if there is no consistent tuple of models containing these two, it does not make any sense to consider these elements (even worse, if we have monotony, adding these elements makes the network unsolvable). For that reason, we need compatibility.
