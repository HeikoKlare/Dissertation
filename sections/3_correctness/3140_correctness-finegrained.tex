\section{A Fine-grained Notion of Consistency}
\label{chap:correctness:finegrained}

%\begin{copiedFrom}{SoSym MPM4CPS}

% \todo{Check whether we discuss why we do not use explicit trace models, adapt prototypical implementation reference in evaluation
% -> Will be added by fine-grained consistency relations}

% \todo{Fine-grained relations hierher verschieben. Diskutieren, dass model-level relations im Prinzip erstmal ausreichend für allgemeine Betrachtungen (z.B. und insbesondere für den Formalismus als Ganzes wie auch speziell die Orchestrierung). Daher zunächst der allgemeine Formalismus. Später der feingranulerer und praxisnähere Formalismus, der insb. für Kompatibilität eingeführt wird. Ist aber im Prinzip gleichbedeutend. Feingranularer Konsistenzbegriff: Wir sagen nicht wann zwei Modelle konsistent sind, sondern was wir im zweiten Modell erwarten, wenn in dem ersten etwas vorhanden ist. So drücken es auch Transformationssprachen aus.
% CPRs bleiben gleich auf feingranularen CRs. Transformation besteht dann aus mehreren CRs und einer CPR.
% Das definieren wir aber nicht neu, sondern sagen und zeigen in Prosa einfach nur, dass das so ist (ergibt sich daraus, dass jede Menge von feingranulare CRs eine model-level CR induziert). Damit ist das ohne weitere Definitionen abgefrühstückt.}

\mnote{Fine-grained understanding of consistency}
We have yet given a common definition of consistency~\cite{stevens2010sosym} by enumerating consistent pairs of models in a relation (see \autoref{chap:correctness:notions_consistency}).
That notion is sufficient for defining transformation networks, correctness of their artifacts and also the essential considerations regarding orchestration, as presented in the preceding section.
Domain experts and transformation developers, however, usually think in terms of a more fine-grained notion of consistency.
They do not consider when complete models are consistent, but when specific relations between some of their elements are fulfilled, i.e., which other elements they require to exist if some elements are present in models.
For example, they consider when architectural components and object-oriented classes are consistent and interfaces in two models are consistent, rather than considering when the overall models containing all these elements are consistent.

\mnote{Representation in transformation languages}
This is also reflected in practice by transformation languages, such as \gls{QVTR}.
They, first, require relations to be defined at the level of classes and their properties, i.e., how properties of instances of some classes are related to properties of instances of other classes.
Second, they are defined in an \emph{intensional} way, i.e., constraints specify which elements shall be considered consistent, rather than enumerating all consistent instances in an an \emph{extensional} specification.
We have already discussed that intensional and extensional specifications both have equal expressiveness and that we stick to extensional specifications for reasons of simplicity, which can be transformed into extensional ones by enumerating all instances that fulfill the constraints.
However, we reuse the concept of specifying relations at the level of classes and their properties. % rather than complete models.

\mnote{Benefits of fine-grained notion}
This reflects a natural understanding of consistency and especially makes it easier to make statements about dependencies between consistency relations, which we will need to make statements about compatibility of consistency relations.
Thus, we introduce an appropriate, fine-grained notion of consistency relations in the following. %, which, as we will also show, is just a refinement of the already given one, thus especially not improving expressiveness.
%For example, two fine-grained consistency relations considering completely independent sets of classes cannot interfere, and thus especially do not introduce any compatibility problems, which is not easy to express when considering relations at the level of complete models.
Finally, from such a fine-grained specification, a \modellevelconsistencyrelation can always be derived by enumerating all models that fulfill all the fine-grained specifications, thus it does not restrict expressiveness in any way and can be seen as a \emph{compositional approach} for defining consistency, which is only a refinement of the notion of \modellevelconsistencyrelations.
We have presented the following definitions of a fine-grained consistency notion, partly literally, in \owncite{klare2020compatibility-report}. They are based on the work of \textcite[Section 2.3.2, 4.1.1]{kramer2017a} and \owncite{klare2020Vitruv-JSS}.

% In the following, we start with introducing a fine-grained notion of consistency relations. % based on such fine-grained consistency relations.
% We proceed with considerations on implicit relations, which are induced by a set of consistency relations, such as transitive relations, to finally precisely define a notion of compatibility.

% General notion of consistency consider relations of models. We use a more fine-grained notion based on consistency relations, which requires those relations to be unidirectional, and the notion of consistency to be more complex. The simple notion (model left requires related model right and vice versa) is not applicable, but induced by our fine-grained specification.

% \begin{itemize}
%     \item Instead of considering relations on the metamodel level, we can consider relations on the element level
%     \item Idea: Create a graph of meta elements (meta-classes, attributes, references) containing edges for all relations between elements defined by consistency relations (if there is a rule relating two or more elements, there is an edge between them)
%     \item If this graph of fine-grained relations forms a set of trees, the transformations are compatible (apply definition from previous section), because a change to one element may only be propagated across one path to each of all other elements
%     \item This is what we call \emph{decomposition} that witnesses compatibility.
%     \item We explain this in detail in \autoref{sec:decomposition}.
% \end{itemize}


%\subsection{Compatibility in Transformation Networks}

% As introduced in the previous section, simply put, compatibility in a transformation network means that there are no contradictions in the relations defined by the transformations. That means, there are not restrictions in the relations that prevent another relation from being fulfilled.
% To precisely specify that notion of \emph{compatibility}, the problems associated with it and prove correctness of a strategy to verify compatibility of given relations, we define our notion of consistency in terms of conditions and consistency relations and define the term \emph{compatibility} based on that.


\subsection{Fine-Grained Consistency Relations}
\label{chap:correctness:finegrained:relations}

\mnote{Conditions}
The central idea of the fine-grained consistency notion is to have consistency relations that contain pairs of objects and, broadly speaking, requires that if the objects in one side of the pair occur in a model, the others have to occur in another model as well.
A \emph{condition} encapsulates such objects, for which we require objects in another model to occur.

\begin{definition}[Condition]
    A condition $\condition{c}{}$ for a class tuple $\classtuple{C}{\condition{c}{}} = \tupled{\class{C}{\condition{c}{},1}, \dots, \class{C}{\condition{c}{},n}}$ is a set of object tuples %$\condition{c}{}$ = \setted{\tupled{\object{o}{1}, \dots, \object{o}{n}}}$ 
    with: 
    \begin{align*}
    &
    \forall \tupled{\object{o}{1}, \dots, \object{o}{n}} \in \condition{c}{}: \forall i \in \setted{1, \dots, n} : \object{o}{i} \in \instances{\class{C}{\condition{c}, i}}
    \end{align*}
    An element $\conditionelement{c}{} \in \condition{c}{}$ is called a \emph{condition element}.
    %
    For a tuple of models $\modeltuple{m} \in \metamodeltupleinstanceset{M}$ of a metamodel tuple $\metamodeltuple{M}$ and %= \setted{\model{m}{1}, \dots, \model{m}{k}}$ 
    a condition element $\conditionelement{c}{}$, % = \tupled{\object{o}{1}, \dots, \object{o}{n}}$ 
    %be a condition element.
    we say that: 
    \begin{align*}
        &
        \modeltuple{m} \containsmath \conditionelement{c}{} \equivalentperdefinition
        \exists \model{m}{} \in \modeltuple{m} : \conditionelement{c}{} \subseteq \model{m}{}
    \end{align*}
\end{definition}

\mnote{Models containing conditions}
\emph{Conditions} represent object tuples that instantiate the same tuple of classes. They are supposed to occur in models that fulfill a certain condition regarding consistency, i.e., they define the objects that can occur in the previously mentioned pairs of consistency relations, which we specify later.
% \begin{definition}[Condition Element Containment] \label{def:conditionelementcontainment}
%     For a set of metamodels $\metamodelset{M}$, let $\modelset{m} \in \metamodelinstances{\metamodelset{M}}$ %= \setted{\model{m}{1}, \dots, \model{m}{k}}$ 
%     be a set of models and let $\conditionelement{c}{} = \tupled{\object{o}{1}, \dots, \object{o}{n}}$ be a condition element.
%     We say that:
%     \begin{align*}
%         \formulaskip &
%         \modelset{m} \mathtext{contains} c \equivalentperdefinition \\
%         & \formulaskip
%         \exists \model{m}{} \in \modelset{m} : \exists \object{o'}{1}, \dots, \object{o'}{n} \in \model{m}{} : \forall i \in \setted{1, \dots, n} : \object{o}{i} \subseteq \object{o'}{i}
%     \end{align*}
% \end{definition}
We say that a tuple of models contains a condition element if any of the models contains all the objects within the condition element. %a set of objects, in which the condition is represented. 
%This does not necessarily mean that the objects have to be exactly those of the condition, but may be a superset of them.
%That definition allows to a condition may only specify partial information of an object to match, as, for example, a consistency relation may only relate specific properties of classes instead of the whole classes.
This implies that the metamodel of such a model has to contain all the classes in the class tuple of the condition.
We use these conditions to define consistency relations as the co-occurrence of condition elements.

%\todo{Relations also support the semi-automatic case: Whenever there is a choice to map a condition element to another, but no necessity, it is fine that a consistency relation does not require anything. The requirement only comes to the consistency preservation rule, which is supposed to update elements that have a corresponding element. Thus, if there is a corresponding element, then the CPR should update it upon change. This is, however, no necessity of the pure consistency relations, as the models would even be consistent if the there is no corresponding element. Thus, we see that our notion of consistency is purely induced by the models but cannot be influenced by information given from outside, such as user decisions.}
%\todoLater{Call class tuple the "signature" of a relation.}
\begin{definition}[Consistency Relation]
\label{def:consistencyrelation}
    %Let $\metamodel{M}{1}, \metamodel{M}{2}$ be two metamodels. 
    %A consistency relation $\consistencyrelation{CR}{}$ is defined for two class tuples $\classtuple{C}{l,\consistencyrelation{CR}{}}$ and $\classtuple{C}{r,\consistencyrelation{CR}{}}$ 
    %with $\forall \class{C}{l,i} \in \classtuple{C}{l,\consistencyrelation{CR}{}} : \exists \class{C}{} \in \metamodel{M}{1} : \class{C}{l,i} \subseteq \class{C}{}$ and $\forall \class{C}{r,i} \in \classtuple{C}{r,\consistencyrelation{CR}{}} : \exists \class{C}{} \in \metamodel{M}{2} : \class{C}{r,i} \subseteq \class{C}{}$.
    % $\consistencyrelation{CR}{}$ is a set of pairs of condition elements
    % \begin{align*}
    %     \formulaskip
    %     \consistencyrelation{CR} = \setted{\tuple{c}{l} = \tupled{\object{o}{l,1}, \dots, \object{o}{l,n}}, \tuple{c}{r} = \tupled{\object{o}{r,1}, \dots, \object{o}{r,m}}}
    % \end{align*}
    % such that there are induced conditions $\condition{c}{l,\consistencyrelation{CR}{}}, \condition{c}{r,\consistencyrelation{CR}{}}$ 
    % \begin{align*}
    %     \exists 
    % \end{align*}
    Let $\classtuple{C}{l,\consistencyrelation{CR}{}}$ and $\classtuple{C}{r,\consistencyrelation{CR}{}}$ be two class tuples.
    A consistency relation $\consistencyrelation{CR}{}$ is a subset of pairs of condition elements in conditions $\condition{c}{l,\consistencyrelation{CR}{}}, \condition{c}{r,\consistencyrelation{CR}{}}$ with
    $\classtuple{C}{l,\consistencyrelation{CR}{}} = \classtuple{C}{\condition{c}{l,\consistencyrelation{CR}{}}}$ and $\classtuple{C}{r,\consistencyrelation{CR}{}} = \classtuple{C}{\condition{c}{r,\consistencyrelation{CR}{}}}$ :
    \begin{align*}
        & 
        \consistencyrelation{CR}{} \subseteq \condition{c}{l,\consistencyrelation{CR}{}} \times \condition{c}{r,\consistencyrelation{CR}{}}
    \end{align*}
    We call a pair of condition elements %$\consistencyrelationpair{cr}{} 
    $\tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{}$ a \emph{consistency relation pair}. 
    For a set of models $\modeltuple{m}$ and a consistency relation pair $\tupled{\conditionelement{c}{l}, \conditionelement{c}{r}}$, we say that:
    \begin{align*}
        & 
        \modeltuple{m} \containsmath \tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \equivalentperdefinition \modeltuple{m} \containsmath \conditionelement{c}{l} \land \modeltuple{m} \containsmath \conditionelement{c}{r}
    \end{align*}
    Without loss of generality, we assume that each condition element of both conditions occurs in at least one consistency relation pair:
    \begin{align*}
        & 
        \forall \conditionelement{c}{} \in \condition{c}{l} : \exists \tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{} : \conditionelement{c}{} = \conditionelement{c}{l}%\\
        %&  
        \land \forall \conditionelement{c}{} \in \condition{c}{r} : \exists \tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{} : \conditionelement{c}{} = \conditionelement{c}{r}
    \end{align*}
    % these metamodels is a (possibly infinite) set of pairs of model element tuples $\consistencyrelation{CR} = \{ \bigtupled{\tupled{e_{l1}, \ldots, e_{ln}}, \tupled{e_{r1}, \ldots, e_{rm}}}, \bigtupled{\tupled{f_{l1}, \ldots, f_{ln}}, \tupled{f_{r1}, \ldots, f_{rm}}}, \newline \dots \}$ with the elements of each left tuple $e_{li}, f_{li}, \ldots \in \metamodelinstances{\metamodel{M}}$ and the elements of each right tuple $e_{ri}, f_{ri}, \ldots \in \metamodelinstances{\metamodel{N}}$.
    % A consistency relation denotes that the element tuples have to co-occur or to not occur at all in instances of $\metamodel{M}$ and $\metamodel{N}$ to consider these instances consistent.
\end{definition}

\mnote{Consistency relations}
A consistency relation according to \autoref{def:consistencyrelation} is a set of pairs of object tuples, which are supposed to indicate the tuples of objects that are considered consistent with each other, i.e., if a model contains one of the left object tuples that occurs in the relation, one of the related right object tuples has to occur in a model as well.
It is based on two conditions that define relevant object tuples in each of the two metamodels and defines the ones that are related to each other.
Based on these consistency relations, we can define a fine-grained notion of consistency.
%\todo{Metamodels in definition may not be different, so consistency relations within a model can be defined. May be a problem if the class tuples are overlapping, so exclude and discuss that?}

%We can now define a notion of consistency for a tuple of models based on the definition of consistency relations.

\begin{definition}[Consistency] \label{def:consistency}
    %Let $\metamodelset{M} = \setted{ \metamodel{M}{1}, \dots, \metamodel{M}{k} }$ be a set of metamodels and 
    Let $\consistencyrelation{CR}{}$ be a consistency relation % for two of the metamodels in $\metamodelset{M}$.
    %Let 
    and let $\modeltuple{m} \in \metamodeltupleinstanceset{M}$ %= \setted{ \model{m}{1}, \dots, \model{m}{k} }, \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}$ 
    be a tuple of models of the metamodels in $\metamodeltuple{M}$.
    We say that:
    % \begin{align*}
    %     \formulaskip
    %     & 
    %     \modelset{m} \mathtext{consistent to} \consistencyrelation{CR}{} \equivalentperdefinition \\
    %     & \formulaskip
    %     \forall \tuple{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} \mid \modelset{m} \mathtext{contains} \conditionelement{c}{l} : \exists \conditionelement{c}{r} \in \condition{c}{r, \consistencyrelation{CR}{}} : \\
    %     & \formulaskip\formulaskip 
    %     \tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{} \land \modelset{m} \mathtext{contains} \conditionelement{c}{r} \\
    %     & \formulaskip
    %     \land \forall \conditionelement{c}{r} \in \condition{c}{r, \consistencyrelation{CR}{}} \mid \modelset{m} \mathtext{contains} \conditionelement{c}{r} : \exists \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \\
    %     & \formulaskip\formulaskip 
    %     \tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{} \land \modelset{m} \mathtext{contains} \conditionelement{c}{l}
    % \end{align*}
     \begin{align*}
        & 
        \modeltuple{m} \consistenttomath \consistencyrelation{CR}{} \equivalentperdefinition \\
        & \formulaskip
        \exists \consistencyrelation{W}{} \subseteq \consistencyrelation{CR}{} : 
        \bigl( \forall \tupled{\conditionelement{c}{l,1}, \conditionelement{c}{r,1}}, \tupled{\conditionelement{c}{l,2}, \conditionelement{c}{r,2}} \in \consistencyrelation{W}{} : \\
        & \formulaskip\formulaskip\formulaskip
        \tupled{\conditionelement{c}{l,1}, \conditionelement{c}{r,1}} = \tupled{\conditionelement{c}{l,2}, \conditionelement{c}{r,2}} \lor 
        ( \conditionelement{c}{l,1} \neq \conditionelement{c}{l,2} \land \conditionelement{c}{r,1} \neq \conditionelement{c}{r,2}) \bigr) \\
        & \formulaskip\formulaskip
        \land \forall \tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in  \consistencyrelation{W}{} : \modeltuple{m} \containsmath \conditionelement{c}{l} \land \modeltuple{m} \containsmath \conditionelement{c}{r} \\
        & \formulaskip\formulaskip
        \land \forall \conditionelement{c}{l}' \in \condition{c}{l,\consistencyrelation{CR}{}} : \modeltuple{m} \containsmath \conditionelement{c}{l}' \Rightarrow \conditionelement{c}{l}' \in \condition{c}{l,\consistencyrelation{W}{}}
        % & \formulaskip\formulaskip
        % \land 
        % \forall \conditionelement{c'}{r} \in \condition{c}{r,\consistencyrelation{CR}{}} \mid \modelset{m} \containsmath \conditionelement{c'}{r} : \conditionelement{c'}{r} \in \condition{c}{r,\consistencyrelation{W}{}}
    \end{align*}
    We call such a $\consistencyrelation{W}{}$ a \emph{witness structure} for consistency of $\modeltuple{m}$ to $\consistencyrelation{CR}{}$, and for all elements $\tupled{\conditionelement{w}{l}, \conditionelement{w}{r}} \in \consistencyrelation{W}{}$, we call $\conditionelement{w}{l}$ and $\conditionelement{w}{r}$ \emph{corresponding to} each other.
    
    For a set of consistency relations $\consistencyrelationset{CR} = \setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}, \dots}$, we say that:
    \begin{align*}
        \formulaskip &
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \equivalentperdefinition %\\
        %& \formulaskip
        \forall \consistencyrelation{CR}{} \in \consistencyrelationset{CR} : \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}
    \end{align*}
\end{definition}

\mnote{Consistency by fine-grained relations}
A consistency relation $\consistencyrelation{CR}{}$ relates one condition element at the left side to one or more other condition elements at the right side of the relation.
The definition of consistency ensures that if one condition element $\conditionelement{c}{} \in \condition{c}{l,\consistencyrelation{CR}{}}$ in the left side of the relation occurs in a tuple of models, exactly one of the condition elements related to it by a consistency relation $\consistencyrelation{CR}{}$ occurs in another model to consider the tuple of models consistent.
%\todo{Give example why this is reasonable, i.e. a counterexample for the more simple notion of Max.}
If another element that is related to $\conditionelement{c}{}$ occurs in the models, this one has to be, in turn, related to another condition element $\conditionelement{c}{}' \in \condition{c}{l,\consistencyrelation{CR}{}}$ of the left side of condition elements by $\consistencyrelation{CR}{}$, which also occurs in the models.
This ensures that a condition element contained in a model uniquely corresponds to a another elements to which is considered consistent according to $\consistencyrelation{CR}{}$.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/correctness/notion/witness_uniqueness.png}
    \caption[Example for necessity of a witness structure]{A consistency relation derived from \autoref{fig:networks:three_persons_example}, which depicts the necessity of a witness structure to ensure that only one employee out of those with differently capitalized names is allowed to correspond to a resident with the same name.}
    \label{fig:correctness:witness_uniqueness}
\end{figure}

\mnote{Witness structure}
Consider the exemplary consistency relations in \autoref{fig:correctness:witness_uniqueness}, which is derived from the one in our running example in \autoref{fig:networks:three_persons_example}.
The relation requires for each resident an employee with an appropriate name to exist and vice versa.
It assumes that resident names are stored in lower case and allows the employee name to be written in arbitrary capitalization.
Thus, for example, both the employees with names \enquote{Alice} and \enquote{alice} would be considered consistent to a resident with name \enquote{alice}.
Without the restriction defined by the auxiliary witness structure $\consistencyrelation{W}{}$, an employee model containing the employees with both capitalizations would be considered consistent to a resident model containing a corresponding resident with the same name written in lower case.
The witness structure, however, ensures that for each employee one corresponding resident exists, thus there can only exist one employee with one of the allowed capitalizations, as each of them is corresponding to the resident with the lower case name.
In general, the witness structure restriction ensures that if several alternatives for a corresponding element exists, only one is actually allowed to be present.
%Without that restriction, using the modified relation $\consistencyrelation{R}{ER}'$ in the running example defined in \autoref{fig:compatibility:three_persons_example_extended}, there may exist two employees having the same name only with different capitalizations, which are considered consistent to a single resident having the same in lower case.
%The given restriction ensures that if there are several alternatives for a corresponding element to be consistent, only one is actually present.
%This is usually expected, as we will see in examples in the following.
%To achieve that, the definition uses an auxiliary structure $\consistencyrelation{W}{}$, which serves as a witness structure for those pairs of condition elements that co-occur in the models.

\begin{figure}
    \centering
    \input{figures/correctness/notion/consistency_example.tex}
    \caption[Examples for fine-grained consistency relations]{A consistency relation between employee and resident and six example model pairs: model pairs 1--4 being consistent with an appropriate witness structure $\consistencyrelation{W}{}$ shown in blue and model pair 5 and 6 being inconsistent with an inappropriate mapping structure shown in red and dashed. Adapted from \owncite{klare2020compatibility-report}.}
    \label{fig:correctness:consistency_example}
\end{figure}

\begin{example}
The definition of consistency is exemplified in \autoref{fig:correctness:consistency_example}, which is an alternation of an extract of \autoref{fig:networks:three_persons_example} only considering employees and residents. Models with employees and residents are considered consistent if for each employee exactly one resident with the same name or the same name in lowercase exists.
The model pairs $1$--$3$ are obviously consistent according to the definition, because there is always a pair of objects that fulfills the consistency relation.
In model pair $4$, there is a consistent resident for each employee, but there is no appropriate employee for the resident with $name = "John"$. However, our definition of consistency only requires that for each condition element of the left side of the relation that appears in the models, an appropriate right element occurs, but not vice versa. Thus, a relation is interpreted unidirectionally, which we will discuss in more detail in the following.
In model pair $5$, there are two residents with names in different capitalizations, which would both be considered consistent to the employee according to the consistency relation.
Comparably, in model pair $6$, there is a resident that fulfills the consistency relations for both employees, each having a different but matching capitalization. 
However, the consistency definition requires that each element in a model for which consistency is defined by a consistency relation may only have one corresponding element %, which is defined in the consistency relation, 
in the model. 
In this case, there are two residents respectively two employees that could be considered consistent to the employee respectively resident, thus there is no appropriate witness structure with a unique mapping between the elements as required by the consistency definition.
\end{example}

%For example, if the relation specifies pairs for all instances of two classes that have the same name, then if one class instance occurs in one model, the other with the same name has to occur in another model.
%Additionally, the relation could ignore the capitalization of the first letter of a class, thus relating all classes with the same name ignoring the first letter capitalization. 
%In consequence, one class would be considered consistent with two others, but only one of them would be allowed to occur to consider the models consistent.

% This means a set of models is considered consistent to a consistency relation $\consistencyrelation{CR}{}$, if the models contain one of the condition elements in one side of the consistency relations, then one of the condition elements the one is related to according to the consistency relation must occur in the models as well.
% For example, if the relation specifies pairs for all instances of two classes that have the same name, then if one class instance occurs in one model, the other with the same name has to occur in another model.
% Additionally, this definition allows that one condition elements can be considered consistent to multiple other, thus the condition element occurs in several pairs of the consistency relation, and in that case only one of them has to be fulfilled.
% Example: do not consider whether name start upper or lower case

\mnote{Unidirectional notion}
As mentioned before, we define the notion of consistency in a unidirectional way, which means that a consistency relation may define that some elements $\conditionelement{c}{r}$ are required to occur in a tuple of models if some elements $\conditionelement{c}{l}$ occur, but not vice versa.
Such a unidirectional notion can also be reasonable in our example, as it could make sense to require a resident for each employee, but not every resident might be employed and thus also represent an employee.
To achieve a bijective consistency definition, for each consistency relation $\consistencyrelation{CR}{}$ its transposed relation $\consistencyrelation{CR}{}^T = \setted{\tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \mid \tupled{\conditionelement{c}{r}, \conditionelement{c}{l}} \in \consistencyrelation{CR}{}}$ can be considered as well.
Regarding \autoref{fig:correctness:consistency_example}, if we consider the relation between employees and residents as well as its transposed, the model pair $4$ would also be considered inconsistent, because an appropriate employee for each resident would be required by the transposed relation.
We call sets of consistency relations that contain only bijective definitions of consistency \emph{symmetric}.

\begin{definition}[Symmetric Consistency Relation Set]
    Let $\consistencyrelationset{CR}$ be a set of consistency relations.
    We say that $\consistencyrelationset{CR}$ is \emph{symmetric} if for each contained relation its transposed one is also contained:
    \begin{align*}
        \formulaskip &
        \consistencyrelationset{CR} \mathtextspacearound{is symmetric} \equivalentperdefinition \\
        & \formulaskip
        \forall \consistencyrelation{CR}{} \in \consistencyrelationset{CR} :
        \exists \consistencyrelation{CR}{}' \in \consistencyrelationset{CR} :
        \consistencyrelation{CR}{}' = \consistencyrelation{CR}{}^T
    \end{align*}
\end{definition}

\mnote{Reasons for unidirectionality}
Any description of bijective consistency relations can be achieved by defining a symmetric set of consistency relations.
We chose to define consistency in a unidirectional way due to two reasons:
\begin{longenumerate}
    \item Some relevant consistency relations are actually not bijective. 
    Apart from the simple example concerning residents and employees, this situation always occurs when objects at different levels of abstraction are related.
    Consider a relation between components and classes, requiring for each component an implementation class but not vice versa, or a relation between UML models and object-oriented code, requiring for each UML class an appropriate class in code but not vice versa.
    %
    %It may be desired that %keeping an UML model consistent with object-oriented code, 
    %for each UML class an appropriate class in object-oriented code exists, but not vice versa. 
    These relations could not be expressed if consistency relations were always considered bidirectional for determining consistency.
    \item We consider networks of consistency relations, in which, as we will see later, a combination of multiple bijective consistency relations does not necessarily imply a bijective consistency relation again. 
    Thus, we need a unidirectional notion of consistency relations anyway.
\end{longenumerate}

%\end{copiedFrom} % SoSym MPM4CPS

\mnote{Explicit trace models}
One might argue that consistency is usually traced by means of a \emph{trace model}, which stores the pairs of element tuples in models that fulfill a consistency relation.
A trace model can be seen as an explicit representation of a witness structure as specified in \autoref{def:consistency}.
We do, however, not explicitly consider such an explicit trace model in this formalism due to two reasons~\owncite{klare2020Vitruv-JSS}.
First, a trace model is only necessary in practice if no identifying information for related elements is present or if performance is to be improved.
However, we assumed such identifying information without loss of generality, as introduced in \autoref{chap:networks:models:assumption}.
Second, a trace model can, from a theoretical perspective, be treated as a usual model, thus always defining consistency between one concrete and one trace model. This conforms to the fact that each multiary relation can be expressed by binary relations to an additional model (in this case the trace model), as discussed in \cite{stevens2020BidirectionalTransformationLarge-SoSym, cleve2019dagstuhl}.
We will later discuss practical benefits of having an explicit trace model for consistency preservation to distinguish modifications of elements from their removal and addition.
But this does, as discussed, not restrict applicability of our formalism.


\subsection{Expressiveness of Fine-Grained Relations} % Equivalence to \modellevelconsistencyrelations

\mnote{Expressiveness of fine-grained consistency}
The model-level consistency notion of \autoref{def:modellevelconsistency} is established and based on notions used by several researchers.
The given fine-grained notion of consistency according to \autoref{def:consistency} is based on the insight that practical approaches to describe consistency and its preservation use fine-grained rules rather than enumerating consistent model pairs.
We did, however, only provide examples that justify specific decisions in the definitions, such as the witness structure for corresponding elements, but we did not argue if and why fine-grained relations are an actual refinement, such that statements about \modellevelconsistencyrelation used for our general formal framework also apply to fine-grained consistency relations.

\mnote{Implication of model-level relation}
To show that every set of fine-grained consistency relations can be expressed by a single \modellevelconsistencyrelation, we can use the same constructive approach that we have used to define consistency according to multiple consistency relations, be they at model level or fine-grained.
Given fine-grained consistency relations $\consistencyrelationset{CR} = \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{k}}$, we can construct an equivalent \modellevelconsistencyrelation $\consistencyrelation{CR}{}$ as follows:
\begin{align*}
    \consistencyrelation{CR}{} = \setted{\modeltuple{m} \mid \modeltuple{m} \consistenttomath \consistencyrelationset{CR}}
\end{align*}

\mnote{Model-level relations more expressive}
A \modellevelconsistencyrelation can, however, not necessarily be expressed by fine-grained consistency relations.
The most simple construction approach would define a single fine-grained consistency relation to express a \modellevelconsistencyrelation, which contains the complete models instead of extracts of them.
The definition of consistency is, however, different for the two types of relations.
While at the model-level consistency is defined as two (or more) models being in a relation (see \autoref{def:modellevelconsistency}), fine-grained consistency relations do only describe that if a left-hand side element occurs in a model, then the right-hand side has to occur in another.
If two models are considered consistent by a \modellevelconsistencyrelation, they will also be consistent to the accordingly constructed fine-grained relation, because there is a witness structure that contains exactly the two consistent models.
If there is, however, a model that is not considered consistent to any other model in the \modellevelconsistencyrelation, thus the \modellevelconsistencyrelation does not contain any pair with that model, then there will also be no such pair in the fine-grained consistency relation.
According to the definition of consistency for fine-grained relations (see \autoref{def:consistency}), if there is no condition element in the relation, then consistency is not constrained for the contained model elements.
In consequence, such a model would be considered consistent to every other model.

\mnote{Additional semantics in consistency relations}
While, at first, this may seem inappropriate, it is actually appropriate for two reasons.
First, the formalism can only express that for some elements other elements need to exist, but not that specific elements are not allowed to exist if other elements exist.
This is reasonable, because consistency between models is supposed to ensure that the overlap of information is represented uniformly, thus to express that information in one model needs to be represented in another one as well.
Expressing that some elements are not allowed to exist because of other, e.g., being an employee in one model, the same person cannot be a student in another model, is actually not a consistency constraint for information shared between models, but actually additional information that should be stored in a specific model representing these semantics.
Thus, we do not consider this case at all.

\mnote{Restriction of valid models}
Second, the formalism for fine-grained can not prevent specific elements from existing at all.
For example, a consistency relation may define that for a component in an architecture model there has to be a corresponding class in the object-oriented design model, but it may not restrict that only components of specific names are allowed.
Such restrictions should and actually are separate specifications not related to consistency between models but restricting a model on its own.
Thus, the metamodel or some additional specification for it should provide such additional restrictions of valid models, which we have already discussed as a restriction of $\metamodelinstanceset{M}{}$ for a metamodel $\metamodel{M}{}$ in \autoref{chap:networks:models}.

% \mnote{Fine-grained and model-level relations are equivalent if valid models are restricted externally}
% If we assume such a restriction of $\metamodelinstanceset{M}{}$, it would be the union of all instances of that metamodel at one side of the \modellevelconsistencyrelation.
% Then, each \modellevelconsistencyrelation can also be defined by a fined-grained one.
% A model that does not occur in the \modellevelconsistencyrelation is also not contained in $\metamodelinstanceset{M}{}$, thus is is no valid model at all.
% If the model occurs in $\metamodelinstanceset{M}{}$, there is also a pair in the fine-grained consistency relation that defines that for this model an according other model has to occur.
% \todo{This is only valid if there are no two models with one being contained in the other and two corresponding models with one not being contained in the other. E.g. component is mapped to class, but if additionally component has an interface then the class it is mapepd to has a different name. Then both consistency relation pairs for the component models apply but only one of the corresponding element tuples is contained in the other model.}

% \mnote{Insights to any kind of relation are valid for the other as well}
% Summarizing, we know that \modellevelconsistencyrelations have equal expressiveness to fine-grained consistency relations, if the restriction that specific models are not allowed to occur at all are encoded in a separate specification, such as a restriction of $\metamodelinstanceset{M}{}$ for each metamodel $\metamodel{M}{}$.
% In consequence, insights based on any of the two kinds of consistency relations also apply to the other.

\mnote{Insight transferability beteween notions}
Summarizing, we know that we can express each set of fine-grained consistency relations by a \modellevelconsistencyrelation.
Additionally, we know that there are specific kinds of restrictions that can be encoded in \modellevelconsistencyrelations, which cannot be expressed with fine-grained consistency relations.
We have, however, discussed why they are not relevant for the designated application area of consistency preservation.
In consequence, all insights made for \modellevelconsistencyrelations can also be applied to fine-grained consistency relations and, if specific restrictions are excluded, vice versa as well.


%\todo{Derive that element-level consistency relations induce model-level consistency relations to be conforming with previous formalism}

%\begin{itemize}
    %\item Is compatibility a subclass of correctness? Is every correct set of relations compatible as well?
    %\item Problematisch: unser Konsistenzbegriff für Relationen (feingranulare Relationen) schließt keine Modelle aus, der Konsistenzbegriff hier aber schon. Wie realisiere ich die feingranularen Relationen, die dafür sorgen, dass nur genau ein Tupel von Modellen konsistent ist?
    %\item Wir müssen bei der Ableitung unseres Kompatibilitätsbegriffes erklären, dass bei uns der vollständige Ausschluss bestimmter Modelle nicht Teil einer feingranularen Konsistenzrelation sein darf, sondern Teil einer weiteren Spezifikation, die angibt, welche Modelle überhaupt valide sind. Denn so ist es in Transformationssprachen tatsächlich auch.
%\end{itemize}


\subsection{Application to Consistency Preservation Rules}

\mnote{Fine-grained notion in transformation languages}
As mentioned before, the fine-grained notion of consistency does also fit well to how specifications in transformation languages consider consistency.
They allow to define rules that relate only some classes by relations, conforming to fine-grained consistency relations, from which then fine-grained consistency preservation rules are derived.
Alternatively, they directly allow to define rules to preserve consistency between specific classes.
These rules are often called \emph{transformation rules} and composed to a transformation that consists of multiple such rules, each encoding a consistency relation and a preservation rule for it.
%We will, however, stick to the coarse-grained notion of consistency preservation rules, because, first, it is difficult to describe how such fine-grained consistency preservation rules can be composed, and second, the coarse-grained notion is sufficient for our considerations anyway.

\mnote{Conflicts between transformation rules}
It may easily happen that the execution of one transformation rule leads to the violation of the consistency relation of another one, which introduces dependencies between the individual transformation rules.
Thus, a combination of such transformation rules to a transformation has to ensure correctness, i.e., that the consecutive execution of the rules leads to a consistent state of the models.
Languages such as \gls{QVTR} and \gls{QVTO} therefore specify that transformation rules may not be conflicting (cf. \cite[7.10.2.]{qvt}).
It is also a dedicated topic of research to ensure that the rules of a single transformation conform to each other, e.g.\ \cite{cuadrado2017tse,cabot2010VerificationInvariants-JSS}, thus we assume that a transformation has that property.

\mnote{Extension of Consistency preservation rules}
To avoid the necessity of specifying this conformance property for transformation rules, we stick to the existing notion of coarse-grained consistency preservation rules, as it is sufficient for our considerations.
Still, consistency preservation rules were yet defined for \modellevelconsistencyrelations in \autoref{def:consistencypreservationrule}.
This can, however, easily be extended to fine-grained consistency relations, as we simply need to require the rule to consider consistency to a set of fine-grained relations according to \autoref{def:consistency} rather than consistency to a single \modellevelconsistencyrelation according to \autoref{def:modellevelconsistency}.

\mnote{Consistency preservation for fine-grained relations}
A consistency preservation rule $\consistencypreservationrule{\consistencyrelationset{CR}}$ for a set of consistency relations $\consistencyrelationset{CR}$ according to \autoref{def:consistencyrelation} is thus still considered correct if it only returns changes when they yield models that are consistent to all consistency relations if applied to the input models, in accordance with \autoref{def:consistencypreservationrulecorrectness}:
\begin{align*}
    &
    \forall \model{m}{1} \in \metamodelinstanceset{M}{1}, \model{m}{2} \in \metamodelinstanceset{M}{2}, \change{\metamodel{M}{1}} \in \changeuniverse{\metamodel{M}{1}}, \change{\metamodel{M}{2}} \in \changeuniverse{\metamodel{M}{2}} : %\tupled{\model{m}{1},\model{m}{2}} \consistenttomath \consistencyrelationset{CR} 
    \\
    & \formulaskip
    %\land 
    \exists \change{\metamodel{M}{1}}' \in \changeuniverse{\metamodel{M}{1}}, \change{\metamodel{M}{2}}' \in \changeuniverse{\metamodel{M}{2}} : \tupled{\change{\metamodel{M}{1}}', \change{\metamodel{M}{2}}'} = \consistencypreservationrule{\consistencyrelationset{CR}}(\model{m}{1}, \model{m}{2}, \change{\metamodel{M}{1}}, \change{\metamodel{M}{2}}) \\
    & \formulaskip\formulaskip
    \Rightarrow \tupled{\change{\metamodel{M}{1}}'(\model{m}{1}),\change{\metamodel{M}{2}}'(\model{m}{2})} \consistenttomath \consistencyrelationset{CR}
\end{align*}
Note that being consistent to all fine-grained consistency relations is equivalent to being consistent to the single \modellevelconsistencyrelation induced by the fine-grained relations.

\mnote{Transformations for fine-grained relations}
Likewise, we consider a synchronizing transformation according to \autoref{def:synchronizingtransformation} as a pair of fine-grained consistency relations and a consistency preservation rule for them, thus $\transformation{t} = \tupled{\consistencyrelationset{CR}, \consistencypreservationrule{\consistencyrelationset{CR}}}$.
Again, in conformance with \autoref{def:synchronizingtransformationcorrectness}, we call such a transformation $\transformation{t}$ correct if, and only if, its consistency preservation rule is correct.