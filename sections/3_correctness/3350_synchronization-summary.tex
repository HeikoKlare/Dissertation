%%% 
%%% SUMMARY
%%%
\section{Summary}

In this chapter, we have discussed how synchronizing transformations, as required in transformation networks, can be defined with existing transformation languages.
To this end, we have defined synchronizing bidirectional transformations as an extension of bidirectional transformations specified in transformation languages.
We have formally proven that these transformations always terminate consistently and have equal expressiveness than synchronizing transformations.
Finally, we have identified properties and proposed an algorithm to be implemented by a transformation specified in a transformation language to be synchronizing.
We close this chapter with the following central insight.

\begin{insight}[Synchronization]
    Synchronizing transformations, as required in transformation networks, process pairs of models that both may have been and need to be modified.
    In contrast, ordinary bidirectional transformations consist of two unidirectional consistency preservation rules, each of them accepting changes in one model and updating the other.
    We have shown that if changes have been performed to both models, the consistency preservation rules cannot be sequenced such that they produce consistent results.
    By requiring that a bidirectional transformation fulfills a notion of being \emph{partial-consistency-improving}, we were able to define an execution algorithm for it that delivers consistent models after a finite number of execution steps.
    In return, we were able to formally prove that such transformations have equal expressiveness than synchronizing transformations as required for transformation networks.
    Finally, we found that a transformation developer needs to consider only few situations explicitly to make a bidirectional transformation partial-consistency-improving. 
    The most important situation is that a transformation creates elements that already exist, because another transformation already created them, for which we provide an algorithm to avoid issues due to duplicate element creation already by construction.
    In consequence, synchronizing transformations can be constructed with existing transformation languages by fulfilling an additional property for which we provide a constructive strategy and without knowing about other transformations to combine them with.
\end{insight}
