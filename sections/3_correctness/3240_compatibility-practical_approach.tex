\section{A Practical Approach to Prove Compatibility}
\label{chap:compatibility:practical_approach}

\mnote{Operationalization of compatibility proof}
We have presented a formal and proven correct approach for validating compatibility of consistency relations in the previous section.
It comprises the reduction of a given set of consistency relations by removing redundant relations to result in independent consistency relation trees.
In this section, we propose an algorithm that turns the formal approach into an operational procedure.
For the most part, this approach is based on results developed and described in detail in the Master's thesis of \textowncite{pepin2019ma}, which was supervised by the author of this thesis, and published in a report~\owncite{klare2020compatibility-report}.

\mnote{Approach for \qvtr}
We call the process of removing redundant relations from a consistency relation set to generate independent consistency relation trees \emph{decomposition}.
A decomposition procedure requires a representation of consistency relations present in actual model transformations that allows to validate their redundancy, more specifically the property of left-equal redundancy (see~\autoref{def:leftequalredundancy}).
We have decided to employ the transformation language \qvtr for the operationalization.
First, \qvtr is standardized~\cite{qvt} and well researched.
Second, it provides a level of abstraction at which consistency relations are explicitly represented.
In contrast, imperative languages would first require to extract consistency relations from their implicit specification as the image of the transformation rules.

\mnote{Procedure overview}
In the following, we first present a mapping between the formalization of the previous sections to the \qvtr transformation language through the use of \emph{predicates}.
We then propose a fully automated decomposition procedure that takes a set of \qvtr transformations, called a \emph{consistency specification}, as an input and removes redundant consistency relations as far as possible.
To find a redundant relation, the procedure identifies an alternative concatenation of consistency relations relating the same classes, according to \autoref{def:leftequalredundancy}, and performs a \emph{redundancy test} with respect to that alternative concatenation.
We explicitly separate the identification of candidates for the alternative concatenation from the redundancy test to assert exchangeability of the redundancy test approach.


\subsection{Practical Specification of Consistency Relations}

\mnote{Intensional consistency specifications}
In \autoref{chap:correctness:notions_consistency:intensional_extensional}, we have discussed the distinction of intensional and extensional specifications of consistency.
We have used an extensional specification for formalizing consistency relations in \autoref{def:consistencyrelation}.
Developers, however, define transformations with intensional specifications of the constraints that have to hold.
In relational transformation languages, such as \qvtr, they define consistency as a set of conditions that models must fulfill.
Such conditions are expressed with metamodel elements, like attributes and references.
For example, an employee and a resident are considered consistent if their $\mathvariable{name}$ values are equal.

\mnote{Predicates expressing conditions}
Conditions represent predicates, i.e., Boolean-valued filter functions.
Consistency relations are then defined as sets of condition element pairs for which the predicate evaluates to $\truemath$.
In \autoref{chap:correctness:notions_consistency:intensional_extensional}, we have already shown that this type of specification has equal expressiveness and can be transformed into an extensional specification.
We define such a predicate based on combinations of properties, selected from each metamodel, which we introduce in the following.

\begin{definition}[Property Set]
A property set $\propertyset{P}{\class{C}{}}$ for a class $\class{C}{}$ is a subset of properties of $\class{C}{}$, i.e., $\propertyset{P}{\class{C}{}} = \setted{P_{\class{C}{}, 1}, \dots, P_{\class{C}{}, n}}$ such that $P_{\class{C}{}, i} \in \class{C}{}$.
\end{definition}

\mnote{Consistency-relevant properties}
A property set represents a selection of properties of a class that are relevant for the definition of a predicate in order to distinguish consistent and non-consistent condition elements. For a consistency relation, not all properties of a class may be relevant and thus need to be considered. In a case of an extensional specification at the level of classes rather than properties, such as the one defined in \autoref{def:consistencyrelation}, this is expressed by enumerating all objects with all possible values of the irrelevant properties. Thus, expressing the relations at the level of classes or properties have equal expressiveness.

\begin{definition}[Tuple of Property Sets]
For a class tuple $\classtuple{C}{} = \tupled{\class{C}{1}, \dots, \class{C}{n}}$, we denote a tuple of property sets for every class as a property tuple $\propertysettuple{P}{\classtuple{C}{}}$:
\begin{align*}
    \propertysettuple{P}{\classtuple{C}{}} = \tupled{\propertyset{P}{\class{C}{1}}, \dots, \propertyset{P}{\class{C}{n}}} = \tupled{\setted{P_{\class{C}{1}, 1}, \dots, P_{\class{C}{1}, m}}, \dots, \setted{P_{\class{C}{n}, 1}, \dots, P_{\class{C}{n}, k}}}
\end{align*}
\end{definition}

\mnote{Property tuples for class tuples}
Since condition elements in consistency relations consist of objects that instantiate multiple classes, property set tuples generalize the use of property sets to class tuples.

\begin{definition}[Property Value Set]
A property value set $\propertyvalueset{p}{\class{C}{}}$ for a property set $\propertyset{P}{\class{C}{}} = \setted{P_{\class{C}{}, 1}, \dots, P_{\class{C}{}, n}}$ is a set in which each property in $\propertyset{P}{\class{C}{}}$ is instantiated, i.e., $\propertyvalueset{p}{\class{C}{}} = \setted{p_{\class{C}{}, 1}, \dots, p_{\class{C}{}, n}}$ with $p_{\class{C}{}, i} \in I_{P_{\class{C}{}, i}}$. 
Analogously, a tuple of property value sets is built from a tuple of property sets by instantiating each property set in it.
\end{definition}

\mnote{Relevant property values}
A property value set is a subset of property values of an object $\object{o}{}$ that instantiates $\class{C}{}$, like a property set is a subset of properties of a class $\class{C}{}$. Such a property value set represents the information of an object $\object{o}{}$ that is relevant for consistency according to a specific consistency relation.

\begin{definition}[Predicate]
A predicate for two class tuples $\classtuple{C}{l} = \tupled{\class{C}{l,1}, \dots, \class{C}{l,n}}$ and $\classtuple{C}{r}$ is a triple $\pi = \tupled{\propertysettuple{P}{\classtuple{C}{l}}, \propertysettuple{P}{\classtuple{C}{r}}, \function{f}_\pi}$ where $\propertysettuple{P}{\classtuple{C}{l}} = \tupled{\propertyset{P}{\class{C}{l,1}}, \dots, \propertyset{P}{\class{C}{l,n}}}$ (resp. $\propertysettuple{P}{\classtuple{C}{r}}$) is a tuple of property sets of $\classtuple{C}{l}$ (resp.\ $\classtuple{C}{r}$) and $\function{f}_\pi$ is a Boolean-valued function for instances of $\tuple{P}_{\classtuple{C}{l}}$ and $\tuple{P}_{\classtuple{C}{r}}$, i.e.,
\begin{align*}
    \function{f}_\pi : \instances{\propertysettuple{P}{\classtuple{C}{l}}} \times \instances{\propertysettuple{P}{\classtuple{C}{r}}} \to \setted{\truemath, \falsemath}
\end{align*}
\end{definition}

\mnote{Property union}
For better readability, we define the property collection $\propertycollection{\pi}$ of a predicate $\pi = (\propertysettuple{P}{\classtuple{C}{l}}, \propertysettuple{P}{\classtuple{C}{r}}, \function{f}_\pi)$ as the union of all properties in that predicate:
\begin{align*}
    &
    \propertycollection{\pi} \equalsperdefinition \bigcup_{j} \propertyset{P}{\class{C}{l,j}} \cup \bigcup_{k} \propertyset{P}{\class{C}{r,k}}
\end{align*}

\mnote{Conditions by predicates}
The definition of a predicate requires the selection of properties of the classes within the class tuples related by a consistency relation $CR$ and the definition of a function $\function{f}_\pi$ that defines whether two instances of these properties are considered consistent.
If $\function{f}_\pi$ evaluates to $\truemath$ for given property values of two object tuples, they match the predicate and are considered consistent, i.e., they represent the condition elements of a consistency relation pair according to \autoref{def:consistencyrelation}.

\mnote{Consistency relations by predicates}
Predicates thus model how consistency relations are defined in model transformation languages in terms of conditions to evaluate for object tuples, i.e., condition elements, rather than enumerating all consistent pairs of condition elements.
We define when we consider property values to match objects and then derive how consistency relations can be defined by predicates.

\begin{definition}[Property Matching]
Let $\propertyvalueset{p}{\class{C}{}} = \setted{p_{\class{C}{}, 1}, \dots, p_{\class{C}{}, n}}$ be a property value set. We say that:
\begin{align*}
    &
    \propertyvalueset{p}{\class{C}{}} \matchesmath \object{o}{} \equivalentperdefinition
    \object{o}{} \in I_{\class{C}{}} \land \forall p_{\class{C}{}, i} \in \propertyvalueset{p}{\class{C}{}} : p_{\class{C}{}, i} \in \object{o}{}
\end{align*}
%
Similarly, let $\propertyvaluesettuple{p}{\classtuple{C}{}} = \tupled{\propertyvalueset{p}{\class{C}{1}}, \dots, \propertyvalueset{p}{\class{C}{n}}}$ be a tuple of property value sets and $\tuple{o} = \tupled{\object{o}{1}, \dots, \object{o}{n}}$ a tuple of objects. We say that:
\begin{align*}
    &
    \propertyvaluesettuple{p}{\classtuple{C}{}} \matchesmath \tuple{o} \equivalentperdefinition
    \forall \propertyvalueset{p}{\class{C}{i}} \in \propertyvaluesettuple{p}{\classtuple{C}{}} : \propertyvalueset{p}{\class{C}{i}} \matchesmath \object{o}{i}
\end{align*}
\end{definition}

\begin{definition}[Predicate-Based Consistency Relation] \label{def:predicatebasedconsistencyrelation}
Let $\condition{c}{l}$ and $\condition{c}{r}$ be two conditions for two class tuples $\classtuple{C}{\condition{c}{l}}$ and $\classtuple{C}{\condition{c}{r}}$. 
Let $\Pi$ be a set of predicates for $\classtuple{C}{\condition{c}{l}}$ and $\classtuple{C}{\condition{c}{r}}$. A $\Pi$-based consistency relation $CR_{\Pi}$ is a subset of pairs of condition elements:
\parameterizeformat{
\begin{align*}
    &
    CR_{\Pi} \equalsperdefinition
    \setted{\tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \condition{c}{l} \times \condition{c}{r} \mid \forall \tupled{\propertysettuple{P}{\classtuple{C}{\condition{c}{l}}}, \propertysettuple{P}{\classtuple{C}{\condition{c}{r}}}, \function{f}_\pi} \in \Pi :
    #2
    \exists \propertyvalueset{p}{\classtuple{C}{\condition{c}{l}}} \in \instances{\propertysettuple{P}{\classtuple{C}{\condition{c}{l}}}},
    \propertyvalueset{p}{\classtuple{C}{\condition{c}{r}}} \in \instances{\propertysettuple{P}{\classtuple{C}{\condition{c}{r}}}}:\\
    & \formulaskip
    \big(
        \propertyvaluesettuple{p}{\classtuple{C}{\condition{c}{l}}} \matchesmath \conditionelement{c}{l}
        \land \propertyvaluesettuple{p}{\classtuple{C}{\condition{c}{r}}} \matchesmath \conditionelement{c}{r}
        \land \function{f}_{\pi}(\propertyvaluesettuple{p}{\classtuple{C}{\condition{c}{l}}}, \propertyvaluesettuple{p}{\classtuple{C}{\condition{c}{r}}}) = \truemath 
    \big)
    }
\end{align*}
}{}{\\ & \formulaskip\formulaskip}%
\end{definition}

\mnote{Intensional consisteny relations}
The construction of consistency relations by means of predicates is comparable to the one discussed in \autoref{chap:correctness:notions_consistency:intensional_extensional} at the level of models.
\autoref{def:predicatebasedconsistencyrelation} extends that construction to fine-grained consistency relations.
It expresses how consistency relations enumerating consistent object tuples are defined by means of predicates.
The construction of the consistency relation fully amounts to the evaluation of the predicate function.

\begin{example}
We construct a consistency relation $\consistencyrelation{CR}{PR}$ based on predicates between persons and residents, according to \autoref{fig:compatibility:three_persons_example_extended}. 
$\consistencyrelation{CR}{PR}$ ensures that the $\mathvariable{name}$ of a resident concatenates the $\mathvariable{firstname}$ and $\mathvariable{lastname}$ of a person and that both have the same address. 
$\consistencyrelation{CR}{PR}$ involves one class in each metamodel, resulting in two class tuples $\classtuple{C}{P} = \tupled{\class{C}{\mathvariable{Person}}}$ and $\classtuple{C}{R} = \tupled{\class{c}{\mathvariable{Resident}}}$. 
Two predicates need to represent consistency conditions, which are equal names and equal addresses.
The first predicate considers $\mathvariable{firstname}$ and $\mathvariable{lastname}$ of a person and $\mathvariable{name}$ of a resident, so $\propertysettuple{P}{\classtuple{C}{P}, 1} = \tupled{\setted{\mathvariable{firstname}, \mathvariable{lastname}}}$ and $\propertysettuple{P}{\classtuple{C}{R}, 1} = \tupled{\setted{\mathvariable{name}}}$. 
Similarly, $\propertysettuple{P}{\classtuple{C}{P}, 2} = \tupled{\setted{\mathvariable{address}}}$ and $\propertysettuple{P}{\classtuple{C}{R}, 2} = \tupled{\setted{\mathvariable{address}}}$.
The functions of the predicate, shortly denoting $\mathvariable{name}$ as $n$, $\mathvariable{firstname}$ as $\mathvariable{fn}$, $\mathvariable{lastname}$ as $\mathvariable{ln}$, as well as $\mathvariable{address}$ of a person as $a_P$ and of a resident as $a_R$, are:
\begin{align*}
   &
   \function{f}_{\pi, 1}(\tupled{\setted{\mathvariable{fn}, \mathvariable{ln}}}, \tupled{\setted{n}}) = 
   \begin{cases} 
      \truemath, & \ifmath n = \mathvariable{fn} + "\text{\textvisiblespace}" + \mathvariable{ln} \\
      \falsemath, & \otherwisemath
   \end{cases} \\
   &
   \function{f}_{\pi, 2}(\tupled{\setted{a_P}}, \tupled{\setted{a_R}}) = \begin{cases} 
      \truemath, & \ifmath a_P = a_R \\
      \falsemath, & \otherwisemath
   \end{cases}
\end{align*}
$\consistencyrelation{CR}{PR}$ is a $\Pi$-based consistency relation where $\Pi$ is the set of the two predicates for names and addresses $\setted{\tupled{\propertysettuple{P}{\classtuple{C}{P}, 1}, \propertysettuple{P}{\classtuple{C}{R}, 1},\function{f}_{\pi, 1}}, \tupled{\propertysettuple{P}{\classtuple{C}{P}, 2}, \propertysettuple{P}{\classtuple{C}{R}, 2}, \function{f}_{\pi, 2}}}$.
\end{example}

\lstinputlisting[float,
    language=QVT, 
    numbers=none, 
    mathescape=true, 
    caption={[Simplified structure of a \acrshort{QVTR} transformation]Simplified structure of a \qvtr transformation. Adapted from~\owncite[Lst.~1]{klare2020compatibility-report}.},
    label={lst:compatibility:qvtr_structure}
]{listings/correctness/compatibility/qvtr_structure.tex}

\mnote{Relations in \qvtr}
We have decided to use \qvtr as the relational language of the \gls{QVT} standard~\cite{qvt} for implementing the formal approach for validating compatibility.
The defined relations can be interpreted as predicates defining $\Pi$-based consistency relations.
The language can be executed in \emph{checkonly} mode to check models for fulfillment of consistency relations, or in \emph{enforce} mode to repair consistency in a specified direction if not all relations are fulfilled.
The relevant parts of the structure of a \qvtr transformation are as follows and also exemplified in \autoref{lst:compatibility:qvtr_structure}. 

\mnote{\qvtr structure}
A \qvtr \texttt{transformation} receives models, which conform to defined metamodels, and checks or repairs their consistency.
Each \texttt{transformation} is composed of \texttt{relation}s, which define when objects of both models are considered consistent. These relations are only invoked if they are prefixed by the \texttt{top} keyword, if they belong to the precondition (\texttt{when}) of a relation to be invoked, or if they belong to the invariant (\texttt{where}) of a relation that was already invoked. 
The \qvtr mechanism for checking consistency is based on pattern matching.
The relations between information in the different models are represented by variables assigned to class properties. 
These variables contain values that must remain consistent from one object to another. 
To consider models consistent, there must exist some assignment that matches all patterns at the same time. 

\lstinputlisting[float,
    language=QVT, 
    numbers=none, 
    mathescape=true, 
    caption={[Two \acrshort{QVTR} domains, each with one domain pattern]Two \qvtr domains, each with one domain pattern. Adapted from~\owncite[Lst.~2]{klare2020compatibility-report}.},
    label={lst:compatibility:qvtr_domain_patterns}
]{listings/correctness/compatibility/qvtr_domain_patterns.tex}

\mnote{Constraints in \qvtr}
More precisely, each \qvtr \texttt{relation} contains two \texttt{domain}s, which in turn contain \emph{domain patterns}. 
In \gls{QVT} terminology, a domain pattern is a variable instantiating a class. 
This variable can take values that are constrained by conditions on its properties, known as \emph{property template items}.
These conditions are expressed by \gls{OCL} constraints~\cite{ocl}.
We give an example for the domains of persons and employees according to the running example in \autoref{lst:compatibility:qvtr_domain_patterns}, in which each domain has one pattern.
These patterns filter $\mathvariable{Person}$ objects with three property template items for $\mathvariable{firstname}$, $\mathvariable{lastname}$, and $\mathvariable{income}$, and $\mathvariable{Employee}$ objects with two property template items for $\mathvariable{name}$ and $\mathvariable{salary}$, respectively. 
For two objects to be consistent, there must exist values of $\mathvariable{fstn}$, $\mathvariable{lstn}$, and $\mathvariable{inc}$ that match property values of these objects, thus ensuring that the employee $\mathvariable{name}$ equals the concatenation of the $\mathvariable{firstname}$ and the $\mathvariable{lastname}$ of the person and that both have the same $\mathvariable{income}$. 
If objects are inconsistent, e.g., if the person and the employee have different incomes, then there is no such variable assignment.
The \qvtr transformations for all three relations of the running example introduced with \autoref{fig:compatibility:three_persons_example_extended} are depicted in \autoref{lst:compatibility:qvtr_running_example}.

\lstinputlisting[float,
    language=QVT, 
    numbers=none, 
    mathescape=true,
    basicstyle=\ifisafour\small\else\footnotesize\fi\ttfamily,
    caption={[\acrshort{QVTR} transformations for the running example]Three binary \qvtr transformations forming a consistency specification, based on the relations in \autoref{fig:compatibility:three_persons_example_extended}. Adapted from~\owncite[Fig.~10]{klare2020compatibility-report}.},
    label={lst:compatibility:qvtr_running_example}
]{listings/correctness/compatibility/qvtr_running_example.tex}

\mnote{\qvtr to formalism}
In \emph{checkonly} mode, \qvtr evaluates the existence of a value that fulfills all property template items in domain patterns. These patterns can be regarded as predicates.
To transfer \qvtr relations into our formalism, each relation is translated into one or multiple predicates.
A predicate is formed by the properties that are bound to the same \qvtr variables, because having \qvtr variables in common means that values of these properties are interrelated and thus need to fulfill some consistency constraints.
The properties of each domain form one of the property sets of a predicate.
Extracting the \gls{OCL} constraints of the property template items generates the predicate function. 
The property sets together with the predicate function represent a predicate. 
We subsequently present a formal construction of predicates from \qvtr and their representation in a graph.


\subsection{Consistency Relations Represented as Graphs}

\mnote{Redundancy in predicate-based consistency relations}
In the following, we introduce the decomposition procedure for proving compatibility, which relies on an algorithmic way to detect redundant consistency relations. 
We have defined the notion of left-equal redundancy for extensionally specified consistency relations in \autoref{def:leftequalredundancy}.
That notion is based on classes, whereas predicate-based consistency relations are defined for properties.
We have, however, already discussed that both kinds of specification have equal expressiveness.
Comparing predicate-based consistency relations of different transformations to evaluate redundancy is what we call a \emph{redundancy test}.

\mnote{Graph representation}
Consistency specifications induce a graph of class properties, which are related by edges that are labeled with the predicates that define the consistency relations.
Such a graph representation enables the application of graph algorithms to identify independent and redundant consistency relations.
The decomposition procedure thus creates such a graph, denoted as a \emph{property graph}, out of \qvtr transformations and detects redundant relations in that graph.
It represents properties and predicates as a hypergraph with labeling.

\begin{definition}[Property Graph] \label{def:propertygraph}
Let $\consistencyrelationset{CR} = \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{n}}$ be a set of consistency relations where each consistency relation $\consistencyrelation{CR}{i}$ is based on a set of predicates $\Pi_i$. 
A property graph is a couple $\mathcal{M}=\tupled{\mathcal{H}, \function{l}}$, such that $\mathcal{H} = \tupled{V_{\mathcal{H}}, E_{\mathcal{H}}}$ is a hypergraph and $\function{l}$
is a hyperedge labeling:
$V_{\mathcal{H}}$ is the set of vertices, i.e., the union of properties in all predicates:
\begin{align*}
    V_{\mathcal{H}} \equalsperdefinition \bigcup_{i = 1}^{n} \bigcup_{\pi \in \Pi_{i}} \propertycollection{\pi}
\end{align*}
%
$E_{\mathcal{H}}$ is the set of hyperedges, i.e., $E_{\mathcal{H}} \subseteq \mathcal{P}(V_{\mathcal{H}}) \setminus \setted{\varnothing}$. Each hyperedge consists of the properties of one predicate:
\begin{align*}
    E_{\mathcal{H}} \equalsperdefinition \bigcup_{i = 1}^{n} \bigcup_{\pi \in \Pi_{i}} \setted{\propertycollection{\pi}}
\end{align*}
$\function{l}$ labels each hyperedge with its corresponding predicate function:
\begin{align*}
    &\forall i \in \setted{1, \dots, n} : \forall \pi = \tupled{\propertysettuple{P}{\classtuple{C}{l}}, \propertysettuple{P}{\classtuple{C}{r}}, \function{f}_\pi} \in \Pi_{i} :
    \function{l}(\propertycollection{\pi}) = \function{f}_\pi
\end{align*}
\end{definition}

\mnote{Independence and redundancy in property graph}
A property graph groups properties that are used in the same predicate.
Each hyperedge with its labeling represents a predicate, which, in turn, represents a consistency relation.
Thus, such a graph is useful for detecting independent sets of consistency relations and potential redundancies.
When there are sets of hyperedges that do not share any vertices, they relate independent sets of properties.
According to \autoref{def:independence}, the consistency relations represented by the hyperedges are independent.
On the contrary, if multiple sequences of hyperedges relate the same properties, the represented consistency relations form a cycle and may thus be incompatible or redundant.

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/property_graph_running_example}
    \input{figures/correctness/compatibility/property_graph_legends}
    \caption[Property graph for the running example]{Property graph for the \qvtr example in \autoref{lst:compatibility:qvtr_running_example} based on relations in \autoref{fig:compatibility:three_persons_example_extended}. Hyperedges are represented as shaded areas. Constraints for the predicate functions are annotated in boxes. Adapted from~\owncite[Fig.~11]{klare2020compatibility-report}.}
    \label{fig:compatibility:propertygraph_example}
\end{figure}

\mnote{Need for hypergraph}
A property graph needs to be a hypergraph, because a predicate can relate more than two properties, so an edge must be able to relate more than two vertices.
The consistency relation $\consistencyrelation{CR}{PE}$ of the running example relates an employee's $\mathvariable{name}$ to the concatenation of the $\mathvariable{firstname}$ and $\mathvariable{lastname}$ of a person and thus contains three properties.
We depict the hypergraph for the running example in \autoref{fig:compatibility:propertygraph_example}.
In the following, we discuss the construction of a property graph from \qvtr transformations.
The identification of redundancies in the represented relations is part of the subsequent subsection.

\mnote{Transformation and relation traversal}
The construction of the property graph for a given set of \qvtr transformations requires each of them to be processed.
Since transformations are not executed but only transformed into a property graph, the processing order is not relevant.
Each transformation consists of a set of \qvtr relations, of which each usually only defines consistency for small parts of the metamodels.
Those relations depend on each other and can thus not be processed in arbitrary order.
Only those relations that may be invoked during the execution of transformations need to be considered, which could be derived from a call graph.
While top-level relations are always invoked during execution, other relations are only invoked in \texttt{where} or \texttt{when} clauses of other relations similar to function calls. 
Since \texttt{when} and \texttt{where} clauses are dual to each other, we restrict ourselves to relations that are invoked in \texttt{where} clauses. 
Then, starting from top-level relations, relevant relations can simply be identified by a depth-first traversal. 

\mnote{Graph construction}
The property graph construction starts with an empty graph.
For every processed \qvtr relation, vertices and a hyperedge may be added.
Each \qvtr relation needs to be translated into a set of predicates, which are represented by labeled hyperedges, in accordance with \autoref{def:propertygraph}.
As an example, we consider the relation $\mathvariable{PE}$ of our running example in \autoref{lst:compatibility:qvtr_running_example}, which relates the domains for persons and employees.
For each domain of a relation, the class tuples of the predicates are specified in the domain patterns.
In the example, these class tuples are $\classtuple{C}{\mathvariable{person}} = \tupled{\class{C}{\mathvariable{Person}}}$ and $\classtuple{C}{\mathvariable{employee}} = \tupled{\class{C}{\mathvariable{Employee}}}$.
Each class in each class tuple is associated with a set of property template items.
A property template item relates a property to an \gls{OCL} expression. 
For example, the property template item $\mathvariable{name} = \mathvariable{fstn} + "\text{\textvisiblespace}" + \mathvariable{lstn}$ defines that the property $\mathvariable{name}$ must match the \gls{OCL} expression $\mathvariable{fstn} + "\text{\textvisiblespace}" + \mathvariable{lstn}$.
The \gls{OCL} expressions, in turn, contain \qvtr variables, such as $\mathvariable{fstn}$ and $\mathvariable{lstn}$.
Predicates are supposed to relate those properties that actually share a consistency relation, i.e., that are actually put into relation by the \qvtr relation.
Such a relation is only given if two properties are related by the same \qvtr variables, because in such a case a value assignment to that variable must satisfy the property template items of both properties.
In such a case, a hyperedge is created and labeled with a function that realizes the conditions of the property template item.
For example, $\mathvariable{Person.firstname}$, $\mathvariable{Person.lastname}$ and $\mathvariable{Employee.name}$ are related by the \qvtr variables $\mathvariable{fstn}$ and $\mathvariable{lstn}$, thus a hyperedge is generated between them.
In contrast, constraints on $\mathvariable{Employee.salary}$ and $\mathvariable{Employee.name}$ are independent, because the property template items relate them to disjoint sets of \qvtr variables. 
Thus consistency of one does not depend on consistency of the other.
In addition to property template items, \gls{OCL} expressions relating properties occur in \texttt{when} and \texttt{where} clauses, of which we, again, focus on invariants of \texttt{where} clauses.
Like for property template items, properties related by shared \qvtr variables in these clauses have to be grouped into a hyperedge.

\begin{algorithm}
    \input{algorithms/correctness/compatibility/merge_properties}
    \caption[Merge of properties to predicates]{Merge to predicates. Adapted from~\owncite[Alg.~1]{klare2020compatibility-report}.}
    \label{algo:compatibility:merge_properties}
\end{algorithm}

\mnote{Merge algorithm}
\autoref{algo:compatibility:merge_properties} expresses the sketched procedure of merging properties to predicates that finally represent hyperedges of the property graph.
It manages couples, called \emph{entries}, of properties and \qvtr variables.
These entries denote that a set of properties is related by the according set of \qvtr variables.
The algorithm starts with a set of couples, of which each couple $\tupled{\setted{p}, V_{\setted{p}}}$ consists of a singleton $\setted{p}$ that presents a property $p$ and the \qvtr variables $V_{\setted{p}}$ it is related to by its property template item.
In each iteration, the algorithm chooses one reference entry and merges it with all other entries to which the intersection of their \qvtr variables is not empty.
The algorithm terminates when all sets of \qvtr variables are pairwise disjoint.

\begin{example}
The relation $\mathvariable{PE}$ of the \qvtr transformation $\mathvariable{PersonEmployee}$ in \autoref{lst:compatibility:qvtr_running_example} contains five properties, which can be described with these entries:
\begin{align*}
&
    \tupled{\setted{\propdisplay{firstname}}, \setted{\mathvariable{fstn}}}, 
    \tupled{\setted{\propdisplay{lastname}}, \setted{\mathvariable{lstn}}},
    \tupled{\setted{\propdisplay{income}}, \setted{\mathvariable{inc}}}, \\ 
&
    \tupled{\setted{\propdisplay{name}}, \setted{\mathvariable{fstn}, \mathvariable{lstn}}},
    \tupled{\setted{\propdisplay{salary}}, \setted{\mathvariable{inc}}}
\end{align*}
After the execution of the algorithm, properties are merged into two sets:
\begin{align*}
&
    \tupled{\setted{\propdisplay{firstname}, \propdisplay{lastname}, \propdisplay{name}}, \setted{\mathvariable{fstn}, \mathvariable{lstn}}},
    \tupled{\setted{\propdisplay{income}, \propdisplay{salary}}, \setted{\mathvariable{inc}}}
\end{align*}
\end{example}

\mnote{Hypergraph from algorithm}
Each entry delivered by the algorithm can be transformed into a hyperedge.
To this end, the properties are grouped into two tuples according to the domains they originally belonged to.
The predicate function is given by the conjunction of all \gls{OCL} expressions associated with properties of the entry, i.e., property template items and invariants.
For the subsequent identification of redundant relations, we only need to operate on this hypergraph rather than the original metamodels or \qvtr transformations.


\subsection{Decomposition of Consistency Relations}

\mnote{General decomposition procedure}
The decomposition procedure for proving compatibility of consistency relations aims at removing redundant relations until, in case of success, the remaining relations form sets of independent consistency relation trees.
For a property graph $\mathcal{M} = \tupled{\mathcal{H}, \function{l}}$, this is achieved by removing the hyperedges of $\mathcal{H}$ that represent redundant consistency relations until no further redundant relations can be found.
Redundancy according to \autoref{def:leftequalredundancy} is given if for a consistency relation an alternative concatenation of consistency relations that relates the at least partly same classes does not restrict consistency.
In terms of a graph, this means that there must be two paths between the same properties.
Independence of consistency relations is then given by connected components of the hypergraph, because they represent the properties that are related by constraints involving the same \qvtr variables.
According to \autoref{theorem:independencecompatibility}, consistency relations are compatible if they are composed of independent, compatible subsets.
Thus if compatibility can be shown for the relations in each connected component of the hypergraph, their union is also compatible.

\mnote{Dual of property graph}
While the hypergraph representation of predicates in consistency relations is well suited for reasons of expressiveness, the drawback of hypergraphs is the increased complexity of graph algorithms, such as graph traversal.
We therefore replace the property graph with its dual, i.e., an equivalent simple graph, for the realization of the redundancy test.
This dual graph contains the hyperedges of the property graph as vertices and edges between two vertices when their hyperedges in the property graph share at least one property.
\autoref{fig:compatibility:dual_propertygraph_example} shows the dual of a property graph of the running example.

\begin{definition}[Dual of a Property Graph]
Let $\mathcal{M} = (\mathcal{H}, \function{l})$ be a property graph. The dual of the property graph $\mathcal{M}$, denoted $\mathcal{M^{*}}$, is a tuple $\tupled{\mathcal{G}, \function{v}, \function{l}}$ with a simple graph $\mathcal{G}$ and two functions $\function{v}$ and $\function{l}$ such that:
    \begin{itemize}
        \item $V_{\mathcal{G}} \equalsperdefinition E_{\mathcal{H}}$
        \item $E_{\mathcal{G}} \equalsperdefinition \setted{\setted{E_1, E_2} \mid \forall \tupled{E_1, E_2} \in E_{\mathcal{H}}^2 : E_1 \cap E_2 \neq \varnothing}$
        \item $\forall \tupled{E_1, E_2} \in E_{\mathcal{G}} : \function{v}(\setted{E_1, E_2}) = E_1 \cap E_2$
    \end{itemize}
\end{definition}

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/dual_property_graph_running_example}
    \input{figures/correctness/compatibility/property_graph_legends}
    \caption[Dual of the property graph for the running example]{Dual of the property graph for the \qvtr example in \autoref{lst:compatibility:qvtr_running_example} based on the relations in \autoref{fig:compatibility:three_persons_example_extended}. Adapted from~\owncite[Fig.~12]{klare2020compatibility-report}.}
    \label{fig:compatibility:dual_propertygraph_example}
\end{figure}

\mnote{Dual graph expressiveness}
The function $\function{v}$ labels each edge $\setted{E_1, E_2}$ in the dual with the set of properties that occur both in $E_1$ and $E_2$.
Since the property graph and its dual have equal expressiveness, the property graph can be constructed out of the dual again.
Given a dual $\mathcal{M^{*}} = \tupled{\mathcal{G}, \function{v}, \function{l}}$, the property graph $\mathcal{M} = \tupled{\mathcal{H}, \function{l}}$ can be built by defining $V_{\mathcal{H}} = \bigcup_{V \in V_{\mathcal{G}}} V$ and $E_{\mathcal{H}} = V_{\mathcal{G}}$. 

\mnote{Independence in property graphs}
Independence of consistency relations in the property graph is characterized by the existence of two (or more) subhypergraphs\footnote{A subhypergraph of a hypergraph $\mathcal{H} = (V_{\mathcal{H}}, E_{\mathcal{H}})$ is a hypergraph $\mathcal{S} = \tupled{V_{\mathcal{S}}, E_{\mathcal{S}}}$ such that $E_{\mathcal{S}} \subseteq E_{\mathcal{H}}$ and $V_{\mathcal{S}} = \bigcup_{E \in E_{\mathcal{S}}} E$} such that there is no path (i.e., sequence of incident hyperedges) from one to the other.
In the dual of the property graph, such a situation is represented by two subgraphs that are not connected to each other.
This conforms to the notion of connected components, which are maximal subgraphs such that any two vertices are connected by a path of edges and reflects the notion of independence given in \autoref{def:independence}.
Per definition, each subgraph relates disjoint sets of properties, as otherwise an edge between two vertices that contain an intersection of these properties would exist.
These property sets occur in independent sets of consistency relations, as otherwise there would be a vertex in the dual of the property graph for a hyperedge of the property graph that relates the properties that are linked by an \gls{OCL} expression and according \qvtr variables.
We use Tarjan's algorithm to compute the connected components of the dual of the property graph in linear time~\cite{tarjan1972depth}.
These independent subgraphs can be processed independently, since their compatibility composes (see~\autoref{theorem:independencecompatibility}).

\mnote{Trees in property graphs}
In addition to independence, \autoref{theorem:treecompatibility} stating that consistency relation trees are compatible also applies to the dual of the property graph.
When there are no two paths relating the same classes or properties, respectively, the notion of a consistency relation tree is fulfilled, thus the represented consistency relations are inherently compatible.
Consequently, if the dual of the property graph is only composed of independent trees, i.e., if it is a \emph{forest}, it is inherently compatible.

\mnote{Redundancy in property graphs}
Finally, \autoref{corollary:transitiveredundancycompatibility} has shown that adding left-equal redundant consistency relations to a compatible consistency relation set preserves its compatibility.
According to \autoref{def:leftequalredundancy} for redundancy, we consider a predicate and its representing hyperedge, respectively, redundant if there is another concatenation of predicates that are always fulfilled if the redundant one is fulfilled.
In the hypergraph, this conforms to an alternative sequence of hyperedges that represent those predicates, which relates the same properties as the possibly redundant one.
In our operationalization, we only consider the case when the exact same classes are related by both the possibly redundant and the alternative concatenation of predicates, although the definition only requires the classes at the left side to be equal.
The existence of such an alternative path is, however, only a necessary but not a sufficient condition.
The predicates must also relate the properties in the same way, as, for example, one predicate may ensure that two string attributes are equal, whereas an alternative sequence of predicates only ensures that they have the same length.
This is the reason why we perform a redundancy test for redundancy candidates given by such an alternative path, which we explain in the subsequent subsection.

\mnote{Alternative paths in property graphs}
An alternative path for a hyperedge $E$, which represents a predicate in the property graph, is a sequence of pairwise incident hyperedges, of which the first and last edge are incident to $E$.
In the dual of the property graph, these hyperedges are represented by vertices.
Thus, in the dual such an alternative sequence is given by a cycle including the vertex $E$.
Let $\sequenced{E, E_1, \dots, E_n, E}$ be the vertex sequence of such a cycle, then $\sequenced{E_1, \dots, E_n}$ is the alternative path.
The generation of redundant paths amounts to the enumeration of pairs $\tupled{E, \sequence{E}_i}$, where $E$ is a possibly redundant predicate, i.e., a vertex in the dual of the property graph, and $\sequence{E}_i$ is an alternative sequence of predicates that may replace $E$.
There may be multiple such possible alternative paths for a single predicate, thus all simple cycles in the dual of the property graph need to be considered.
The problem of finding all simple cycles in an undirected graph is called \emph{cycle enumeration}.

\begin{algorithm}
    \input{algorithms/correctness/compatibility/cycle_enumeration}
    \caption[Removal of redundant predicates]{Predicates removal. Adapted from~\owncite[Alg.~2]{klare2020compatibility-report}.}
    \label{algo:compatibility:cycle_enumeration}
\end{algorithm}

\mnote{Redundant relation removal algorithm}
\autoref{algo:compatibility:cycle_enumeration} implements the enumeration of alternative paths for predicates and their removal in case they are redundant.
The implementation of identifying a candidate predicate as actually redundant within a cycle is assumed to be available as an external function $\function{IsRedundant}$.
As discussed before, this allows us to plug in different implementations for the redundancy test, of which we depict one in the subsequent subsection.
The algorithm is mainly concerned with the enumeration of alternative paths.

\mnote{Cycle enumeration}
The algorithm relies on the computation of a \emph{cycles basis}, which is a set of simple cycles from which all other simple cycles of the graph can be derived by combination.
This cycle basis is computed using Paton's algorithm~\cite{paton1969algorithm}.
For a given predicate, the enumeration processes each cycle from the cycle basis and merges it with all cycles that have been processed so far. 
Every cycle is represented as a set of edges.
We denote the symmetric difference with the $\oplus$ sign, i.e., $A \oplus B$ is the set of edges that are in $A$ or in $B$ but not in both.
The set $\mathvariable{foundCycles}$ contains all linear combinations of cycles that have been processed so far.
Merged with cycles of the basis $\mathvariable{base}_1, \dots, \mathvariable{base}_n$, these linear combinations are used to merge more than two cycles of the basis.
In each iteration of \autoref{algo:compatibility:cycle_enumeration}, processing a new cycle $\mathvariable{base}$ from the cycle basis, new simple cycles are in $\mathvariable{currentCycles} \cup \setted{\mathvariable{base}}$. Edge-disjoint or non-simple cycles are stored in $\mathvariable{currentCycles}^*$.

\mnote{Redundancy test}
The redundancy test is performed in \autoref{algo:compatibility:cycle_enumeration:line:redundancyTest} whenever new cycles are generated.
It checks for the given predicate $\mathvariable{pred}$ whether one of the newly generated cycles is redundant, i.e., whether it contains $\mathvariable{pred}$ and whether $\mathvariable{pred}$ can be replaced by the concatenation of other predicates.
If the test succeeds for an alternative sequence of predicates, the candidate can be removed.
The algorithm then proceeds with further possibly redundant predicates.
It terminates as soon as all predicates have been tested.
If the connected component of the graph becomes a tree after a predicate removal, the dual of the connected component does not contain cycles anymore, thus no further redundancy tests have to be performed.
In the following, we discuss how such a redundancy test can be realized.


\subsection{Redundancy Check for Consistency Relations}
\label{chap:compatibility:practical_approach:redundancies}

\mnote{Redundancy test as black box}
We have so far considered the redundancy test of predicates in the decomposition procedure as a black box, which can be realized by any approach that is able to prove redundancy of predicates.
This fosters independent reuse of the proposed decomposition procedure and the redundancy test to be presented in the following.
\autoref{algo:compatibility:cycle_enumeration} contains the function \function{IsRedundant} that needs to realize this check.

\mnote{Redundancy undecidability}
Since \gls{OCL} expressions have equal expressiveness than fist-order logic, reasoning about satisfiability of \gls{OCL} constraints is undecidable~\cite{beckert2002ocltranslation}.
Deciding whether a predicate is redundant reduces to deciding satisfiability, which is why no strategy that always decides redundancy can be defined.
In the following, we first discuss how predicates can be generally compared to prove compatibility.
We then present an approach that translates \gls{OCL} constraints of the predicates into first-order formulae and applies a theorem prover.
Finally, we discuss the limitations of the approach especially arising from the translation to first-order logic and the use of a theorem prover.

\mnote{Redundancy notion for predicates}
A redundancy test takes a couple $\tupled{E, \sequenced{E_1, \dots, E_n}}$ and returns \textsc{true} whenever the predicate $E$ is proven to be redundant to the sequence of predicates $\sequenced{E_1, \dots, E_n}$.
Redundancy as defined in \autoref{def:leftequalredundancy} requires the set of consistency relations, which are defined by the predicates, to be equivalent with and without the redundant relation.
This especially means that removing the redundant relation must not weaken consistency, i.e., it must not lead to models being considered consistent without that relation that are not considered consistent with that relation.
This is equivalent for a property graph, in which a redundant predicate may not restrict consistency by considering a model with specific property values inconsistent that are considered consistent by an alternative sequence of predicates.
A predicate $E$ can thus only be removed if all instances matching the predicate also match predicates $\sequenced{E_1, \dots, E_n}$.
In fact, \autoref{def:leftequalredundancy} limits redundancy to relations in which the left-side classes are equal.
We do, however, only consider relations between the same sets of properties, thus being restricted to relations between the same sets of classes anyway.

\mnote{Extensional redundancy test}
In consequence, a redundancy test realizes the comparison of two sets of instances of models or, in particular, property values.
A predicate can, however, be fulfilled by an infinite number of property values, i.e., condition elements in terminology of consistency relations, such as consistency of person incomes and employee salaries by an infinite number of integer pairs.
An extensional element-wise comparison is thus generally impossible.

\mnote{Intensional redundancy test}
For that reason, we consider the intensional specification of consistency relations by means of \gls{OCL} constraints.
These constraints are annotated to the property graph as hyperedge labels.
The redundancy test can thus be realized by a static analysis of these labels and \qvtr relation conditions in \texttt{when} and \texttt{where} clauses.
One such strategy is the transformation of \gls{OCL} expressions into first-order logic and the reasoning about the resulting first-order formulae~\cite{beckert2002ocltranslation, berardi2005umlreasoning}.
We set up the first-order formulae such that they are valid, i.e., \textsc{true} under every possible interpretation, whenever the redundancy test is positive.
This transformation benefits from the availability of theorem proving tools for reasoning about first-order formulae.

\mnote{First-order logic representation}
Since first-order logic is generally undecidable, redundancy of a relation cannot be proven for every derived formula.
Thus, the result quality of the decomposition procedure depends on the quality of the theorem prover.
The transformation of \gls{OCL} to logic formulae requires a representation of all constructs, such as arithmetic operations, strings, arrays, etc., in formulae.
Objects, such as strings, floats, sequences, and others can be represented by theories of theorem provers.
With theories, the satisfiability problem equates to assigning values to variables in first-order logic sentences such that their evaluation returns \textsc{true}.
For example, the formula $(a \times b = 6) \land (a + b > 0)$ is satisfiable given the assignment $\setted{a = 2, b = 3}$.
This extension is known as \glsfirst{SMT}.
Formulae for the \gls{SMT} problem are called \emph{\gls{SMT} instances}.
\emph{Theory-based theorem provers} provide built-in theories, to which we translate \gls{OCL} constraints for our redundancy test.

\mnote{Redundancy of predicates}
The information that is necessary for a redundancy test is given by the predicates passed to the test.
Let $E = \tupled{\propertysettuple{P}{\classtuple{C}{l}}, \propertysettuple{P}{\classtuple{C}{r}}, \function{f}_E}$ be a predicate for two class tuples $\classtuple{C}{l}$ and $\classtuple{C}{r}$. 
During the construction of the property graph, a hyperedge composed of all properties in $\propertysettuple{P}{\classtuple{C}{l}}$ and $\propertysettuple{P}{\classtuple{C}{r}}$ is labeled with the description of the predicate function $\function{f}_E$.
Such a predicate $E$ can be replaced by a sequence of other predicates $\sequenced{E_1, \dots, E_n}$ if $\function{f}_E$ evaluates to \textsc{true} whenever $\function{f}_{E_1} \wedge \dots \wedge \function{f}_{E_n}$ evaluates to \textsc{true}.
In that case, the removal of the consistency relation given by $E$ does not weaken consistency, because it is fulfilled only when  the relation given by the concatenation of $\sequenced{E_1, \dots, E_n}$ is fulfilled anyway.
In consequence, $E$ is redundant.
This redundancy test can be encoded as a formula in the following way:
\begin{align*}
    &
    (\function{f}_{E_1} \wedge \dots \wedge \function{f}_{E_n}) \Rightarrow \function{f}_{E}
\end{align*}

\mnote{Horn clauses}
This formula is a \emph{Horn clause}.
According to common terminology, we call terms at the left-hand side of the clause \emph{facts} and the term at the right-hand side \emph{goal}.
The assignment of values to variables in the Horn clause also models the instantiation of properties, i.e., the assignment of property values.
If the Horn clause is valid, the alternative sequence of predicates can replace the other predicate for every instance.
Variables in Horn clauses are usually implicitly quantified universally.
Predicate functions of \gls{OCL} expressions, however, need to contain existentially quantified \qvtr variables, as the pattern matching of the expressions requires the existence of values for these variables.

\begin{example}
\autoref{fig:compatibility:dual_propertygraph_example} depicts the dual of the property graph for the motivational example in \autoref{lst:compatibility:qvtr_running_example}. 
It contains four connected components, of which three contain only one predicate. 
These three components are trivial trees, so compatibility for them is proven.
The other component consists of three predicates and contains a cycle ($\sequenced{1, 2, 3}$).
Let $3$ be the possibly redundant predicate.
Then, the alternative combination of predicates is composed of $1$ and $2$. 
This leads to the following formula with facts $1$ and $2$ and goal $3$:
\begin{align*}
    &
        \big(\propdisplay{Person.firstname} = \mathvariable{fstn1} \land \propdisplay{Person.lastname} = \mathvariable{lstn1}\\
    &
        \formulaskip \land \propdisplay{Resident.name} = \mathvariable{fstn1} + "\text{\textvisiblespace}" + \mathvariable{lstn1} \\
    & 
        \land 
            \propdisplay{Person.firstname} = \mathvariable{fstn2} \land \propdisplay{Person.lastname} = \mathvariable{lstn2}\\
    &
        \formulaskip \land \propdisplay{Employee.name} = \mathvariable{fstn2} + "\text{\textvisiblespace}" + \mathvariable{lstn2} \big)\\
    & 
        \Rightarrow
        \big(
            \exists n : (
                \propdisplay{Resident.name} = \mathvariable{n} \land \propdisplay{Employee.name} = \mathvariable{n}
            )
        \big)
\end{align*}
\qvtr variables have been renamed to avoid conflicts, because they are no longer isolated as they were before in distinct \qvtr relations.
The formula is valid and will be identified as such by an \gls{SMT} solver.
For that reason, predicate~$3$ can be removed from the property graph and its dual. 
Since the component then only consists of two predicates and thus forms a tree, the represented consistency relations are compatible.
Since all independent consistency relation sets, represented by the independent connected components of predicates, are compatible, the complete consistency specification is compatible.
\end{example}

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/redundancy_test}
    \caption[Redundancy test overview]{Overview of the redundancy test from \gls{OCL} expressions to the \gls{SMT} solver results. Adapted from~\owncite[Fig.~14]{klare2020compatibility-report}.}
    \label{fig:compatibility:redundancytest}
\end{figure}

\mnote{Satisfiability of negation}
Whenever such a Horn clause is valid, i.e., \textsc{true} under every interpretation, redundancy of the consistency relation represented by the predicate given as the clause goal is proven.
The \gls{SMT} solver takes the clause as an \gls{SMT} instance and verifies its satisfiability whenever possible.
Proving that a Horn clause $H$ is valid is equivalent to proving that its negation $\neg H$ is unsatisfiable.
Therefore, we actually let the \gls{SMT} solver prove that the \gls{SMT} instance $\function{f}_{E_1} \wedge \dots \wedge \function{f}_{E_n} \wedge \neg \function{f}_{E}$ is unsatisfiable.
The complete process of the redundancy test is depicted in \autoref{fig:compatibility:redundancytest}.
The solver can provide the following three results.
\begin{properdescription}
    \item[Satisfiable:] If $\neg H$ is satisfiable, $H$ is not valid. An interpretation exists, i.e., an instantiation of properties, that fulfills the possibly redundant predicate but not the alternative sequence of predicates. Thus, the predicate is not redundant and cannot be removed.
    \item[Unsatisfiable:] If $\neg H$ is unsatisfiable, $H$ is valid. Thus, when the alternative sequence is fulfilled, the predicate is fulfilled as well. It is redundant and can be removed.
    \item[Unknown:] First-order logic being undecidable, a theorem prover cannot evaluate satisfiability of all formulae, thus also returning \emph{Unknown}. To ensure conservativeness, the redundancy test is considered negative. As a result, the predicate is not removed.
\end{properdescription}

\mnote{Translation to logic formulae}
For the actual translation of \gls{OCL} expressions in \qvtr relations into \gls{SMT} instances, we refer to existing work on translating \gls{OCL} to first-order formulae~\cite{beckert2002ocltranslation} and, in particular, to our work presenting the specific translation for proving compatibility~\owncite{klare2020compatibility-report}.
\qvtr uses a subset of \gls{OCL} called \emph{EssentialOCL}~\cite{qvt}, which is a side-effect-free sublanguage that provides primitive data types, data structures and operations to express constraints on models.
Several \gls{OCL} constructs have a direct equivalent in theories of the theorem prover or can be mapped to a combination of primitive constructs.
We employ the SMT-LIB specification, which is a standard that provides an input language for \gls{SMT} solvers~\cite{smtlib2017}, and the Z3 theorem prover~\cite{z32008} to realize the redundancy test.
A complete reference of translated constructs has been developed in the Master's thesis of \textowncite{pepin2019ma}.

\mnote{Untranslatability}
In addition to undecidability of \gls{OCL}, some \gls{OCL} operations are said to be \emph{untranslatable}, because no mapping to features of \gls{SMT} solvers were found yet.
Thus, some \qvtr relations cannot be processed automatically by the proposed decomposition procedure.
For example, string operations like $\mathvariable{toLower}$ and $\mathvariable{toUpper}$ cannot be easily translated into logic formulae for \gls{SMT} solvers without several used-defined axioms.
Although decision procedures for such a case exist~\cite{veanes2012transducers}, they are not yet integrated into solvers.

\mnote{Practical approach summary}
In this section, we have discussed how the formal approach for proving compatibility as depicted in \autoref{algo:compatibility:formal_proof} can be realized for \qvtr.
We have defined a representation of consistency relations in graphs and explained how they can be derived from \qvtr transformations.
We have discussed how a consistency relation tree and independent relation sets manifest in such a graph and how candidates for redundancies can be found in it.
Finally, we have presented a redundancy test based on transforming \gls{OCL} expressions of potentially redundant relations into Horn clauses that are validated by \gls{SMT} solvers.
