\chapter{A Systematic Approach to Prevent and Detect Errors
    \pgsize{45 p.}
}
\label{chap:prevention}

To ensure that a network of \acp{BX} operates properly, potential mistakes %, as identified in the previous section, 
must be avoided.
%\todoHeiko{Klarmachen, dass wir hier keine vollumfänglichen Lösungsstrategien präsentieren, sondern das, was man im Prinzip auf den Ebenen tun muss. Nur für die unterste Ebene gibt es ein Konzept}
We evaluate our categorization regarding correctness and completeness %for that 
in a case study that combines independently developed transformations.
In that case study, we classify occurring failures with our categorization and trace them back to a causal mistake.
To identify whether such a classification is correct, we need to be able to fix the mistake and validate that the failure disappears.
%To investigate whether the classification of revealed mistakes is correct, we need to be able to fix them. %the classification of a mistake was correct and if another mistake was potentially hidden by the fixed one.
%Therefore, we do not provide complete solution strategies, but instead discuss how mistakes at the different levels can be avoided in general as our contribution \ref{contrib:avoidance}.
Therefore, we discuss general strategies to avoid mistakes at the different levels as our contribution \ref{contrib:avoidance} and apply them in the evaluation.
%, we discuss how mistakes at the different levels can be avoided in general, but do not provide complete solutions % solution strategies
%in this work.

%At the system level, mistakes can only be avoided by careful requirements elicitation. 
%Since occurring mistakes on that level represent non-conformance with a usually informal notion of consistency, such mistakes cannot be automatically avoided or detected.
At the global level, mistakes occur due to non-conformance with an informal notion of consistency and %cannot be detected automatically but 
can only be avoided by careful requirements elicitation. 
We therefore have to assume that global level mistakes are reliably avoided by the developers.
Analytic approaches~\cite{klare2018docsym}
can ensure that specifications at the modularization and operationalization level are free of faults.
%This can be applied on both the modularization and the operationalization level.
Nevertheless, %under the assumption that transformations are developed independently, 
the drawback of such an approach is that it works a-posteriori, when transformations are combined to a network. %, so transformations would have to be adapted %after their specification 
%when they are combined to a network
We, in contrast, want to achieve avoidance of interoperability issues a-priori, so that transformations can be developed independently and combined afterwards.
It is easy to see that mistakes at the modularization level cannot be avoided a-priori. 
%If modular transformations are developed independently, 
Ensuring that transformations are non-contradictory %, i.e. that they rely on the same notion of a global consistency specification, 
would require developers to have knowledge about the other transformations, which breaks the assumption of independent development.
%This breaks our assumption that developers have restricted domain knowledge, each defining one modular consistency specification.
%
Finally, mistakes regarding element matching at the operationalization level are domain-independent. 
This enables the development of generic mechanisms to ensure interoperability at the operationalization level by construction, without knowing about other transformations.

In the following, we discuss one strategy to avoid mistakes at the modularization and one to avoid those at the operationalization level.
Developers can use these strategies to build networks that are free of faults, or can use them to fix mistakes if failures occur.

% MOVED TO BEGINNING OF SECTION
% We evaluate our categorization in a case study combining independently developed transformations. 
% For that, we need to fix mistakes in order to investigate whether their classification was correct. %the classification of a mistake was correct and if another mistake was potentially hidden by the fixed one.
% Therefore, we do not provide complete solution strategies, but instead discuss how mistakes at the different levels can be avoided in general as our contribution \ref{contrib:avoidance}.

%We therefore assume that mistakes on modularization level are avoided as well and investigate, under this assumption, whether the operationalization can be develop interoperable by construction.

% \begin{itemize}
%     \item Problems on all three levels must be avoided
%     \item On all levels, possibility to use model checking for finding faults when combining a set of transformations (cf. \cite{klare2018docsym}
%     \item Detecting mistakes on level 1 is hard, because one would have to compare the specification against a natural, usually unspecified notion of consistency
%     \item Drawback: works a-posteriori, so transformations would have to be adapted afterwards to be used together
%     \item Therefore: approach for a-priori avoidance of interoperability issues necessary
%     \item Problem: on level 2 no a-priori avoidance of problems possible, or overall knowledge from level 1 necessary -> breaks our assumption of independent development
%     \item But: On level 3 possibility to develop mechanisms and patterns to ensure interoperability on that level by construction, because it only concerns the operationalization of specifications. In contrast to the consistency specifications, which are domain specific, the operationalization follows a generic pattern for which generic interoperability solutions can be derived
%     \item We assume interoperability on level 2 for our approach so that there are no interactions between mistakes on the level 2 and 3 (no precise enough)
% \end{itemize}


\section{Analyzing Transformations for Contradicting Consistency Relations \pgsize{15 p.}}
Goal: Applies formal framework for extensional specification to actual languages with intensional specification (MA Aurélien)

%FORMERLY: \subsection{Contradiction-free Modularizations}

Contradictions in binary consistency specifications cannot be avoided by design.
%They can, in the best case, be found by analyzing a combination of modular specifications.
However, the structure of the network of specifications influences how prone to mistakes it is~\cite{klare2018docsym}.
Two extremes of networks are depicted in \autoref{fig:correctness:modularization_strategies}:
One is to have a specification for each pair of model types, inducing a dense graph. % of specifications.
This extreme is prone to contradictions, because all relations are redundantly specified across several paths.
Another extreme is to define each relation, potentially indirectly, only once, so that only one path of consistency specifications exists between each pair of model types.
This leads to a tree of specifications, which is inherently free of contradictions and %, as there is only one path of specifications between each pair of model types.
%Thus, it 
avoids modularization mistakes by design.
%Nevertheless, developers must understand the complete network to know which relations are represented, which is contradictory to our assumption of independent development.
%Nevertheless, it breaks our assumption that specifications are developed independently, because relations are expressed indirectly, so developers must understand the complete network to know which relations are represented.
However, it requires that such a network structure exists at all, because between three model types there must always be one relation that can be expressed transitively across the other two (cf.~\cite{klare2018docsym}).
For example, if $\mathit{CS}_{1,3}$ in \autoref{fig:correctness:mistakes_specification_levels} shall be omitted and transitively expressed across $\mathit{CS}_{1,2}$ and $\mathit{CS}_{2,3}$, it must hold that:
% \begin{align*}
%     & \forall M_1 \in \mathcal{M}_1 : \forall M_2 \in \mathcal{M}_2 : \forall M_3 \in \mathcal{M}_3 : \\
%     & \hspace{1em} \mathit{CS}(M_1, M_2, M_3) \iff \mathit{CS}_{1,2}(M_1, M_2) \land \mathit{CS}_{2,3}(M_2, M_3)
% \end{align*}
\begin{align*}
    & \forall M_1, M_2, M_3 : (M_1, M_2, M_3) \in \mathit{CS} \Leftrightarrow (M_1, M_2) \in \mathit{CS}_{1,2} \land (M_2, M_3) \in \mathit{CS}_{2,3}
\end{align*}
%If this transitive relation misses or is even unable to express certain direct constraints, inconsistent models would be identified as consistent. %\todoHeiko{Das transitive muss man wohl an einem Beispiel erklären, am besten Ref. zu Intro}

\begin{figure}[tb]
    \centering
    \input{figures/correctness/modularization_strategies.tex}
    \caption{Extremes of Strategies for Modularizing Consistency Specifications}
%    \todoHeiko{Ergänzen um Angaben Metamodelle und evtl. Relationsnamen. Angleichen zur Relationen-Grafik}
    \label{fig:correctness:modularization_strategies}
\end{figure}

In consequence, if a network of transformation can be built that is a tree, mistakes at the modularization level are avoided by design.
If a tree cannot be achieved, it is necessary to find and fix mistakes when transformations are combined to a network.
In this case, the consistency specifications must be revised whenever non-termination or non-deterministic termination of consistency preservation is observed (see \autoref{fig:correctness:categorization}). %, or, if possible, analyzed for potential contradictions before execution~\cite{klare2018docsym}.
%This can potentially be supported by model checking techniques~\cite{klare2018docsym}.

% \subsection{Modularization Options}
% %ADD: We consider level 2 and 3, and assume level 1.
% %ADD: Transformations languages on level 2 or 3, but could also be on level 1
% \todoHeiko{ADD: Distinction on level 2 regarding one path / several paths -> redundancy or bottleneck -- Do that here?}
% \todoHeiko{Eigentlich brauchen wir der Argumentation nach diesen Abschnitt nicht. Er ist aber extrem wichtig. Irgendwo anders einbauen?}

% For modularizing consistency specifications, two extremes of approaches can be applied, as discussed in \cite{klare2018docsym} and depicted in \autoref{fig:modularization_strategies}. One of these extremes is to have each existing binary consistency relation represented in a consistency specification, which leads to a dense graph of specifications as shown in the left of \autoref{fig:modularization_strategies}. Another extreme is to define each consistency relation only across one path in the graph of consistency specifications, leading to a tree of consistency specifications as shown in the right of \autoref{fig:modularization_strategies}.

% \begin{figure}[tb]
%     \centering
%     \input{figures/modularization_strategies.tex}
%     \caption{Strategies for Modularizing Consistency Specifications}
%     \todoHeiko{Ergänzen um Angaben Metamodelle und evtl. Relationsnamen. Angleichen zur Relationen-Grafik}
%     \label{fig:modularization_strategies}
% \end{figure}

% To discuss the implications of the different strategies, we consider the simplified example in \autoref{fig:relations_example}. The relation $R$ is defined for three \metamodels $\mathcal{M}_1, \mathcal{M}_2$ and $\mathcal{M}_3$ on system level (Level 1). This relation can be modularized into three binary relations $R_1, R_2 and R_3$ on modularization level (Level 2).

% \begin{figure}[tb]
%     \centering
%     \includegraphics[angle=270, width=0.7\textwidth]{figures/relations_example.pdf}
%     \caption{Example Relations on System and Modularization Level}
%     \label{fig:relations_example}
% \end{figure}

% The first extreme, to specify every existing consistency relation, has the advantage that modularity is very high in the sense that any subset of the \metamodels between which consistency is specified can be selected and kept consistent when instantiating them. In the example, it is possible to use only instances of $\mathcal{M}_1$ and $\mathcal{M}_2$ for example, omitting $\mathcal{M}_3$ without losing the specification of certain consistency relations. 
% The drawback of this approach is the high degree of redundancy, as each consistency relations is specified multiple times across different paths. Those redundant specifications can easily contradict and lead to mistakes.
% The cause for contradicting consistency specifications is that at least one of them is not conform to the underlying consistency relation of the system. In the example, $R_1$ would be erroneous if the following condition holds:
% \begin{align*}
%     \exists M_1 \in \mathcal{M}_1 : \exists M_2 \in \mathcal{M}_2 : \exists M_3 \in \mathcal{M}_3 : [R(M_1, M_2, M_3) \land \neg R_1(M_1, M_2)] \lor [\neg R(M_1, M_2, M_3] \land R_1(M_1, M_2)]
% \end{align*}
% Since the relation $R$ is usually not specified explicitly, but implicitly through the partial, binary consistency specifications, such mistakes lead to contradictions between different binary consistency specifications.

% The second extreme, if each consistency relations is only represented across one path of consistency specifications, no redundancies exist, avoiding potential contradictions and mistakes induced by that. Nevertheless, it requires to find a network structure that is capable of representing all consistency relations without having multiple paths between two \metamodels in the graph of consistency specifications. This requires that of three \metamodels there is always one representing the overlapping information of the two others. 
% Therefore it must be possible to remove one of the relations without losing the representation of certain consistency relations. In the example, $R_3$ can be omitted, so that only $R_1$ and $R_2$ are used, if the following condition holds:
% \begin{align*}
%     \forall M_1 \in \mathcal{M}_1 : \forall M_2 \in \mathcal{M}_2 : \forall M_3 \in \mathcal{M}_3 : R(M_1, M_2, M_3) \Leftrightarrow R_1(M_1, M_2) \land R_2(M_2, M_3)
% \end{align*}
% If a developer accidentally leaves one a binary relation although the condition above is not fulfilled, some global consistency relations are not covered any more, which can lead to inconsistencies.

% An essential drawback of the second approach is that the network structure prescribes which parts of the consistency relations a binary consistency specification has to contain. Therefore, the consistency specifications cannot be developed independently, as their contents depend on those of the others. 
% \todoHeiko{Das letzte stimmt eigentlich nicht, denn auch bei dem anderen Verfahren muss man eigentlich die anderen Transformationen kennen, damit man Widersprüche vermeidet}
% \todoHeiko{Was wollen wir mit diesem Abschnitt jetzt eigentlich genau sagen?}

% \todoHeiko{MÖGLICHERWEISE: Diese Abschnitt hinter die Issues stellen als Begründung für die Issues und deren Diskussion auf Level 2? Dann steht das ungefähr auf einer Ebene mit Level 3! Könnte man auch in eigenes Kapitel packen, dann werden Level 2 und Level 3 explizit behandelt, Level 1 schließen wir ja eh aus. Gefällt mir auf den ersten Blick VIEL BESSER.}



\section{Ensuring Interoperability of Executed Transformations \pgsize{15 p.}}
Goal: Avoidance strategies for interoperability mistakes, i.e. achieving synchronization of transformations (MA Torsten / Timur)

% FORMERLY: \subsection{Matching Elements in Operationalizations}

To avoid failures due to mistakes at the operationalization level, transformations must respect that other transformations may have already created elements.
In the binary case, this is unnecessary.
A single incremental \ac{BX} can assume that elements are either created by the user, %and then are input of the transformations
or were created by the transformation itself.
To identify corresponding elements, transformation languages usually use trace models, which are created by the transformations.
When \acp{BX} are combined to networks, %elements may also be created by other transformations.
%In consequence, 
direct trace links may be missing because a sequence of other transformations created the elements and trace links only indirectly across elements in other models.
%Thus, it is necessary to establish direct trace links between corresponding elements.´
In this scenario, corresponding elements can be matched by information at three levels:
%Such element matching can be performed on three levels:
\begin{enumerate}
    \item \emph{Explicit unique}: The information that elements correspond is unique and represented explicitly, e.g., within a trace model. %Existing transformation languages usually use this technique.
    \item \emph{Implicit unique}: The information that elements correspond is unique, but represented implicitly, e.g., in terms of key information within the models such as element names. %types and element names.
    \item \emph{Non-unique}: If no unique information exists, heuristics must be used, e.g. based on ambiguous information or transitive resolution of indirect trace links.
\end{enumerate}

Indirect trace links, which link elements transitively across other models, usually exist for elements that correspond, because other transformations have already created them.
Nevertheless, indirect trace links cannot be used to unambiguously identify such elements.
An element can correspond to multiple elements in another model, which is why most transformation languages offer tagging of trace links with additional information to identify the correct element.
%For example, a component in an architecture description could be mapped to two classes in an object-oriented design, one providing the component implementation and one providing utilities.
%The relevant corresponding element can be retrieved if the traces are tagged with the information that one class is the implementation and one is a utility.
For example, a language may tag trace links with the transformation rule they were instantiated in.
This is helpful in the bidirectional case, but when links are resolved transitively, these tags have been created by other, independently developed transformations, and are thus unknown.
%If such tags would be considered, transformations would depend on tags of other transformations and could thus not be developed independently anymore.
Therefore, resolving indirect trace links is only a heuristic, but does not unambiguously retrieve corresponding elements.

% Explain how to match rules on three different levels, what the levels can provide etc.

% \begin{enumerate}
%     \item Direct Correspondences
%     \item Key information
%     \item Heuristics: Indirect correspondences, potentially ambiguous information
% \end{enumerate}

Finally, it is up to the transformation engine or the transformation developer %, depending on the provided abstraction level, 
to ensure that elements are correctly matched.
In contrast to the bidirectional case, direct trace links cannot be assumed in case of networks of \acp{BX}.
Therefore, key information within the models must always be considered to identify matching elements.
Whenever direct trace links or unique key information exists, relevant elements can be unambiguously matched.
In all other cases, heuristics must be used, which potentially leads to failures.



\section{Orchestrating the Execution of Transformation Networks \pgsize{15 p.}}
Unability to find always terminating orchestration (Turing completeness, Halting problem). Relate to or define restriction of having unique choices in all transformations. Otherwise, propose engineering strategy for execution order by induction (Pdf Joshua)



