\section{A Formal Approach to Prove Compatibility}
\label{chap:compatibility:formal_approach}

\mnote{Compatibility validation approach}
In this section, we derive a formal approach for proving compatibility of consistency relations from the given definition.
It bases on two ideas:
\begin{longenumerate}
    \item A set of consistency relations in which each pair of classes is only related across one concatenation of relations is inherently compatible, because there cannot be any contradictory relations. We precisely define this in a specific notion of \emph{consistency relation trees}.
    \item A consistency relation that is redundant in a set of relations, i.e., a relation that does not alter the notion of consistency for models regarding the other relations in that set, does not affect compatibility and can thus be removed from that set of relations.
\end{longenumerate}
Given a set of consistency relations, compatibility can be proven inductively by finding a consistency relation tree (or multiple such trees) that is equivalent to the set of relations by removing redundant relations from that set.
Such an equivalent consistency relation tree serves as a \emph{witness} for compatibility of a set of relations.
In the following, we formalize and prove this inductive approach to check compatibility of a set of consistency relations.

\mnote{Equivalence of consistency relations}
The sketched approach is essentially based on a notion of equivalence for sets of consistency relations.
We consider two sets of consistency relations equivalent if they consider the same model tuples consistent.

\begin{definition}[Consistency Relations Equivalence]
\label{def:equivalence}
    Let $\consistencyrelationset{CR}_{1}$ and $\consistencyrelationset{CR}_{2}$ be two sets of consistency relations defined for a tuple of metamodels $\metamodeltuple{M}$.
    We say that:
    \begin{align*}
        &
        \consistencyrelationset{CR}_{1} \equivalenttomath \consistencyrelationset{CR}_{2} \equivalentperdefinition \\
        & \formulaskip
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} :
        \big(
            \modeltuple{m} \consistenttomath \consistencyrelationset{CR}_{1} \equivalent \modeltuple{m} \consistenttomath \consistencyrelationset{CR}_{2}
        \big)
    \end{align*}
\end{definition}

\mnote{Usage of equivalence}
We later use the notion of equivalence to introduce a notion of redundancy that is compatibility-preserving.
In the following, we first consider structures of consistency relation sets that are inherently compatible and afterwards discuss redundancy as a means to reduce and decompose a relation set into an equivalent composition of such inherently compatible structures.

%%
%% Properties for inherent compatibility
%%
\mnote{Inherent compatibility properties}
We consider the following two properties of a consistency relation set that lead to its inherent compatibility.
\begin{properdescription}
    \item[Composability:] The union of independent, compatible sets of relations is compatible.
    \item[Trees:] Relations fulfilling a special notion of \emph{consistency relation trees} are compatible.
\end{properdescription}
Showing that these properties imply compatibility, we know that a consistency relation set of independent subsets of consistency relation trees is inherently compatible.


\subsection{Independence of Consistency Relations}
\label{chap:compatibility:formal_approach:independence}

\mnote{Independence of relation sets}
We consider two consistency relation sets to be independent if the tuples of classes they put into relation are disjoint.

\begin{definition}[Consistency Relation Sets Independence]
    \label{def:independence}
    Let $\consistencyrelationset{CR}_{1}$ and $\consistencyrelationset{CR}_{2}$ be two sets of consistency relations. We say that:
    \parameterizeformat{
    \begin{align*}
        &
        \consistencyrelationset{CR}_{1} \andmath \consistencyrelationset{CR}_{2} \mathtextspacearound{are independent} \equivalentperdefinition \\
        & \formulaskip
        \bigcup_{\consistencyrelation{CR}{} \in \consistencyrelationset{CR}_1} \classtuple{C}{r,\consistencyrelation{CR}{}} \cap \bigcup_{\consistencyrelation{CR}{} \in \consistencyrelationset{CR}_2} \classtuple{C}{l,\consistencyrelation{CR}{}} = \emptyset \;
        #2
        \land 
        \bigcup_{\consistencyrelation{CR}{} \in \consistencyrelationset{CR}_2} \classtuple{C}{r,\consistencyrelation{CR}{}} \cap \bigcup_{\consistencyrelation{CR}{} \in \consistencyrelationset{CR}_1} \classtuple{C}{l,\consistencyrelation{CR}{}} = \emptyset
    \end{align*}
    }{}{\\ & \formulaskip}%
    We call $\consistencyrelationset{CR}$ \emph{connected} if there is no partition of $\consistencyrelationset{CR}$ into two subsets that are independent, i.e.:
    \begin{align*}
        &
        \forall \consistencyrelationset{CR}_{1}, \consistencyrelationset{CR}_{2} \subseteq \consistencyrelationset{CR} :
        \big(
            \consistencyrelationset{CR}_{1} \cap \consistencyrelationset{CR}_{2} = \emptyset \land \consistencyrelationset{CR}_{1} \cup \consistencyrelationset{CR}_{2} = \consistencyrelationset{CR}  \\
            & \formulaskip
            \Rightarrow \neg (\consistencyrelationset{CR}_{1} \andmath \consistencyrelationset{CR}_{2} \mathtextspacearound{are independent})
        \big)
    \end{align*}
\end{definition}

\mnote{More general independence notions}
In fact, this notion of independence is not the most general one that ensures preservation of compatibility.
Such a notion would only require that for each condition element in each of the consistency relation sets still a consistent model tuple can be found when both consistency relation sets are considered together.
This means that it is only necessary that for all instances of class tuples that may be required by one of the consistency relation sets to produce a consistent model tuple for each of the condition elements, there is no condition element containing these instances within the consistency relations of the other set.
Such a notion does, however, become complicated to validate and the given one already reflects a reasonable notion of independence, which is sufficient for all cases that we consider in our evaluation, which indicates general adequacy.
Thus, we stick to the given notion of independence.
% Note: The problem here are cycles within one set, thus a concatenation of relations creates elements by two of the concatenated relations, which together require further elements by another relation, i.e., CR1 -> CR2 -> CR3 and CR2+CR3 -> CR4

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/independent_relations}
    %\includegraphics[width=\columnwidth]{figures/independence_example.png}
    \caption[Two independent sets of consistency relations]{Two independent (sets of) consistency relations. Taken from~\owncite[Fig.~5]{klare2020compatibility-report}.}
    \label{fig:compatibility:independence_example}
\end{figure}

\begin{example}
\autoref{fig:compatibility:independence_example} depicts a simple example with two consistency relations $\consistencyrelation{CR}{1}$ and $\consistencyrelation{CR}{2}$, each relating instances of two disjoint classes with each other.
Since there is no overlap in the classes that are related by the consistency relations, they are considered independent according to \autoref{def:independence}.
\end{example}

An important property of independent consistency relation sets is that computing their union is compatibility-preserving, i.e., the union of compatible, independent consistency relation sets is compatible as well.

\begin{theorem}[Independent Relation Sets Compatibility] \label{theorem:independencecompatibility}
    Let $\consistencyrelationset{CR}_{1}$ and $\consistencyrelationset{CR}_{2}$ be two independent sets of consistency relations. Then it holds that:
    \begin{align*}
        \consistencyrelationset{CR}_{1} \cup \consistencyrelationset{CR}_{2} \compatiblemath \equivalent
        \consistencyrelationset{CR}_{1} \compatiblemath \land \consistencyrelationset{CR}_{2} \compatiblemath
    \end{align*}
\end{theorem}
\begin{proof}
    The forward direction is trivially given. 
    Compatibility of the union of the consistency relation sets means that for every condition element in the consistency relations of the union, a model tuple containing that condition element and being consistent to the union of the consistency relation sets can be found. Then the same model tuple is consistent to each of the consistency relation sets and, in particular, the one containing the condition element.

    The backward direction of the equivalence can be seen by construction.
    Since $\consistencyrelationset{CR}_{1}$ is compatible, per definition there is a model tuple $\modeltuple{m}$ for each condition element $\conditionelement{c}{}$ of the left condition of each consistency relation in $\consistencyrelationset{CR}_{1}$ that contains $\conditionelement{c}{}$ and that is consistent to $\consistencyrelationset{CR}_{1}$.
    Taking any such $\modeltuple{m}$, we create $\modeltuple{m'}$ by removing all elements from $\modeltuple{m}$ that are contained in any condition elements of the left conditions in every consistency relation $\consistencyrelation{CR}{} \in \consistencyrelationset{CR}_{2}$ and thus potentially require other elements to occur to be considered consistent to that consistency relation.
    The classes of these elements are thus in $\classtuple{C}{l,\consistencyrelation{CR}{}}$.
    In consequence, $\modeltuple{m'}$ does not contain any condition elements in left conditions of consistency relations in $\consistencyrelationset{CR}_{2}$ and is thus consistent to $\consistencyrelationset{CR}_{2}$ by definition. 
    Additionally, $\modeltuple{m'}$ is still consistent to $\consistencyrelationset{CR}_{1}$, because due to the independence of $\consistencyrelationset{CR}_{1}$ and $\consistencyrelationset{CR}_{2}$, there cannot be any consistency relation $\consistencyrelation{CR}{}' \in \consistencyrelationset{CR}_{1}$ that requires the existence of the removed elements.
    Otherwise, the classes of these elements would be in $\classtuple{C}{r,\consistencyrelation{CR}{}'}$.
    Per definition of independence, however, $\classtuple{C}{l,\consistencyrelation{CR}{}} \cap \classtuple{C}{r,\consistencyrelation{CR}{}'} = \emptyset$, which is a contradiction.
    In consequence, for each condition element $\conditionelement{c}{}$ of each consistency relation in $\consistencyrelationset{CR}_{1}$, a model tuple that contains $\conditionelement{c}{}$ and is consistent to $\consistencyrelationset{CR}_{1} \cup \consistencyrelationset{CR}_{2}$ exists.
    The argumentation applies to $\consistencyrelationset{CR}_{2}$ analogously, so the definition of compatibility is fulfilled for all condition elements of all consistency relations in $\consistencyrelationset{CR}_{1} \cup \consistencyrelationset{CR}_{2}$.
\end{proof}

\mnote{Constructive proof example}
The constructive proof can also be reflected exemplarily in \autoref{fig:compatibility:independence_example}: Take any tuple of models that, for example, contains a resident with an arbitrary name and is consistent to $\consistencyrelation{CR}{1}$, i.e., that also contains an employee with the same name.
If that tuple of models contains any addresses or locations, they can be removed without violating consistency to $\consistencyrelation{CR}{1}$, because addresses and locations are independently related by $\consistencyrelation{CR}{2}$.


\subsection{Consistency Relation Trees}

\mnote{Intuitive tree notion}
In addition to independence of consistency relation sets as a property that inherently implies compatibility, we aim at finding a specific structure of a connected consistency relation set that leads to inherent compatibility of the contained relations.
In consequence, if we can reduce sets of consistency relations to independent sets of such a structure in a compatibility-preserving way, we know that the relations are compatible.
Intuitively, such a structure can be expected from a kind of trees, because then there are no two concatenations of relations that can relate elements in a contradictory way.

\todoLater{Maybe we can remove symmetry and define some restriction for inverse relations. It could be useful to think about implicit relations, which are induced by another one, so that the "signatures" of forward and backward direction match.}
\begin{definition}[Consistency Relation Tree] \label{def:relationtree}
    Let $\consistencyrelationset{CR}$ be a symmetric, connected consistency relation set. 
    We say:
    \parameterizeformat{
    \begin{align*}
        &
        \consistencyrelationset{CR} \mathtextspacearound{is a consistency relation tree} \equivalentperdefinition \\
        & \formulaskip
        \forall \consistencyrelation{CR}{} = \consistencyrelation{CR}{1} \concat \dots \concat \consistencyrelation{CR}{m}  \in \transitiveclosure{\consistencyrelationset{CR}} : 
        #2
        \forall \consistencyrelation{CR}{}' = \consistencyrelation{CR}{1}' \concat \dots \concat \consistencyrelation{CR}{n}' \in \transitiveclosure{\consistencyrelationset{CR}} \setminus \consistencyrelation{CR}{} : \\
        & \formulaskip\formulaskip
        \big[
            \forall s, t \mid s \neq t: 
            \big( 
                \consistencyrelation{CR}{s} \neq \consistencyrelation{CR}{t}^T \land \consistencyrelation{CR}{s}' \neq \consistencyrelation{CR}{t}'^T 
            \big) \\
            & \formulaskip\formulaskip #1
            \Rightarrow
            \classtuple{C}{l,\consistencyrelation{CR}{}} \cap
            \classtuple{C}{l,\consistencyrelation{CR}{}'} = \emptyset
            \lor \classtuple{C}{r,\consistencyrelation{CR}{}} \cap
            \classtuple{C}{r,\consistencyrelation{CR}{}'} = \emptyset
        \big]
    \end{align*}
    }{\formulaskip}{\\ & \formulaskip}%
\end{definition}
\todoLater{We have to assume, that no element is mapped to two elements of the same class, because then it would be possible to have an incompatible network}

\mnote{Relation tree definition}
The definition of a consistency relation tree requires that there are no two sequences of consistency relations that put the same classes into relation, i.e., all pairs of classes are only put into relation by a single concatenation of consistency relations.
Since we assume a symmetric set of consistency relations, we exclude the symmetric relations from that argument.
Otherwise, there would always be two such concatenations by adding a consistency relation and its transposed relation to any other concatenation.

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/consistency_relation_tree}
    %\includegraphics[width=\columnwidth]{figures/tree_example.png}
    \caption[A consistency relation tree]{A consistency relation tree $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{1}^T, \consistencyrelation{CR}{2}, \consistencyrelation{CR}{2}^T}$. Adapted from~\owncite[Fig.~6]{klare2020compatibility-report}.}
    \label{fig:compatibility:tree_example}
\end{figure}

\begin{example}
\autoref{fig:compatibility:tree_example} depicts a rather simple consistency relation tree. 
Persons are related to residents and residents are related to employees, all having the same names or a concatenation of $\mathvariable{firstname}$ and $\mathvariable{lastname}$, respectively, by the relations $\consistencyrelation{CR}{1}$ and $\consistencyrelation{CR}{2}$, as well as their transposed relations $\consistencyrelation{CR}{1}^T$ and $\consistencyrelation{CR}{2}^T$.
There are no classes that are put into relation across different paths of consistency relations, thus the definition for a consistency relation tree is fulfilled. 
If an additional relation between persons and employees was specified, like in \autoref{fig:compatibility:three_persons_example_extended}, the tree definition would not be fulfilled.
\end{example}

\mnote{Compatibility of relation trees}
The definition also covers the more complicated case in which multiple classes are put into relation by consistency relations, but only a subset of them that is put into relation by different consistency relations.
%
%\todoDiss{Subsection with discussion about why hypertrees are not suitable here}
%
We can now prove that a consistency relation tree is always compatible.
To preserve the reading flow, we only provide a proof sketch in the following and refer for the complete proof with an auxiliary lemma to \autoref{chap:appendix:compatibility_proofs}.

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/consistency_relation_tree_construction}
    %\includegraphics[width=\columnwidth]{figures/tree_construction_example.png}
    \caption[Construction of a model tuple for a consistency relation tree]{Model tuple construction with condition element of $\consistencyrelation{CR}{1}$ containing person \enquote{Alice Avid} for a consistency relation tree of relations in \autoref{fig:compatibility:tree_example}. Adapted from~\owncite[Fig.~7]{klare2020compatibility-report}. Arrows with numbers indicate the order in which elements are created.}
    \label{fig:compatibility:tree_construction_example}
\end{figure}

\begin{theorem}[Consistency Relation Tree Compatibility] \label{theorem:treecompatibility}
    Let $\consistencyrelationset{CR}$ be a consistency relation tree. Then $\consistencyrelationset{CR}$ is compatible.
\end{theorem}

\begin{proof}[Proof Sketch]
    The complete proof is given in \autoref{chap:appendix:compatibility_proofs}.
    It is based on a proven lemma stating that starting with any of the consistency relations of a consistency relation tree, there is a sequence of the consistency relations such that there is no overlap in the classes of the conditions at the right sides of these relations and that for each relation there is no overlap in the classes of the condition at the left side with the ones at the right side of any subsequent relation in the sequence.
    More informally speaking, the relations do not induce a cycle between any of the classes in the metamodels.
    We use this insight to define a construction approach for such sequences given a set of consistency 
    relations.
    For proving compatibility, we need to show that for each condition element in a consistency relation, we find a consistent model tuple containing it.
    Thus, we start with each condition element of each relation and add a corresponding element according to that relation.
    We then inductively add further elements required by other consistency relations due to the just added elements.
    Based on the properties of consistency relation trees, we can show that this construction is always possible and terminates with a consistent model tuple.
    
    A simple example for that construction is depicted in \autoref{fig:compatibility:tree_construction_example}, which is based on the relations in the consistency relation tree in \autoref{fig:compatibility:tree_example} and more precisely explained in the complete proof.
    The example shows the construction for the condition element with the person named \enquote{Alice Avid}, consecutively selecting consistency relations for whose fulfillment further elements, namely an appropriate resident and employee, are added.
\end{proof}

%%
%% Summary: Independent trees are compatible
%%
\mnote{Compatibility of independence and trees}
Summarizing, \autoref{theorem:independencecompatibility} and \autoref{theorem:treecompatibility} show that consistency relation sets fulfilling the notion of consistency relation trees are compatible and that combining compatible independent sets of relations is compatibility-preserving.
In consequence, having a consistency relation set that consists of independent subsets that are consistency relation trees, this set of relations is inherently compatible.
An approach that evaluates whether a given set of consistency relations fulfills \autoref{def:independence} and \autoref{def:relationtree} for independence and trees can be used to prove compatibility of those relations.


\subsection{Redundancy of Consistency Relations}
\label{chap:compatibility:formal_approach:redundancy}

%%
%% Problem: Not having a compatible structure, compatibility is unclear
%%
\mnote{Not inherently compatible sets}
We have introduced specific structures of consistency relation sets that are inherently compatible.
However, actual consistency relation sets have such a structure only in specific cases.
In general, like in our initial example in \autoref{fig:compatibility:three_persons_example_extended}, multiple consistency relations may put the same classes into relation, such that the definition for consistency relation trees is not fulfilled.

%%
%% Idea: Find and virtually remove redundant relations
%%
\mnote{Compatibility preservation}
In the following, we present an approach to reduce the relations in a set of consistency relations to, in the best case, an equivalent set of independent consistency relation trees.
The essential idea is to identify relations within a set, such that whether or not they are contained in the set does not change its compatibility.
An approach that finds such relations and, for the scope of the analysis, removes them from the set until the remaining relations represent independent consistency relation trees proves compatibility of the given set of relations.
We first define the term of a \emph{compatibility-preserving} relation.

\begin{definition}[Compatibility-Preserving Consistency Relation]
    \label{def:compatibilitypreserving}
    Let $\consistencyrelationset{CR}$ be a compatible set of consistency relations and let $\consistencyrelation{CR}{}$ be a consistency relation. We say that:
    \begin{align*}
        &
        \consistencyrelation{CR}{} \compatibilitypreservingtomath \consistencyrelationset{CR} \equivalentperdefinition
        \consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}} \compatiblemath
    \end{align*}
\end{definition}

\mnote{Redundant relations}
To find such compatibility-preserving relations, we introduce the notion of \emph{redundant} relations and prove the property of being compatibility preserving.
Informally speaking, a relation is redundant if it is expressed transitively across others, i.e., if it does not restrict or relax consistency compared to a combination of other relations.
We precisely define redundancy as follows.

\begin{definition}[Redundant Consistency Relation]
\label{def:redundancy}
    Let $\consistencyrelationset{CR}$ be a set of consistency relations for a tuple of metamodels $\metamodeltuple{M}$.
    For a consistency relation $\consistencyrelation{CR}{} \in \consistencyrelationset{CR}$, we say that:
    \begin{align*}
        &
        \consistencyrelation{CR}{} \redundantinmath \consistencyrelationset{CR} \equivalentperdefinition
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})} : 
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} :\\
        & \formulaskip
        \big(
            \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}' \Rightarrow \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}
        \big)
    \end{align*}
\end{definition}

\todoLater{Add examples for redundancy! How do the elements of the redundant relation have to be related to the ones in $\consistencyrelation{CR}{}'$?}
\todoLater{Can we define an even more general notion of redundancy, not stating about the relation to a single consistency relation but the set of consistency relation, abstracting the implication to consistency to the whole set of relations?}
\mnote{Redundancy ensures equivalence}
The definition of redundancy of a consistency relation $\consistencyrelation{CR}{}$ ensures that there is another consistency relation, possibly transitively expressed across others, such that if a model is consistent to that other relation, it is also consistent to $\consistencyrelation{CR}{}$.
This means that there are no model tuples that are considered inconsistent to $\consistencyrelation{CR}{}$ but not to another relation, thus $\consistencyrelation{CR}{}$ does not restrict consistency.
Actually, the definition of redundancy implies that the set of consistency relations with and without the redundant one are equivalent according to \autoref{def:equivalence}, thus both consider the same model tuples to be consistent.

\todoLater{Explain that we do not require equality of elements in CR and CR' because, e.g., CR might only related names, whereas CR' related names and addresses, thus we only require that there are elements that are co-indicating consistency.}

\begin{lemma}[Redundant Relations Equivalence] \label{lemma:redundancyimpliesequivalence}
    Let $\consistencyrelation{CR}{} \in \consistencyrelationset{CR}$ be a redundant consistency relation in a relation set $\consistencyrelationset{CR}$.
    Then $\consistencyrelationset{CR}$ is equivalent to $\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}}$.
\end{lemma}

\begin{proof}
    As discussed in \autoref{lemma:consistencytransitiveclosure}, adding a consistency relation to a set of consistency relations can never lead to a relaxation of consistency, i.e., models becoming consistent that were not considered consistent before. This is a direct consequence of \autoref{def:consistency} for consistency, which requires models to be consistent to all consistency relations in a set to be considered consistent and thus restricts the set of consistent model tuples by adding further consistency relations.
    In consequence, it holds that:
    \begin{align*}
        \formulaskip
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \Rightarrow 
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}}
    \end{align*}
    Additionally, a direct consequence of \autoref{def:redundancy} for redundancy is that a redundant consistency relation does not restrict consistency, as it considers all models consistent that are also considered consistent to another consistency relation in the transitive closure of the consistency relation set. Thus, all models that are considered consistent to the transitive closure of $\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}}$ are also consistent to $\consistencyrelation{CR}{}$ and thus to all relations in $\consistencyrelationset{CR}$:
    \begin{align*}
        \formulaskip
        \modeltuple{m} \consistenttomath \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})} \Rightarrow 
        \modeltuple{m} \consistenttomath \consistencyrelationset{CR}
    \end{align*}
    According to \autoref{lemma:consistencytransitiveclosure}, each tuple of models that is consistent to a consistency relation set is also consistent to its transitive closure and vice versa.
    So the latter implication is also true for $\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}}$.
    Summarizing, $\consistencyrelationset{CR}$ and $\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}}$ are equivalent.
\end{proof}

\mnote{Redundancy by weaker consistency requirements}
In general, to consider a consistency relation redundant in $\consistencyrelationset{CR}$, it has to define equal or weaker requirements for consistency than one of the other relations in $\consistencyrelationset{CR}$.
Informally speaking, such weaker requirements mean that the redundant relation must have weaker conditions, i.e., it must require consistency for less objects and consider the same or more objects consistent to each of the left condition elements. 

\begin{example}
Such weaker consistency requirements are exemplified in the example in \autoref{fig:compatibility:redundancyrelationextremes}, which shows a consistency relation $\consistencyrelation{CR}{1}$ that is redundant in $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}}$.
A redundant consistency relation, such as $\consistencyrelation{CR}{1}$, must have weaker requirements in the left condition, such that it requires consistent elements to exist in less cases.
This means that it may have a larger set of classes that are matched and that there may be less condition elements for which consistency is required.
In case of $\consistencyrelation{CR}{1}$, the left condition contains both a resident and a location, whereas the left condition of $\consistencyrelation{CR}{2}$ only contains residents.
Thus, $\consistencyrelation{CR}{1}$ requires consistent elements, i.e., employees, only if a resident and a location exist, whereas $\consistencyrelation{CR}{2}$ already requires that for an existing resident.
Furthermore, the residents for which $\consistencyrelation{CR}{1}$ constrains consistency are a subset of those for which $\consistencyrelation{CR}{2}$ constrains consistency, as $\consistencyrelation{CR}{1}$ does not constrain consistency for residents with an empty $\mathvariable{name}$.
Thus, the left condition elements of $\consistencyrelation{CR}{1}$ are a subset of those of $\consistencyrelation{CR}{2}$.
In consequence, if $\consistencyrelation{CR}{1}$ constrains consistency for a resident and a location, $\consistencyrelation{CR}{2}$ constrains it for the contained resident anyway.

Additionally, a redundant consistency relation, such as $\consistencyrelation{CR}{1}$, must have weaker requirements for the  elements at the right side, such that one of the consistent right condition elements is contained anyway, because another relation already required them. 
This means that the relation may have a smaller set of classes, of whom instances are required to consider the models consistent.
In addition, there may be more condition elements at the right side considered consistent to condition elements at the left side to not restrict the elements considered consistent.
$\consistencyrelation{CR}{1}$ only requires an employee to exist for a resident, whereas $\consistencyrelation{CR}{2}$ also requires a non-empty address to exist. Additionally, $\consistencyrelation{CR}{1}$ does not restrict the employees that are considered consistent to residents in comparison $\consistencyrelation{CR}{2}$, as it also considers employees with the same $\mathvariable{name}$ as consistent, but additionally those having the $\mathvariable{name}$ of the resident in lowercase.
\end{example}

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/redundant_relation_example}
    %\includegraphics[width=\columnwidth]{figures/redundancy_relation_extremes.png}
    \caption[Redundant consistency relation]{Redundant consistency relation $\consistencyrelation{CR}{1}$ in $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}}$. Taken from~\owncite[Fig.~8]{klare2020compatibility-report}.}
    \label{fig:compatibility:redundancyrelationextremes}
\end{figure}

% \todoLater{Add proposition about redundancy properties}
% These informal insights on the properties of a redundant consistency relation can be formalized as follows.

% \begin{proposition}
%     Let $\consistencyrelationset{CR}$ be a set of consistency relations and let $\consistencyrelation{CR}{}$ be a consistency relation. Then it holds that:
%     \begin{align*}
%         \formulaskip &
%         \consistencyrelation{CR}{} \redundantinmath \consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}} \equivalent \\
%         & \formulaskip
%         \exists \consistencyrelation{CR'}{} \in \consistencyrelationset{CR} : %\\
%         %& \formulaskip
%         \classtuple{C}{l,\consistencyrelation{CR'}{}} \subseteq \classtuple{C}{l,\consistencyrelation{CR}{}} \land
%         \classtuple{C}{r,\consistencyrelation{CR}{}} \subseteq \classtuple{C}{r,\consistencyrelation{CR'}{}} \\
%         & \formulaskip
%         \land \forall \conditionelement{c}{l} \in \condition{c}{l,\consistencyrelation{CR}{}} : \exists \conditionelement{c'}{l} \in \condition{c}{l,\consistencyrelation{CR'}{}} : \big( 
%         \conditionelement{c'}{l} \subseteq \conditionelement{c}{l} \\
%         & \formulaskip\formulaskip
%         \land \forall \tupled{\conditionelement{c'}{l},\conditionelement{c'}{r}} \in \consistencyrelation{CR'}{} : \exists \tupled{\conditionelement{c}{l},\conditionelement{c}{r}} \in \consistencyrelation{CR}{} : \conditionelement{c}{r} \subseteq \conditionelement{c'}{r} \big)
%     \end{align*}
% \end{proposition}

% \begin{proof}
%     
% \end{proof}

\mnote{Redundancy not preserving compatibility}
Our goal is to have a compatibility-preserving notion of redundancy, i.e., adding a redundant relation to a compatible relation set should preserve compatibility.
Unfortunately, the up to now given intuitive redundancy definition is not compatibility-preserving.

\begin{proposition}[Redundant Relations Non-Compatibility] \label{prop:redundantnotimpliescompatible}
    Let $\consistencyrelationset{CR}$ be a compatible consistency relation set and let $\consistencyrelation{CR}{}$ be a consistency relation that is redundant in $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$.
    Then $\consistencyrelation{CR}{}$ is in general not compatibility-preserving to $\consistencyrelationset{CR}$.
\end{proposition}

\begin{proof}
We prove the proposition by providing a counterexample.
Consider the example in \autoref{fig:compatibility:redundancy_compatibility_counterexample}. 
$\consistencyrelation{CR}{2}$ relates each employee to a person with the same $\mathvariable{name}$ and $\consistencyrelation{CR}{3}$ relates each person to a resident with the same $\mathvariable{name}$ in lowercase.
The consistency relation set $\setted{\consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$ is obviously compatible, because for each employee and each person, which constitute the left condition elements of the consistency relations, a consistent model tuple containing the person and employee, respectively, can be created by adding the appropriate person or employee with the same $\mathvariable{name}$ and a resident with the $\mathvariable{name}$ in lowercase.
Furthermore, $\consistencyrelation{CR}{1}$ is redundant in $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$.
If a model is consistent to $\consistencyrelation{CR}{2}$, it is also consistent to $\consistencyrelation{CR}{1}$, since $\consistencyrelation{CR}{1}$ also requires persons with the same $\mathvariable{name}$ as an employee to be contained in a model tuple but in less cases, precisely those in which the models also contain a resident such that the employee's $\mathvariable{name}$ is the resident's $\mathvariable{name}$ written in uppercase.

$\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$ is, however, not compatible.
Intuitively, this is because $\consistencyrelation{CR}{1}$ and $\consistencyrelation{CR}{3}$ define an incompatible mapping between the names of residents and persons.
Consider a model with an employee and a resident with $\mathvariable{name} = "A"$. This is a condition element in $\condition{c}{l,\consistencyrelation{CR}{1}}$. 
Consequentially, $\consistencyrelation{CR}{1}$ requires a person with $\mathvariable{name} = "A"$ to exist. 
Then $\consistencyrelation{CR}{3}$ requires a resident with $\mathvariable{name} = "a"$ to exist.
Thus, there are two tuples of employees and residents, both with the employee named $"A"$ and one with resident $"A"$ as well as one with resident $"a"$, for which a person with $\mathvariable{name} = "A"$ is required by $\consistencyrelation{CR}{1}$.
However, $\consistencyrelation{CR}{1}$ forbids to have two residents with one having the lowercase $\mathvariable{name}$ of the other, because both are condition elements in $\consistencyrelation{CR}{1}$ requiring an appropriate person to occur in a consistent model, but both can only be mapped to the same person with the uppercase $\mathvariable{name}$.
In consequence, there is no witness structure with a unique mapping as required by \autoref{def:consistency} for consistency.
This example shows that adding a redundant consistency relation to a compatible consistency relation set does not necessarily preserve its compatibility.
\end{proof}

\begin{figure}
    \centering
    \input{figures/correctness/compatibility/redundancy_incompatible_example}
    %\includegraphics[width=\columnwidth]{figures/redundancy_compatibility_counterexample.png}
    \caption[Incompatibility with redundant consistency relation]{A consistency relation $\consistencyrelation{CR}{1}$ being redundant in  $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$ with $\setted{\consistencyrelation{CR}{2}, \consistencyrelation{CR}{3}}$ being compatible and $\setted{\consistencyrelation{CR}{1}, \consistencyrelation{CR}{2},\consistencyrelation{CR}{3}}$ being incompatible. Taken from~\owncite[Fig.~9]{klare2020compatibility-report}.}
    \label{fig:compatibility:redundancy_compatibility_counterexample}
\end{figure}

\subsection{Compatibility-Preserving Redundancy}

\mnote{Stronger redundancy definition}
In consequence of \autoref{prop:redundantnotimpliescompatible}, we need a stronger definition of redundancy, which is compatibility-preserving. 
The counterexample in \autoref{fig:compatibility:redundancy_compatibility_counterexample} shows that it is problematic if a redundant relation considers more classes in its left condition than the relation it is redundant to.
Therefore, we define a stronger notion that restricts the left class tuple.

\begin{definition}[Left-Equal Redundant Consistency Relation] \label{def:leftequalredundancy}
    Let $\consistencyrelationset{CR}$ be a set of consistency relations for a metamodel tuple $\metamodeltuple{M}$.
    For a consistency relation $\consistencyrelation{CR}{} \in \consistencyrelationset{CR}$, we say:
    \parameterizeformat{
    \begin{align*}
        &
        \consistencyrelation{CR}{} \leftequalredundantinmath \consistencyrelationset{CR} \equivalentperdefinition 
        #2
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})} : 
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} :\\
        & \formulaskip\formulaskip
        \big( 
            (
                \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}' \Rightarrow \modeltuple{m} \consistenttomath \consistencyrelation{CR}{} )
            \land \classtuple{C}{l,\consistencyrelation{CR}{}} = \classtuple{C}{l,\consistencyrelation{CR}{}'} 
        \big)
    \end{align*}
    }{}{\\ & \formulaskip }%
\end{definition}

\mnote{Left-equal redundancy}
The definition of left-equal redundancy restricts the notion of redundancy to cases in which the left condition of the redundant consistency relation $\consistencyrelation{CR}{}$ considers the same classes as the other relation in the set of consistency relations that induces consistency of a model tuple to $\consistencyrelation{CR}{}$.
As discussed before, redundancy in general allows that the left condition of a redundant consistency relation can consider a superset of those classes.

\begin{lemma}[Left-Equal Redundancy to Redundancy] \label{lemma:leftequalredundancyimpliesredundancy}
    Let $\consistencyrelation{CR}{}$ be a consistency relation that is left-equal redundant in a set of consistency relations $\consistencyrelationset{CR}$. Then $\consistencyrelation{CR}{}$ is redundant in $\consistencyrelationset{CR}$.
\end{lemma}
\begin{proof}
    Since the definition of left-equal redundancy is equal to the one for redundancy except for the additional class tuple restriction, redundancy of a left-equal redundant relation is a direct implication of the definition.
\end{proof}

\mnote{Redundancy of condition elements}
We prove an auxiliary lemma to show that left-equal redundancy preserves compatibility.
It shows that if a model tuple contains a left condition element of a left-equal redundant relation, i.e., if that relation requires the model tuple to contain corresponding elements for that object tuple, there is another relation that requires corresponding elements for that object tuple.

\begin{lemma}[Left-Equal Redundancy Containment] \label{lemma:leftequalredundancysubset}
    Let $\consistencyrelation{CR}{}$ be a consistency relation that is left-equal redundant in a consistency relation set $\consistencyrelationset{CR}$ for a metamodel tuple $\metamodeltuple{M}$. Then it holds that: 
    \begin{align*}
        &
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})} : 
        \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : 
        \exists \conditionelement{c}{l}' \in \condition{c}{l,\consistencyrelation{CR}{}'} : \\
        & \formulaskip
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : 
        \big(
            \modeltuple{m} \containsmath \conditionelement{c}{l}' \Rightarrow 
            \modeltuple{m} \containsmath \conditionelement{c}{l}
        \big)
    \end{align*}
\end{lemma}

\begin{proof}
    Due to left-equal redundancy of $\consistencyrelation{CR}{}$ in $\consistencyrelationset{CR}$, we know per definition:
    \begin{align*}
        &
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})} :
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \\
        & \formulaskip
        \big(
            (
                \modeltuple{m} \consistenttomath \consistencyrelation{CR}{}' \Rightarrow \modeltuple{m} \consistenttomath \consistencyrelation{CR}{} 
            )
            \land 
            \classtuple{C}{l,\consistencyrelation{CR}{}} = \classtuple{C}{l,\consistencyrelation{CR}{}'} 
        \big)
    \end{align*}
    This implies that:
    \begin{align*}
        &
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})} :
        \forall \conditionelement{c}{l} \in \condition{c}{l,\consistencyrelation{CR}{}} :
        \conditionelement{c}{l} \in \condition{c}{l,\consistencyrelation{CR}{}'}
    \end{align*}
    Because if there was a $\conditionelement{c}{l} \in \condition{c}{l,\consistencyrelation{CR}{}}$ so that $\conditionelement{c}{l} \not\in \condition{c}{l,\consistencyrelation{CR}{}'}$, then the model tuple $\modeltuple{m}$ only consisting of $\conditionelement{c}{l}$ would be consistent to $\consistencyrelation{CR}{}'$.
    In contrast, there is at least one $\tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{}$, so that $\modeltuple{m}$ needs to contain $\conditionelement{c}{r}$ to be consistent to $\consistencyrelation{CR}{}$, which is not given by construction.
    This shows that $\condition{c}{l,\consistencyrelation{CR}{}'}$ contains all elements in $\condition{c}{l,\consistencyrelation{CR}{}}$, so there is always at least one element in $\condition{c}{l,\consistencyrelation{CR}{}'}$ that a model tuple contains if it contains an element in $\condition{c}{l,\consistencyrelation{CR}{}}$, which proves the lemma.
\end{proof}

%\todoLater{The following lemma derived the property of left-equal redundancy from redundancy, which was not correct. Maybe we can find a more general notion of redundancy from which we can derive the contains implication, reviving this lemma gain.}
% \begin{lemma} \label{lemma:redundancysubset}
%     Let $\consistencyrelation{CR}{}$ be a consistency relation that is redundant in a set of consistency relations $\consistencyrelationset{CR}$ for a set of metamodels $\metamodelset{M}$. Thus there exists a consistency relation $\consistencyrelation{CR'}{} \in \transitiveclosure{(\consistencyrelationset{CR} \setminus \setted{\consistencyrelation{CR}{}})}$ with:
%     \begin{align*}
%         \formulaskip & 
%         \forall \modelset{m} \in \metamodelinstances{\metamodelset{M}} : \modelset{m} \consistenttomath \consistencyrelation{CR'}{} \Rightarrow \modelset{m} \consistenttomath \consistencyrelation{CR}{}
%     \end{align*}
%     Then it holds that:
%     \begin{align*}
%         \formulaskip &
%         \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \exists \conditionelement{c'}{l} \in \condition{c}{l, \consistencyrelation{CR'}{}} : 
%         \forall{m} \in \metamodelinstances{\metamodelset{M}} : \\
%         & \formulaskip
%         \modelset{m} \containsmath \condition{c'}{l} \Rightarrow \modelset{m} \containsmath \condition{c}{l} %\\
%         % &
%         % \land \forall \conditionelement{c}{r} \in \condition{c}{r, \consistencyrelation{CR}{}} : \exists \conditionelement{c'}{r} \in \condition{c}{r, \consistencyrelation{CR'}{}} : 
%         % \forall{m} \in \metamodelinstances{\metamodelset{M}} : \\
%         % & \formulaskip
%         % \modelset{m} \containsmath \condition{c'}{r} \Rightarrow \modelset{m} \containsmath \condition{c}{r}
%         %\conditionelement{c}{l} \subseteq \conditionelement{c'}{l}
%     \end{align*}
% \end{lemma}

% \begin{proof}
%     % Due to symmetry of the statement for $\conditionelement{c}{l}$ and $\conditionelement{c}{r}$, the proof is also symmetric, which is why we restrict the proof to $\conditionelement{c}{l}$. 
%     We prove that
%     \begin{align*}
%         \formulaskip &
%         \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \exists \conditionelement{c'}{l} \in \condition{c}{l, \consistencyrelation{CR'}{}} : 
%         %\forall{m} \in \metamodelinstances{\metamodelset{M}} : \\
%         %& \formulaskip
%         \conditionelement{c}{l} \subseteq \conditionelement{c'}{l}
%     \end{align*}
%     which directly implies the statement according to \autoref{def:conditionelementcontainment} for the containment of condition elements.
%     Let us assume the contrary, such that:
%     \begin{align*}
%         \formulaskip &
%         \exists \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \forall \conditionelement{c'}{l} \in \condition{c}{l, \consistencyrelation{CR'}{}} : \conditionelement{c}{l} \not\subseteq \conditionelement{c'}{l}
%     \end{align*}
%     Consider that $\conditionelement{c}{l} = \tupled{\object{o}{1}, \dots \object{o}{n}} \in \condition{c}{l, \consistencyrelation{CR}{}}$.
%     Now select a model set $\modelset{m} \in \metamodelinstances{\metamodelset{M}}$, which only contains objects $\object{o'}{1}, \dots, \object{o'}{n}$, such that $\forall i \in \setted{1, \dots, n} : \object{o}{i} \subseteq \object{o'}{i}$. In other words, we select a minimal model set that contains $\conditionelement{c}{l}$.
%     Per definition of $\consistencyrelation{CR}{}$, there must exist at least one consistency relation pair $\tupled{\conditionelement{c}{l}, \conditionelement{c}{r}} \in \consistencyrelation{CR}{}$, in which $\conditionelement{c}{l}$ occurs.
%     Since $\modelset{m}$ does not contain any $\conditionelement{c}{r}$, $\neg (\modelset{m} \consistenttomath \consistencyrelation{CR}{})$ per definition.
%     Since $\forall \conditionelement{c'}{l} \in \condition{c}{l, \consistencyrelation{CR'}{}} : \conditionelement{c}{l} \not\subseteq \conditionelement{c'}{l}$, there is no such $\conditionelement{c'}{l}$ with $\modelset{m} \containsmath \conditionelement{c'}{l}$.
%     \dots
%     \todoHeiko{Correct and finish proof}
% \end{proof}

\begin{theorem}[Left-Equal Redundancy Compatibility] \label{theorem:redundancycompatibility}
    Let $\consistencyrelationset{CR}$ be a compatible set of consistency relations and let $\consistencyrelation{CR}{}$ be left-equal redundant in $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$. Then $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$ is compatible. 
\end{theorem}

\begin{proof}
    Left-equal redundancy of $\consistencyrelation{CR}{}$ in $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$ implies general redundancy according to \autoref{def:redundancy}. In consequence, $\consistencyrelationset{CR}$ and $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$ are equivalent, as shown in \autoref{lemma:redundancyimpliesequivalence}.
    Because of this equivalence, we know that:
    \begin{equation} \label{eq:redundancyconsistency}
        \forall \modeltuple{m} \in \metamodeltupleinstanceset{M}: 
        \big(
            \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \equivalent 
            \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}} 
        \big)
    \end{equation}
    It follows from \autoref{def:compatibility} for compatibility and \autoref{eq:redundancyconsistency}:
    \begin{align} \label{eq:redundancycompatibleexisting}
        & \nonumber
        \forall \consistencyrelation{CR}{}' \in \consistencyrelationset{CR} : \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}'}
        : \exists \modeltuple{m} \in \metamodeltupleinstanceset{M} : \\
        & \formulaskip
        \big(
            \modeltuple{m} \containsmath \conditionelement{c}{l} \land \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}} 
        \big)
    \end{align}
    This already shows that for $\consistencyrelationset{CR}$ the compatibility definition is fulfilled, so we need to prove that the compatibility definition is fulfilled for $\consistencyrelation{CR}{}$ as well.
    Due to compatibility of $\consistencyrelationset{CR}$ and \autoref{lemma:compatibilitytransitiveclosure} showing equality of compatibility for a consistency relation set and its transitive closure, we know that:
    \parameterizeformat{
    \begin{align} \label{eq:compatibilityclosure}
        & 
        \forall \consistencyrelation{CR}{}' \in \transitiveclosure{\consistencyrelationset{CR}} : \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}'} : \exists \modeltuple{m} \in \metamodeltupleinstanceset{M} : 
        #2
        \big(
            \modeltuple{m} \containsmath \conditionelement{c}{l} \land \modeltuple{m} \consistenttomath \transitiveclosure{\consistencyrelationset{CR}} 
        \big)
    \end{align}
    }{}{\nonumber \\ & \formulaskip}%
    Due to left-equal redundancy of $\consistencyrelation{CR}{}$ in $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$, we have shown in \autoref{lemma:leftequalredundancysubset} that the following is true:
    \begin{align} \label{eq:redundancycontainment}
        & \nonumber 
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{\consistencyrelationset{CR}} : \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \exists \conditionelement{c}{l}' \in \condition{c}{l,\consistencyrelation{CR}{}'} : \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : \\
        & \formulaskip
        \big(
            \modeltuple{m} \containsmath \conditionelement{c}{l}' \Rightarrow \modeltuple{m} \containsmath \conditionelement{c}{l} 
        \big)
    \end{align}
    The combination of \autoref{eq:compatibilityclosure} and \autoref{eq:redundancycontainment} gives:
    \begin{align*}
        & \nonumber 
        \exists \consistencyrelation{CR}{}' \in \transitiveclosure{\consistencyrelationset{CR}} : \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \exists \conditionelement{c}{l}' \in \condition{c}{l,\consistencyrelation{CR}{}'} : \\
        & \formulaskip
        \big[
            \forall \modeltuple{m} \in \metamodeltupleinstanceset{M} : 
            \big(
                \modeltuple{m} \containsmath \conditionelement{c}{l}' \Rightarrow \modeltuple{m} \containsmath \conditionelement{c}{l} 
            \big) \\
            & \formulaskip
            \land \exists \modeltuple{m} \in \metamodeltupleinstanceset{M} :
            \big(
                \modeltuple{m} \containsmath \conditionelement{c}{l}' \land \modeltuple{m} \consistenttomath \transitiveclosure{\consistencyrelationset{CR}} 
            \big)
        \big]
    \end{align*}
    A simplification by combining the two last lines of that statement leads to:
    \begin{align*}
        & \nonumber 
        \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \exists \modeltuple{m} \in \metamodeltupleinstanceset{M} : 
        \big(
            \modeltuple{m} \containsmath \conditionelement{c}{l} \land \modeltuple{m} \consistenttomath \transitiveclosure{\consistencyrelationset{CR}} 
        \big)
    \end{align*}
    Due to \autoref{eq:redundancyconsistency} and \autoref{lemma:consistencytransitiveclosure}, which shows equality of consistency for a consistency relation set and its transitive closure, this is equivalent to:
    \parameterizeformat{
    \begin{align} \label{eq:redundancycompatiblenew}
        & 
        \forall \conditionelement{c}{l} \in \condition{c}{l, \consistencyrelation{CR}{}} : \exists \modeltuple{m} \in \metamodeltupleinstanceset{M} :
        #2
        \big(
            \modeltuple{m} \containsmath \conditionelement{c}{l} \land \modeltuple{m} \consistenttomath \consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}
        \big)
    \end{align}
    }{}{\nonumber \\ & \formulaskip}%
    The combination of \autoref{eq:redundancycompatibleexisting} and \autoref{eq:redundancycompatiblenew} shows that $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{}}$ fulfills \autoref{def:compatibility} for compatibility.
\end{proof}

\begin{corollary}[Transitive Redundancy Compatibility] \label{corollary:transitiveredundancycompatibility}
    Let $\consistencyrelationset{CR}$ be a compatible set of consistency relations and let $\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{k}$ be consistency relations with:
    \begin{align*}
        &
        \forall i \in \setted{1, \dots, k} : \consistencyrelation{CR}{i} \leftequalredundantinmath \consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{i}}
    \end{align*}
    Then $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{k}}$ is compatible.
\end{corollary}

\begin{proof}
    $\consistencyrelationset{CR}$ is compatible. Sequentially adding $\consistencyrelation{CR}{i}$ to $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{i-1}}$ inductively ensures compatibility of $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{i}}$ due to \autoref{theorem:redundancycompatibility}, which shows compatibility of $\consistencyrelationset{CR} \cup \setted{\consistencyrelation{CR}{1}, \dots, \consistencyrelation{CR}{i-1}}$.
\end{proof}

\mnote{Proving compatibility}
With \autoref{corollary:transitiveredundancycompatibility}, we have shown that if we have a set of consistency relations $\consistencyrelationset{CR}$ and are able to find a sequence of redundant consistency relations $\consistencyrelation{CR}{1}, \dots, {\consistencyrelation{CR}{k}}$ according to \autoref{corollary:transitiveredundancycompatibility} such that we know that $\consistencyrelationset{CR} \setminus \setted{ \consistencyrelation{CR}{1}, \dots, {\consistencyrelation{CR}{k}}}$ is compatible, then it is proven that $\consistencyrelationset{CR}$ is compatible.



\subsection{An Algorithm to Prove Compatibility} % Trees, Independence and Redundancy for Witnessing Compatibility
\label{chap:compatibility:formal_approach:algorithm}

\mnote{Insights for compatibility}
In the previous subsections, we have proven the following three central insights.
\begin{longenumerate}
    \item Compatibility is composable: If independent sets of consistency relations are compatible, their union is compatible as well (\autoref{theorem:independencecompatibility}).
    \item Consistency relation trees are compatible: If there are no two concatenations of consistency relations in a consistency relation set that relate the same classes, that set is compatible (\autoref{theorem:treecompatibility}).
    \item Left-equal redundancy is compatibility-preserving: Adding a left-equal redundant consistency relation to a compatible consistency relation set, the union of that set with the redundant relation is compatible (\autoref{corollary:transitiveredundancycompatibility}).
\end{longenumerate}

\mnote{Iterative process}
These insights enable us to define a formal approach for proving compatibility of a set of consistency relations.
Given a set of relations for which compatibility shall be proven, we search for consistency relations in that set that are left-equal redundant to it.
If iteratively removing such redundant relations from the set leads to a set of independent consistency relation trees, it is proven that the initial set of consistency relations is compatible.

\begin{algorithm}
    \input{algorithms/correctness/compatibility/formal_compatibility_algorithm.tex}
    \caption[Proof for compatibility of consistency relations]{Proof for compatibility of consistency relations.}
    \label{algo:compatibility:formal_proof}
\end{algorithm}

\mnote{Compatibility validation algorithm}
\autoref{algo:compatibility:formal_proof} realizes this procedure.
It executes the described steps and assumes appropriate procedures to find out whether the given set of relations is a relation tree, whether it consists of independent subsets, and whether it contains a redundant relation.
It is easy to see that this algorithm is correct, as is implements the proven findings summarized before.
This does, however, not mean that implementing the sub-procedures is trivial.
We provide a practical approach to realize them in the subsequent section.

\begin{theorem}[Compatibility Algorithm Correctness]
    \label{theorem:compatibilityalgorithmcorrectness}
    \autoref{algo:compatibility:formal_proof} is correct, i.e., it only returns \textsc{true} if the given consistency relation set $\consistencyrelationset{CR}$ is compatible.
\end{theorem}

\begin{proof}
    We make a case distinction for the returning statements of the algorithm.
    \begin{longenumerate}
        \item If the consistency relation set is a tree, the algorithm directly returns \textsc{true} (Lines~\ref{algo:compatibility:formal_proof:line:starttree}--\ref{algo:compatibility:formal_proof:line:endtree}), which is correct according to \autoref{theorem:treecompatibility}.
        \item If the consistency relation set can be split into independent sets, the algorithm returns \textsc{true} when both independent sets are identified as compatible by recursive application of the algorithm (Lines~\ref{algo:compatibility:formal_proof:line:startindependence}--\ref{algo:compatibility:formal_proof:line:endindependence}), which is correct according to \autoref{theorem:independencecompatibility}.
        \item If the consistency relation set contains a redundant relation, the algorithm returns \textsc{true} when the set without the redundant relation is identified as compatible by recursive application of the algorithm (Lines~\ref{algo:compatibility:formal_proof:line:startredundancy}--\ref{algo:compatibility:formal_proof:line:endredundancy}), which is correct according to \autoref{corollary:transitiveredundancycompatibility}.
        \item In all other cases, the algorithm returns \textsc{false} (\autoref{algo:compatibility:formal_proof:line:failure}).
        \qedhere
    \end{longenumerate}
\end{proof}

\mnote{Algorithm conservativeness}
The algorithm, however, also operates \emph{conservatively}.
If the approach finds redundant relations, such that a consistency relation set can be reduced to a set of independent consistency relation trees, the set is proven compatible, as we have shown by proof.
If the approach is not able to find such relations, the set may still be compatible, but the approach is not able to prove that.
Conceptually, this can be due to the fact that there are compatibility-preserving relations that do not fulfill the definition of left-equal redundancy, or because our independence definition is too restrictive.
Furthermore, an actual technique to identify left-equal redundant relations may not be able to find all of them automatically for undecidability reasons, as we see later at the practical approach.

\begin{theorem}[Compatibility Algorithm Conservativeness]
    \autoref{algo:compatibility:formal_proof} operates conservatively, which means that it is correct but the given consistency relation set $\consistencyrelationset{CR}$ is not necessarily incompatible if it returns \textsc{false}.
\end{theorem}

\begin{proof}
    We know that the algorithm is correct due to \autoref{theorem:compatibilityalgorithmcorrectness}.
    Additionally, it is easy to find examples for which the algorithm cannot prove compatibility, although the relations are compatible.
    Let us assume a consistency relation $\consistencyrelation{CR}{}$. 
    Then we construct a consistency relation $\consistencyrelation{CR}{}'$ by taking $\consistencyrelation{CR}{}$, adding an arbitrary class $C$ to the left-hand side class tuple of the relation, and constructing the relation elements by taking the ones in $\consistencyrelation{CR}{}$, each complemented by all instances of $C$.
    Then $\setted{\consistencyrelation{CR}{},\consistencyrelation{CR}{}'}$ is, by construction, compatible, but the two relations are neither independent or a consistency relation tree, as they relate the same classes, nor are they redundant according to \autoref{def:leftequalredundancy}, because the left-side class tuples are not equal.
\end{proof}

\mnote{Relevance of conservativeness}
The example given in the proof for conservativeness shows that the strictness of our definition for left-equal redundancy (\autoref{def:leftequalredundancy}) can prevent the algorithm from proving compatibility.
We will, however, see in the evaluation in \autoref{chap:correctness_evaluation:compatibility} that it is still sufficient in realistic cases, although such special cases as discussed in the proof are not supported.

\mnote{Approach operationalization}
In the following, we discuss how such an approach can be operationalized.
First, we discuss at the example of \qvtr how transformations can be represented in a graph-based structure, which conforms to our formal notion and allows to check whether the structure is an independent set of consistency relation trees.
Second, we present an approach for finding consistency relations that are left-equal redundant by means of a \gls{SMT} solver applied to the constraints defined in \qvtr transformations.


\todoLater{We partly did that by the expressiveness section for model-level and fine grained relations: Construction of valid models. Valid models may restrict the usable instances of a metamodel. Discuss impact on definitions and theorems and especially the constructive discussions within the proofs. Especially consider the meaning of references in models.}
