\section{Knowledge Levels in Transformation Specifications}
%\todo{Process and levels from ICMT to identify how levels depend on each other (restructure according to relations (compatibility), individual transformations and networks), and derive which errors occur and how they depend on each other}

\mnote{Levels by available knowledge}
The process of specifying a transformation network can be considered at different conceptual levels depending on the knowledge a developer must have to ensure correctness at that level.
For example, at the lowest level a developer may only know that a transformation shall be used within a network without knowing the actual network, which only allows to avoid specific errors, whereas further errors are relevant and need to be considered when having knowledge about the other transformations to combine it with.
In addition, depending on the level of abstraction that a specification formalism, such as a transformation language, provides, the developer must only deal with some of these levels as the language abstracts from the others, which determines the resulting challenges a developer has to deal with.
%In \autoref{chap:correctness:notions_consistency:monolithic_modular}, we have introduced the separation between a modular and monolithic notion of consistency.
%Although we focus on a modular notion of consistency in this thesis, we will see how a monolithic notion relates to the error potentials of modular specifications.
In consequence, these levels are supposed to mean that specific kinds of mistakes can be made at each of them and that a formalism may ensure correctness with respect to one of those levels and the ones below, whereas the transformation developer is still responsible for avoiding mistakes at the levels above.
%even if abstraction is lifted to that appropriate level, thus correctness as the lower levels is ensures, specific potential mistakes can still be made.

\begin{propertable}
    \rowcolors{1}{\firstlinecolor}{\secondlinecolor}
    \begin{tabular}{C{2.4em+0.05\difftoafiveimage}L{3.9em+0.83\difftoafiveimage}L{10.8em+0.1\difftoafiveimage}L{11.3em+0.02\difftoafiveimage}}
        \toprule
        \textbf{Level} & \textbf{Name} & \textbf{Correctness} & \textbf{Knowledge} \\
        \midrule
        1 & \LevelTransformation & Synchronizing transformations & Individual transformation \\
        2 & \LevelNetworkRelation & Compatible consistency relations & Consistency relations of complete network \\
        3 & \LevelNetworkRule & Interoperable consistency preservation rules & Transformations of complete network \\
        \bottomrule
    \end{tabular}
    \caption[Knowledge levels in transformation network specification]{Distinguished levels in the transformation network specification process with their correctness criteria and required knowledge.}
    \label{tab:errors:levels}
\end{propertable}

\mnote{Three distinguished levels}
We distinguish three such levels, which we summarize in \autoref{tab:errors:levels} together with their properties and discuss in the following.
%They are supposed to mean that even if abstraction is lifted to that appropriate level, thus correctness as the lower levels is ensures, specific potential mistakes can still be made.
%At the \emph{global level}, we consider the (multiary) relation and/or transformation between all involved models.
%At the \emph{modularization level}, we consider the combination of modular, binary relations and synchronizing transformations between the involved models.
%At the \emph{transformation level}, we consider the synchronization of transformation between two models.
%
At the \emph{\leveltransformation level}, we consider the specific properties, especially synchronization, of a single transformation to be used in a, more precisely any, transformation network.
At the \emph{\levelnetworkrelation level}, we consider the interplay of the binary consistency relations of a concrete set of transformations.
At the \emph{\levelnetworkrule level}, we consider the interplay of the consistency preservation rules of a concrete set of transformations.
These levels depend on each other, because, for example, consistency preservation rules cannot properly work together if each on its own is not at least synchronizing and thus correct at the \leveltransformation level.
Nevertheless, a transformation can be correct at the \leveltransformation level without being correct at the relation and \levelnetworkrule level.

\mnote{Required knowledge per level}
These levels especially differ in what knowledge they require to be able to deal with and even avoid potential errors.
For the \leveltransformation level, it is sufficient to know that a transformation may be used in a transformation network without knowing the actual network.
For the \levelnetworkrelation level, at least the relations of the other transformations in the network must be known.
Finally, for the \levelnetworkrule level, the transformations of the complete network must be known.
This influences how far errors at the different levels can be avoided, first, because of the required knowledge to do so and, second, because of the possibility to ensure correctness at all.
% Remark: correctness for rules -> decidability

%\todoHeiko{Annahme: Immer nur Änderung an einem Modell (keine Synchronisation)}

%The process of specifying consistency between $n>2$ types of models using a network of \acp{BX} can be separated into different conceptual levels.
%We distinguish three such levels:
%At the \emph{global level}, we describe the (multiary) relations between all involved model types.
%At the \emph{modularization level}, we split these global relations into modular, binary relations.
%Finally, at the \emph{operationalization level}, we define preservation of consistency %after changes 
%according to the modular relations.

%All of these levels have to be considered during the consistency specification process.
%A developer specifies consistency on one of these levels, depending on the abstraction level that the transformation language provides, and the transformation engine finally derives an operationalization from that.
%Although a developer does not specify consistency on multiple levels, he or she has to think about the levels on and above the one consistency is specified on.
%For example, to define an operationalization, the developer must be aware of the modular consistency relations.
%If a developer only specifies the modular consistency relations, the transformations engine has to derive an appropriate operationalization.
%In the end, to preserve consistency, an operationalization has to be derived from a specification on any of those levels.
%The benefit of clearly separating these levels is that they have different potentials for mistakes, faults, and resulting failures. 
%Consequently, avoiding a specific kind of mistake, which is related to one of the identified levels, completely prevents a specific category of failures.
%We exemplify these levels in \autoref{fig:properties:levels_overview} and explain them in more detail in the following.

%\todoHeiko{Give an example for mistakes here! Maybe one example for every level as well?}

\subsection{Knowledge-Dependent Specification Levels}
%\label{chap:properties:levels}

\mnote{Levels for modular consistency notion}
In the following, we introduce the three mentioned levels more precisely.
They represent a revised version of the three levels we have presented in previous work~\owncite{klare2019icmt}.
In that work, we have discussed the \emph{global} level, which considers the global knowledge in terms of the overall, multiary relation between all involved models.
We have, however, discussed different correctness notions in \autoref{chap:correctness:notions_correctness} and argued why we do not consider a \emph{monolithic} notion of consistency, which conforms to the \emph{global} specification level, as we do not assume this global knowledge to be represented explicitly, such that it would make sense to explicitly consider correctness according to it.

%\begin{figure}
    %\centering
%    \includegraphics[angle=-90, width=\textwidth]{figures/levels_overview.pdf}
%    \input{figures/properties/levels_overview.tex}
    %\caption{Examples for Abstraction Levels in the Consistency Specification Process}
    %\label{fig:properties:levels_overview}
%\end{figure}

%\todoHeiko{Definieren was Correctness auf jedem der Levels heißt. System: Richtig bzgl. den tatsächlichen Konsistenzbeziehungen, Modularization: Richtig bzgl. der globalen Spezifikation, Operationalization: Korrekte Ergebnisse nach Änderungen bzgl. der modularen Spezifikationen}

\begin{properdescription}
%\mnote{Knowledge about single transformation}
\item[Level 1 (\emph{\LevelTransformation}):] \mnote{Knowledge about single transformation}
At the first level, we only consider the knowledge that a transformation shall be used within a transformation network.
According to our formalism presented in \autoref{chap:correctness:formalization}, this means that the transformation needs to be \emph{synchronizing}.
We have discussed in \autoref{chap:synchronization} how synchronization can be achieved with ordinary transformation languages.
Correctness at this level is given by the fulfillment of the synchronization property for a transformation.

%\mnote{Knowledge about consistency relations of network}
\item[Level 2 (\emph{\LevelNetworkRelation}):] \mnote{Knowledge about consistency relations of network}
At the second level, we consider the knowledge about the actual network in which the transformations shall be used, but restricted to their relations.
In consequence, it would be possible that the relations between all models are known, e.g., because there is a common understanding of the relations, which may also be documented.
We have discussed in \autoref{chap:compatibility} that \emph{compatibility} is a relevant property of the consistency relations in a transformation network to ensure that the transformations are able to find consistent models after changes.
Correctness at this level is thus given by compatibility of the consistency relations.

%\mnote{Knowledge about complete transformations of network}
\item[Level 3 (\emph{\LevelNetworkRule}):] \mnote{Knowledge about complete transformations of network}
At the third level, we consider the knowledge about the complete transformations of an actual network, thus especially also the consistency preservation rules that preserve consistency.
We have discussed in \autoref{chap:orchestration} the problem of orchestrating these rules and also discussed several issues that may prevent an algorithm from finding a consistent orchestration, such as the selection of an option from different possibilities provided by a consistency relation to restore consistency.

\end{properdescription}

% At the most abstract level, we consider the knowledge about all actual consistency relations between the involved model types.
% This knowledge can be represented by an multiary relation between all model types, containing all tuples of consistent instances of the $n$ model types according to a consistency specification (\autoref{def:consistency_specification}). 
% We refer to this as a \emph{global} consistency specification.

% \subsubsection*{Level 2 (\emph{Modularization}):} 
% At the second level, the global knowledge of the first level is separated into partial, binary consistency relations that, in combination, represent the overall knowledge about consistency in the system.
% These relations should not contain any contradictions.
% We do not necessarily need to describe relations between all pairs of model types, since some may not share information that may become inconsistent, or some may be represented transitively across other relations.
% %This does also comprise the selection of a network structure that is capable of representing the full system knowledge.
% %Mathematically speaking, on this level the knowledge on this level 
% This knowledge 
% can be represented by up to $\frac{n*(n-1)}{2}$ binary relations, each containing all pairs of instances of two of the model types that are consistent.
% This corresponds to a set of binary consistency specifications according to \autoref{def:consistency_specification}.
% We refer to these as \emph{modular} consistency specifications.\\[-1em]

% \noindent\emph{Remark:} 
% %\begin{remark*}
% Although in theory not all kinds of multiary relations can be separated into binary relations~\cite{stevens2020BidirectionalTransformationLarge-SoSym}, we assume that all consistency relations considered in an automated consistency preservation process can be expressed by binary relations.
% We shortly discussed why this is a reasonable assumption in \autoref{chap:properties:terminology}.
%As stated by \textcite{stevens2020BidirectionalTransformationLarge-SoSym}, this is a reasonable assumption, because it is hard enough for people to think about and specify binary relations.
%Additionally, the separation into binary relations is the extreme case, which we explicitly consider here, nevertheless our finding also apply to a modularization into consistency specifications of higher arity.
%\end{remark*}

%\todoHeiko{Definieren, wie man mit mehrere CPS Konsistenz erreicht -> Zum Ziel der Arbeit kommen, dass man modulare CPS bel. Veschalten kann, um zu Konsistenz zu kommen.}  
% \subsubsection*{Level 3 (\emph{Operationalization}):}
% At this level, the consistency preservation is operationalized in terms of binary consistency preservation specifications according to \autoref{def:consistency_preservation_specification}. % for modular consistency specifications %after \autoref{def:consistency_specification} 
% %on the second level.
% %This requires the definition of update operations that restore consistency after user changes.
% As discussed in \autoref{chap:properties:terminology}, we consider a set of consistency preservation specifications that can be composed to restore consistency.
% In contrast to a single \ac{BX}, an operationalization in %arbitrary
% networks of \acp{BX} has to deal with confluence of information.
% This can lead to problems, such as overwrites or duplications of information, whenever a change can be propagated across at least two paths in the network of \acp{BX} to the same model.
% %It especially requires an identification of matching elements in different consistency preservation specifications to avoid duplicate element creations or insertions. 
% %For example, if an element is propagated from a model of $\mathcal{M}_1$ to a model of $\mathcal{M}_2$ and from this model to one of $\mathcal{M}_3$, then an additional consistency preservation specification from $\mathcal{M}_1$ to $\mathcal{M}_3$ must consider the already existing element instead of creating an additional or overwriting the existing one.
% We have seen an example, in which such multiple transformation paths cannot be avoided, in \autoref{fig:properties:motivational_example}.
%We refer to these as modular consistency preservation specifications.

%\todoHeiko{Maybe call this recombination of modularized knowledge? Makes fokus more on operationalization/ consistency preservation, as that is where the problems occur}
%Mathematically speaking, on this level consistency preservation specifications according to \autoref{def:consistency_preservation_specification} are defined, which adhere to the consistency specifications according to \autoref{def:consistency_specification} on the second level.
%Mathematically speaking, this is the step from a consistency specification of relations to a consistency preservation specification of restore functions.
%We refer to these as modular consistency preservation specifications.
%OLD: partial knowledge (adding information to make partial specifications combinable without knowing about the others)


\subsection{Abstraction to Specification Levels}

\mnote{Inherent correctness by formalism}
All three levels are relevant during the specification process of a transformation network, and potential mistakes that can be made at each of them need to be avoided.
As mentioned before, a specification formalism, usually a transformation language, provides a specific level of abstraction associated with one of the conceptual levels introduced above, which relieves the developer from dealing with potential problems of the lower levels.
He or she must, however, still ensure correctness with respect to all higher levels.

\mnote{Inherent correctness at \leveltransformation level}
At the lowest level, a transformation language does not ensure correctness regarding any of the levels.
For example, an imperative, unidirectional transformation language requires the developer to ensure synchronization of transformations at the \leveltransformation level, compatibility of the relations at the \levelnetworkrelation level, as well as interoperability of the consistency preservation rules at the \levelnetworkrule level.
Some declarative, bidirectional transformation languages already relieve the developer from specifying consistency preservation rules and lift the abstraction to consistency relations, from which consistency preservation rules are automatically derived.
Some languages even relieve the developer from manually ensuring synchronization, for example, by using keys for matching existing elements in \gls{QVTR}.
In this case, the transformation engine ensures correctness at the \leveltransformation level, but the developer still has to ensure it for the other levels.
Then, the developer only needs to deal with problems at the higher levels.
Integrating an analysis for compatibility, such as the one proposed in \autoref{chap:compatibility}, into \gls{QVTR} could thus also abstract from the \levelnetworkrelation level.

\mnote{Formalisms for higher-level correctness}
Languages that ensure correctness at higher levels than the \leveltransformation level are currently unusual.
This requires either the specification of multidirectional transformations, i.e., a less modular or even monolithic notion of consistency (see \autoref{chap:correctness:notions_correctness}), or at least additional analysis functionality integrated into the languages to, for example, ensure compatibility and thus correctness at the \levelnetworkrule level.
Multidirectional \gls{QVTR}~\cite{macedo2014FrameworkMultiDirectional-BX} or extensions of \glspl{TGG} to multiple models~\cite{trollmann2015TransformationTGGtoMultiModel-ICMT,trollmann2016SynchronizationTGGtoMultiModel-ICMT} or to \glspl{MGG}~\cite{koenigs2006MGGs-SoSym} provide means to define rules between multiple models, from which then consistency preservation rules between two models are derived, thus abstracting from the problems of ensuring rule compatibility and interoperability of consistency  preservation rules.
The \commonalities language~\owncite{gleitze2017a}, which we present in detail in \autoref{chap:improvement}, lifts the abstraction such that the \levelnetworkrelation and \levelnetworkrule levels do not have to be considered by the transformation developer.
This is, however, achieved by a specific network topology induced by that language, which avoids several of the problems that we discussed for networks of arbitrary topologies.

\mnote{Dependencies between levels}
Correctness at the higher conceptual levels always requires correctness at the lower levels.
Especially the interoperability of transformations at the \levelnetworkrule level requires the transformations to be synchronizing, i.e., correct at the \leveltransformation level, and the relations to be compatible, i.e., to be correct at the \levelnetworkrelation level.
In fact, compatibility of the relations does not require the transformations to be synchronizing, i.e., theoretically the \levelnetworkrelation level does not require correctness at the \leveltransformation level.
It does, however, not make sense from a knowledge perspective to ensure compatibility of relations when the transformations that ensure them are not even synchronizing, because synchronization of a transformation can already be ensured independent from the other transformations to combine it with, whereas this knowledge is required for ensuring compatibility.

% A transformation language finally derives a consistency preservation specification from a specification on any of the levels and executes it. %specification is finally transformed into a consistency preservation specification by a transformation language, no matter on which level it is specified.
% Imperative transformation languages expect specifications at the operationalization level, whereas rather declarative, usually bidirectional transformation languages expect specification at the modularization level.
% Specifications at the global level are rather unusual, but could for example be expressed with multidirectional QVT-R~\cite{macedo2014FrameworkMultiDirectional-BX}, or the Commonalities language~\owncite{gleitze2017a}.
% A specification must finally be free of mistakes that can be made on any of those levels. 
% The responsibility depends on the abstraction level the transformation language provides, as the developer is responsible for avoiding mistakes at or above the level at which he or she specifies consistency, whereas the transformation language is responsible for those below.

% Specifications must especially be correct regarding all higher levels.
% This means that an operationalization in consistency preservation specifications must preserve consistency according to the underlying modular consistency specifications.
% So after changing a consistent set of models, the consistency preservation has to return another set of models that is consistent again, as shown in \autoref{fig:properties:levels_overview}.
% Additionally, modular consistency specifications must be correct regarding the global specification in the sense that it must contain the same sets of models as the global specification. %exactly those sets of models that are in the relation of the modular specification are in the one of global specification.
% Finally, the global consistency specification has to be correct regarding some, usually informal, notion of consistency for the considered model types.
% Since this can usually not be validated, we assume a global specification to be correct. %made the assumption of having normative consistency specifications.
% This conforms to the notion of \emph{correctness} already defined for \acp{BX}~\cite{stevens2010sosym}, but is used for the extension to networks of \acp{BX} here.

% A specification on one level must always be correct regarding all higher levels.
% This means, for example, that an operationalization in consistency preservation specifications must preserve consistency according to the underlying modular consistency specifications.
% So after changing a consistent set of models, the consistency preservation has to return another set of models that is consistent again, as shown in \autoref{fig:levels_overview}.
% Additionally, modular consistency specifications must be correct regarding the global specification in the sense that it must contain the same sets of models than the global specification. %exactly those sets of models that are in the relation of the modular specification are in the one of global specification.
% Finally, the global consistency specification has to be correct regarding some, usually informal notion of consistency for the considered model types.
% Since this can usually not be validated, we assume a global specification to be correct. %made the assumption of having normative consistency specifications.

% To preserve consistency for a set of models, all specification levels have to be considered.
% A developer defines a concrete specification on one of these levels, which usually depends on the used transformation language and especially the level of abstraction it provides.
% He or she therefore has to consider all levels on and above the one he or she specifies consistency on to ensure correctness, and especially has to avoid mistakes that can be made on those levels.
% On the other hand, the transformation language abstracts from all levels below the one consistency is specified on, and especially has to avoid all mistakes that can be made there.
% In the end, %for correct consistency preservation, 
% all mistakes on all levels must be avoided, but the responsibility depends on the level consistency is specified on.


% %Depending on level on which consistency is defined, potentials mistakes that can be made on one of the levels either have to be avoided by the developer or by the used transformation language and its engine.
% %The developer must avoid all mistakes that can arise from the conceptual levels on and above the one he or she specifies consistency one, whereas the transformation language must ensure that no mistakes occur on the lower levels, which it abstracts from.
% Imperative transformation languages expect specifications on the operationalization level, which means that the transformation developer has to ensure that he or she makes no mistakes on the Levels 1--3.
% Rather declarative, usually bidirectional transformation languages expect specifications on the modularization level, as they abstract from the operationalization. In that case, the developer must only deal with potential mistakes from Level 1--2 and possible operationalization mistakes have to be handled by the language and its engine.
% Finally, specifications on system level are rather unusual, but could for example be expressed with multidirectional QVT-R~\cite{macedo2014FrameworkMultiDirectional-BX}, or the Commonalities language~\owncite{gleitze2017a}. % or the domain-specific DUALLY approach~\cite{eramo2012a}. %Nevertheless, knowledge about the overall consistency constraints in the system is still important, even when providing a specification on a lower level.
% \todoHeiko{Die letzten beiden Abschnitte möglicherweise tauschen, da im letzten eingängier erklärt wird, wie die Ebenen voneinandern abhängen. Der mittele Abschnitt ist sehr schwer verständlich.}
% %As we are focused on networks of \acp{BX}, whose specification happens on the modularization or operationalization level, we are especially concerned with those two levels. 
% %We therefore assume that the developer ensures that no mistakes on the system level are made by knowing about
