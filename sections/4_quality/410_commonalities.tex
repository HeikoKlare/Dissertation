\chapter{Specification of Consistency Relations with Commonalities \pgsize{20 p.}}
\label{chap:commonalities}

\section{Running Example\pgsize{0.5p.}}

We use a running example throughout the paper to explain the \commonalities idea.
It relies on three \metamodels: UML class models, Java code, whose grammar definition can be treated as a \metamodel~\cite{heidenreich2010a}, and the \ac{PCM}~\cite{reussner2016a}, a component-based architecture description language.
The consistency relations between Java and UML class models are mostly one-to-one mappings, as they provide the same concepts of object-oriented design. %provide redundant representations of the same concepts, so the consistency relations between them define mostly one-to-one mappings.
Consistency relations between \ac{PCM} and Java were proposed by \textcite{langhammer2015a}.
For this paper, only the one-to-one mapping between components in \ac{PCM} and classes in Java---or generally all object-oriented languages---are relevant, whereby each component is mapped to a class but not vice versa.

For the examples in this paper, a minimalist subset of those \metamodels, depicted in \autoref{fig:quality:running_example}, is sufficient.
It only comprises classes in UML and Java and components in \ac{PCM}, which all have a name.
The name shall be equal between corresponding classes in UML and Java, whereas the classes realizing a component shall have the same name as the component, complemented by an \enquote{Impl} suffix (cf.~\cite{langhammer2015a}).
With state-of-the-art techniques, those constraints could be implemented as relations in declarative or as enforcing routines in imperative transformation languages.

\begin{figure}
	\centering
	\input{figures/quality/running_example.tex}
	\caption{\Metamodel extracts for Java, UML and \ac{PCM} and consistency relations ({\protect\tikz[baseline=-0.5ex] \protect\draw[latex-latex, consistency related element] (0,0) -- (1.5em,0);}) between them}
	\label{fig:quality:running_example}
\end{figure}

In this paper, we consider \metamodels that conform to the \ac{EMOF} standard~\cite{mof}.
Such \metamodels consist of classes, which we denote as \emph{\metaclasses} to avoid confusion with classes in exemplary \metamodels such as Java and UML.
\Metaclasses can in turn contain attributes and associations to other classes, which may be containments.



\section{The Commonalities Approach\pgsize{2.25p.}}

The state-of-the-art approach to keep models consistent automatically is the application of transformation languages.
If instances of multiple (i.e., more than two) \metamodels are to be kept consistent, one can either use multidirectional transformation approaches, or compose bidirectional transformations to a network of transformations~\cite{cleve2019dagstuhl}.
% Following sentence moved to introduction
%Such a network can be regarded as a graph, formed by \metamodels as its nodes and transformations as its edges.
When an instance of one \metamodel is changed in such a network, the transformations are executed successively to propagate the change transitively across all models.
There are strategies to find one ordering of transformations to apply~\cite{stevens2017a} and strategies to perform a fixpoint iteration until no further changes are conducted~\cite{klare2019icmt}.

%Short introduction of transformation network, what nodes and edges are and so on.
In this section, we propose a different approach for keeping two or more models consistent by specifying their common concepts rather than their direct consistency relations.
This forms our contribution~\ref{contrib:approach}.
% \subsection{Defining Consistency Relations}
% Different metamodels provide

% Consistency relations are usually defined declaratively (what constraints have to hold) or imperatively (how are constraints enforced) between two (or sometimes more) metamodels.
% This is a definition of when instances of that metamodels are considered consistent.
% Consistency constraints can be either \emph{declarative} or \emph{normative}. Declarative constraints exist (e.g. because they are somehow \enquote{natural} and have to be formalized to be checked or preserved by a tools. Normative constraints do not have to adhere to an existing notion of consistency and thus implicitly define what is considered consistent.
% In our running example, the constraints between UML and Java exist and only have to be specified in a declarative manner.
% On the other hand, the constraints between architecture and OO design (i.e. PCM and UML/Java) were normatively defined by \textcite{langhammerconstraints}. There is no single correct mapping between architecture and OO design but several possible.


\subsection{Making Common Concepts Explicit}

The redundancies between different \metamodels are an expression of common concepts that are represented redundantly.
We already gave the example of a class in UML and Java, which are different representations of the common concept of a class in general object-oriented design.
We propose to make common concepts explicit rather than encoding them into the rules of a transformation.
This can be achieved by creating a \emph{\conceptmetamodel}, which defines those common concepts, and specifying the relations between the \conceptmetamodel and the existing \metamodels.
We refer to the existing \metamodels as \emph{\concretemetamodels}.
The relation specifications can be used to derive transformations between the \concretemetamodels and the \conceptmetamodel.

\autoref{fig:quality:commonalities_example} shows the \metaclasses for a \texttt{Class} as extracts of the \concretemetamodels for UML and Java and the \metaclass for the common concept of a \texttt{Class} in the \conceptmetamodel for object-oriented design.
We denote a single common concept as a \emph{\commonality}.
Further \commonalities in object-oriented design could, for example, be interfaces or methods.
The relation between the \texttt{Class} \commonality and its realizations in the \concretemetamodels are shown by a \emph{«manifests»} relation.
%Such a relation can be defined in a transformation.
In our simplified example, the relation would especially define that the names of the classes have to be equal. %an equality relationship.

\begin{figure}
    \centering
    \input{figures/quality/one_commonality_example.tex}
    \caption{\Conceptmetamodel for object-oriented design with a \texttt{Class} \commonality and its relations to UML and Java}
    \label{fig:quality:commonalities_example}
\end{figure}

When another \concretemetamodel that represents the same concepts shall be added, it is only necessary to define its relation to the \conceptmetamodel.
For example, adding \cplusplus as another \metamodel representing object-oriented design would require the definition of the relation between the \texttt{Class} \commonality in object-oriented design and its representation in \cplusplus.
Adding an additional \metamodel may require the \conceptmetamodel to be extended by \commonalities that were not relevant for the already considered \metamodels.
In general, a \conceptmetamodel has to contain \commonalities for redundancies in all \concretemetamodels, which---mathematically speaking---can be expressed as the union of all pairwise intersections of the \concretemetamodels.

% Short description of the Commonalities concept and application to example (UML and Java classes, could e.g. be extended by C++)
% Necessary artifacts: the Commonalities metamodel and the transformations.
% But: one can define a language to specify the Commonalities metamodel together with a specification of how the elements and properties manifest in the concrete metamodels, which we will explain in more detail in \autoref{sec:language}.
% Introduce terms: \emph{Commonality} (metamodel with common concepts), concrete metamodel (a metamodel that is accessed by a user) and \emph{Manifestation} (the concrete metamodels that realize a Commonality).


\subsection{Composing \commonalities}

We have explained how multiple \metamodels can be kept consistent using one \conceptmetamodel.
This allows, theoretically, the definition of one large \conceptmetamodel that contains all \commonalities for all \concretemetamodels.
It would at first sight be similar to a \ac{SUMM}, as introduced by \textcite{atkinson2010a}.
However, it would be less complex than a \ac{SUMM}, which is able to express all information about the software system and thus contains the union of all \concretemetamodels.
%In fact, the resulting \conceptmetamodel would be comparable to a \summ according to \textcite{atkinson2010a}, which is able to express all information about the software system, whereas the instances of the \concretemetamodels would only serve as projectional views that do not provide further information.
Nevertheless, one large \conceptmetamodel would still become unmanageably large due to the fact that it had to contain the union of all pairwise intersections of the \concretemetamodels, as mentioned before.

\begin{figure}
    \centering
    \input{figures/quality/composed_commonalities_example.tex}
    \caption{\Conceptmetamodels (dark) and their relations to \concretemetamodels (light) for the running example}
    \label{fig:quality:composed_commonalities_example}
\end{figure}

To avoid the specification of such a monolithic \conceptmetamodel, we propose to compose \commonalities from different \conceptmetamodels.
Instead of having only \commonalities that relate to \metaclasses in \concretemetamodels, \commonalities may also have relations to other \commonalities.
Consider the \conceptmetamodel for component-based design in \autoref{fig:quality:composed_commonalities_example}.
It contains the \commonality \texttt{Component}, which is represented by an equally named \metaclass in \ac{PCM},
as well as in the \commonality \texttt{Class} in the \conceptmetamodel for object-oriented design, conforming to the relations proposed by \textcite{langhammer2015a}.
This induces a tree structure with \commonalities as inner nodes and \metaclasses of \concretemetamodels as leaves.
With such a composition structure, a \emph{«manifests»} relation may not only exist between a %concrete and a concept \metamodel but also between two \conceptmetamodels.
\commonality of a \conceptmetamodel and a \metaclass in a \concretemetamodel but also between two \commonalities.
However, a concrete or \conceptmetamodel that is lower in the hierarchy is supposed to represent how a \metaclass or \commonality in the higher one manifests, which is why we call it a \emph{manifestation}.
%Due to that, we call concrete and \conceptmetamodels that contain \metaclasses or \commonalities with a \emph{«manifests»} relation to another \conceptmetamodel a \emph{manifestation} of that \conceptmetamodel.
For example, the object-oriented design \conceptmetamodel is a manifestation of the component-based design \conceptmetamodel.

\begin{figure}
    \centering
    \input{figures/quality/extended_composed_commonalities_example.tex}
    \caption{\Conceptmetamodels (dark) and \concretemetamodels (light) of the running example, extended by UML components, with their relations}
    \label{fig:quality:extended_composed_commonalities_example}
\end{figure}

Our goal is to achieve a tree structure of commonalities. In the extended example in \autoref{fig:quality:extended_composed_commonalities_example}, a \texttt{Component} in the \conceptmetamodel for component-based design does not only manifest in a \ac{PCM} \texttt{Component} as well as a \texttt{Class} in object-oriented design, but also in \ac{UML}.
Since a \texttt{Class} in object-oriented design manifests both in Java and \ac{UML}, we do not have a tree structure of the induced relations between the metamodels anymore, due to \texttt{Class} and \texttt{Component} both being represented in \ac{UML}.
However, This still induces a tree structure between \metaclasses and \commonalities, with the \commonalities being inner nodes and \metaclasses of \concretemetamodels being leaves.

%
% How are Commonalities composed to keep multiple models consistent? What about overlaps?
% Apply to OO and PCM case
%
% \begin{figure}
%     \centering
% %    \includegraphics[width=\columnwidth]{figures/dag_example.pdf}\\
%     \input{figures/quality/dag_example.tex} %\\[1em]
%     %\input{figures/dag_example_alternative.tex}
%     \caption{\Concretemetamodels (light) and \conceptmetamodels (dark) of the running example forming a \acs{DAG}}
%     \label{fig:quality:dag_example}
% \end{figure}

%Since we only assume a tree of \commonalities,  rather than a tree of \conceptmetamodels, 
A \metamodel may have several \commonalities in different \conceptmetamodels with different other \metamodels.
For example, in \autoref{fig:quality:composed_commonalities_example}, the UML \metamodel contains a \texttt{Class} and a \texttt{Component} \metaclass, which have two different \commonalities in two different \conceptmetamodels.

%We currently assume that all concept metamodels and relations to their manifestations can be represented as a tree.
% In general, %, this will not be possible, 
% the assumption of having a tree of \conceptmetamodels may not be satisfiable if
% \metamodels have several \commonalities with different \metamodels.
% In fact, we can relax that assumption: 
% The essential requirement is that each change is only propagated across one path between two models, which is inherently given in a tree.
% If the \commonalities of two \conceptmetamodels manifest in disjoint sets of elements of the same manifestation, that manifestation can be---virtually---separated into two \metamodels, for which the network forms a tree again.
% In consequence, if we consider the transformations as directed edges from a \conceptmetamodel to its manifestations, we only have to require a \ac{DAG}, % induced by these edges, 
% as long as the manifestations of all \commonalities are disjoint.
% %If we consider the transformations as directed edges from a \conceptmetamodel to its manifestations, we only have to require a \ac{DAG} induced by these edges, as long as the \conceptmetamodels represent disjoint sets of elements of their manifestations.
% %This relaxation is possible due to the fact that the essential requirement is to have only one path between two models across which a change can be propagated.
% %If different \conceptmetamodels relate to disjoint parts of their manifestations, these manifestations can be virtually separated into different \metamodels, which then form a tree again.
% \autoref{fig:dag_example} exemplifies this relaxation: % on our running example:
% If the UML is also considered a manifestation of component-based design by providing the \texttt{Component} \metaclass, the network does not constitute a tree because of the relations between the UML and the \conceptmetamodels for component-based design and object-oriented design.
% However, it forms a \ac{DAG} and the redundant paths to the UML \metamodel are unproblematic, because the relation to object-oriented design affects the part of the UML \metamodel considering classes (\emph{Class}), whereas the relation to component-based design affects the part of the UML \metamodel considering components (\emph{Comp}). 
% The elements in these parts of the UML \metamodel are disjoint.

\subsection{Transformation Operationalization}
\label{sec:approach:operationalization}

To actually keep models consistent, the specification of a hierarchy of \conceptmetamodels has to be operationalized.
Two options for operationalization can be distinguished:

\begin{description}[leftmargin=\parindent]
    \item[\Conceptmetamodels as additional \metamodels:] The specified \conceptmetamodels are actually instantiated and the transformations are executed as they are defined between the \conceptmetamodels and their manifestations. In consequence, instances of the \conceptmetamodels have to be maintained.
    \item[Transformations between \concretemetamodels:] The \conceptmetamodels and the relations between them and their manifestations are used to derive bidirectional transformations between the \concretemetamodels. For example, from the \conceptmetamodel for object-oriented design in \autoref{fig:quality:commonalities_example}, a bidirectional transformation between Java and UML is derived.
\end{description}

A drawback of the first option is that additional models have to be managed and persisted. 
In consequence, the user has to version these models although they should be transparent to him or her, as long as no appropriate framework abstracts from such tasks.
%Additionally, it is not easily possible to derive the direct relations between two concrete metamodels from such a specification. For example, the direct relation between classes in UML and Java is not accessible but only implicitly expressed by the transitive relation across the concept metamodel for object-oriented design.
A drawback of the second option is that the types of supported relations that can be described in the transformations are limited.
First, only relations may be defined that can be composed with any other relation, such that a direct transformation between two \metamodels can be derived.
Second, it is possible to define $n$-ary relations between more than two \metamodels that cannot be decomposed into binary relations between them, but only into $n$ binary relations between those \metamodels and an additional one~\cite{stevens2017a}.
In consequence, the first option provides higher expressiveness.

While the first option can be realized without an additional language by just defining the \conceptmetamodels and the transformations with existing languages, the second option requires a mechanism that generates the transformations between the \concretemetamodels from those between the \conceptmetamodels and their manifestations.


\subsection{Benefits of \commonalities}
\label{sec:approach:benefits}

We suppose the \commonalities approach to provide two kinds of benefits:
First, we expect that it improves understandability of relations between \metamodels, because common concepts are not encoded in transformations implicitly but modelled explicitly.
This is even a benefit if instances of only two \metamodels shall be kept consistent.
Second, it reduces problems that can occur if several bidirectional transformations are combined into a network of transformations to keep multiple models consistent.

% Two types of benefits:
% \begin{itemize}
%     \item Independent from network size: Understandability (explicit commonalities rather than implicit encoding in constraints)
%     \item Benefits for transformation networks (in the following)
% \end{itemize}

\begin{figure}
    \centering
    %includegraphics[width=\columnwidth]{figures/topologies.png}
    \begin{minipage}[b]{0.4\columnwidth}
        \centering
        \input{figures/quality/topologies_full.tex}
        \vspace{-1em}
        \subcaption{Dense Graph}
        \label{fig:quality:topologies:full}
    \end{minipage}
    \hspace{2em}
    \begin{minipage}[b]{0.4\columnwidth}
        \centering
        \input{figures/quality/topologies_tree.tex}
        \subcaption{Tree}
        \label{fig:quality:topologies:tree}
    \end{minipage}
    \caption{Extremes of transformation network topologies: nodes represent \metamodels, edges represent transformations (\conceptmetamodels in a tree of \commonalities in dark gray), adapted from \cite{klare2018docsym}}
    \label{fig:quality:topologies}
\end{figure}

Networks of transformations can have two extremes of topologies, as depicted in \autoref{fig:quality:topologies}.
If transformations between all \metamodels are defined, the network forms a dense graph (see \autoref{fig:quality:topologies:full}).
In contrast, if there exists exactly one path of transformations between each pair of \metamodels, the network forms a tree (see \autoref{fig:quality:topologies:tree}).
Several properties for such %transformation 
networks have been identified by \textcite{gleitze2017a} and \textcite{klare2018docsym}.
Two essential properties %, defined in \cite{klare2018docsym}, 
are \emph{compatibility} and \emph{modularity}~\cite{klare2018docsym}, which, unfortunately, contradict each other.
The \commonalities approach, however, improves both of them. %, which is an essential benefit that we discuss in the following. %We discuss the benefits of the \commonalities approach regarding those properties.
\emph{Compatibility} means that transformations do not define contradictory constraints.
Consider the relations introduced for the running example in \autoref{fig:quality:running_example}.
The names of the same class in Java and UML are defined to be equal.
If a class in Java and UML realizes a \ac{PCM} component, it shall have the same name appended with an \enquote{Impl} suffix.
If transformations realize the three relations between \ac{PCM}, UML and Java, and the one between \ac{PCM} and Java adds that suffix whereas the one between \ac{PCM} and UML omits it, the constraints can never be fulfilled.
%If the three relations between Java, UML and \ac{PCM} are defined in transformations and the one between \ac{PCM} and Java adds that suffix whereas the one between \ac{PCM} and UML omits it, the constraints can never be fulfilled.
In that case, the transformations are considered incompatible.
Incompatibility may arise whenever more than one transformation path between two \metamodels exists.
In consequence, compatibility cannot be guaranteed in dense network, whereas it is inherently high if the network forms a tree.
\emph{Modularity} means that any subset of the \metamodels can be used without loosing consistency because of missing transformations.
Modularity is high if any \metamodel can be removed from the network and the remaining transformations still define consistency between all remaining \metamodels.
In consequence, modularity is high in a dense network, because all \metamodels are directly related, while it is low if the network is a tree, because inner nodes cannot be removed without their children not being related by a transformation anymore.
Since redundant paths between \metamodels improve modularity but reduce compatibility, these properties are inherently contradicting.

The \commonalities approach improves both these properties due to the fact that additional \metamodels are introduced in the specification.
The transformations between \metaclasses in \concretemetamodels and \commonalities in \conceptmetamodels induce a tree, thus compatibility is high.
Additionally, only the leaves of the tree are \concretemetamodels, which are actually used to describe a system and whose instances are modified, whereas the inner nodes only represent auxiliary \metamodels, exemplarily marked in \autoref{fig:quality:topologies:tree}. 
In consequence, taking an arbitrary subset of \concretemetamodels removes only leaves and can thus be done without removing any transformations that are necessary to keep instances of the remaining \metamodels consistent.
This constitutes a major benefit of the \commonalities approach as compared to ordinary networks of transformations.


% \subsection{Limitations of \commonalities}
% \label{sec:approach:limitations}
% ONE PART MOVED TO COMPOSITION (DAG INSTEAD OF TREES), ONE MOVED TO LIMITATIONS IN EVALUATION SECTION


