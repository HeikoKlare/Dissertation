\chapter{Conclusions
    \pgsize{5 p.}
}
\label{chap:conclusions}

\mnote{Contributions and future work}
We conclude this thesis with a summary of the developed contributions for the problems of achieving correctness of transformation networks and improving their quality properties, as well as a summary of central topics for future work.
In addition to summarizing the central insights, we focus on bringing them into relation and deriving the overall benefits of these contributions in the following.
Limitations and future work have already been discussed in detail %for each of the two parts regarding correctness and quality properties 
within the two evaluations in \autoref{chap:correctness_evaluation} and \autoref{chap:commonalities_evaluation}.
We thus emphasize general topics of future work that we derive from the overall assumptions made for this thesis and the limitations these assumptions induced to the presented approaches.


\section{Summary}

\mnote{Context and assumptions}
With our work, we aim to support the construction of transformation networks to enable the evolution of multiple models describing a software-intensive system while ensuring their consistency.
We have motivated the necessity to develop such transformations independently and to enable their modular reuse, because knowledge about consistency to be defined in transformations is distributed across several roles, and because subsets of the transformations may be reused across multiple projects.
In consequence, it was our goal to find assumptions for transformations such that they can be combined with any other transformations to a network and to find an approach for deciding how and in which order to execute them, i.e., to find an orchestration, such that all models are consistent to the notion of consistency encoded into each of the transformations afterwards.
We have explicitly restricted ourselves to bidirectional transformations, i.e., those keeping two models consistent, and refer to future work for the combination of multidirectional transformations.

\mnote{Thesis topics}
For this context, we have identified two important topics.
First and most essentially, transformation networks need to be correct.
Thus, we have identified the necessity to define a notion of \emph{correctness} for them and approaches how to achieve it in \autoref{part:correctness}.
Second, as building transformation networks is a software engineering task, not only correctness but also further \emph{quality properties} are important, such as maintainability.
Thus, we have discussed relevance of certain quality properties and how they are and can be influenced by the way in which a transformation network is specified in \autoref{part:quality}.

\subsection{Correctness of Transformation Networks}

\mnote{Correctness notion}
We have defined transformation networks as a combination of transformations and functions for determining an execution order of the transformations after a change was performed to a set of models, as well as for applying the transformations in that order.
Such a network can be considered correct if for every set of models and changes, the application of the transformations in the determined order yields consistent models, provided such an execution order restoring consistency for the inputs exists.
This correctness notion consists of three requirements.
First, each transformation must be correct on its own. Second, the combination of transformations must preserve consistency according to a non-contradicting notion of consistency. Third, the determined execution order of transformations must ensure that the resulting models are consistent to the consistency notions of all transformations.

\mnote{Correctness of individual transformations}
Correctness of the individual transformations is a well-defined requirement for bidirectional transformations~\cite{stevens2010sosym}.
Transformations to be used in a transformation network must, however, be \emph{synchronizing}, i.e., they must be able to process changes to both models and update both models they keep consistent.
We have thus discussed how transformations can be defined to be synchronizing with existing transformation languages, which only support processing changes to a one model and which only update the other model to restore consistency.
To this end, we have derived a formal property for which we have proven to achieve synchronization of bidirectional transformations, and a pattern for practical application, of which we have successfully evaluated completeness and correctness to achieve synchronization in case studies.
This approach enables the specification of synchronization transformations by means of existing transformation languages without the necessity to know about other transformations to later combine the developed ones with.

\mnote{Compatibility of transformations}
When knowledge about consistency between models is distributed across multiple roles, these roles can have a contradicting notion of consistency, which can prevent the transformations from finding models that are consistent to all these notions.
This is especially the case if the different pairwise notions of consistency induce a global notion among all models that cannot be fulfilled by any set of models.
We have defined \emph{compatibility} as a property to reflect when consistency notions are contradicting and proposed a formal approach to validate compatibility, which is proven correct.
In addition, we have derived a practical approach for validating compatibility for \qvtr transformations, which operates conservatively, i.e., which is not able to prove compatibility for every set of transformations that actually is compatible because of undecidability of \gls{OCL} used in \qvtr.
In an empirical applicability evaluation of the practical approach, it could validate compatibility of transformations in \SI{80}{\percent} of the cases.
Compatibility is a property of a set of transformation and thus its validation requires knowledge about all transformations to be combined.
The contributions give systematic knowledge about when transformations cannot be combined properly, and the validation approach even enables transformation network developers to automatically validate their transformations to that effect.

\mnote{Orchestration of transformations}
Finally, transformations must be executed in an order such that the resulting models are consistent to the notions of consistency of all transformations.
We have identified and defined the \emph{orchestration problem}, which considers finding an orchestration, i.e., an execution order, of the transformations such that the resulting models are consistent whenever such an order exists.
We have proven that this can require each transformation to be executed multiple and an even arbitrary high number of times, and that this problem is, in general, undecidable.
In addition, we did not find restrictions of the transformations or networks to make the problem decidable and expect it to be unlikely to find such restrictions, as the considered ones were even too restrictive to be practically applicable.
In consequence, we have proposed an algorithm that conservatively approaches the problem by only applying transformations when the resulting models are consistent and in cases in which it fails to find such an orchestration, it supports finding reasons for that.
These contributions provide the knowledge that transformations cannot be combined to preserve consistency between multiple models in every case, but also give an algorithm at hand to at least improve the possibility for transformation network developers and users to find the reasons for not finding an execution order of transformations that preserves consistency.

\mnote{Relevance of problems}
In conclusion, we have provided an approach to achieve correctness for the individual transformations by construction, an approach to statically validate compatibility of transformations, and an approach to dynamically deal with undecidability of the orchestration problem.
In case studies, we have identified missing synchronization to be the most relevant type of mistake, i.e., most occurring failures during transformation network execution were caused by missing synchronization.
Since synchronization can be achieved by construction of the individual transformations, most failures can be avoided without knowing about the other transformations to combine the developed one with.
In addition, the case studies indicate that the orchestration problem may not be that relevant in practice, as no failures due to it occurred.

\mnote{Benefits}
Our contributions thus provide systematic knowledge about correctness of transformation networks and the different necessities to achieve it.
They enable transformation developers to achieve synchronization, as one of the most important properties in transformation networks, already by construction of the individual transformations, to analyze compatibility of transformations and to be aware of undecidability of the orchestration problem, but to have an algorithm at hand that eases the identification of the cause whenever transformations are not able to preserve consistency.

% - Defined notion of correctness for transformation networks -> leads to compatibility and orchestration (global correctness), as well as the requirement of synchronization (local assumption)
% - Correctness of transformations (for local consistency) can be achieved by construction 
% -> Synchronizing transformation can be build without knowing about others to combine with
% -> Approach for making transformation in existing transformation languages (not deriving synchronizing ones) synchronizing, once formal (proven correct) and once with patterns for practical application (driven by argumentation and evaluated empirically)
% - Compatibility can only be checked for given transformations (not without knowing about other transformation), but actually not having compatibility does not affect correctness
% -> Formal definition of compatibility (more than global multiary relation induced by local binary relations is empty)
% -> Formal approach for proving compatibility (proven correct)
% -> Practical approach for validating compatibility for \qvtr transformations (derived from formal approach and empirically validated): only operated conservatively, because of undecidability of \gls{OCL} used in \qvtr - empirically evaluated applicability and found that only \SI{20}{\percent} of compatible transformations could not be identified as such.
% - Orchestration problem is undecidable (repeat the problem), restrictions of transformations and networks to make it decidable were not found and considered restriction made it unlikely to find such a restriction (hard restrictions but still not decidable)
% -> Definition of orchestration problem
% -> Proof of undecidability
% -> Proposal of algorithm for conservatively approach the problem by giving a solution only when its correct, but may not find a solution although it exists, but in that case improve explainability of the failure.
% - Derived which failures are caused by which mistakes regarding the different types of correctness
% Found in case studies that synchronization is most relevant (most failures caused by missing synchronization)
% Found that orchestration problem may not be that relevant in practice (no failures due to orchestration problem in case studies).

% Conclusion: We have an approach to achieve correctness by construction, have a well-defined level of conservativeness for the orchestration and support developers in the conservative cases, and finally provide a static prover for compatibility. Thus we provide important contributions to the goal of defining correct transformation networks.
% Gives systematic knowledge about correctness of transformation networks and the different necessities to achieve it.
% Enables transformation developers to achieve synchronization, as one of the most important properties in transformation networks, by construction, to analyze compatibility and to be aware of undecidability of the orchestration problems, but to have an algorithm at hand that is supposed to ease the identification of mistakes whenever a transformation network fails.

\subsection{Quality Properties of Transformation Networks}

\mnote{Effects of topologies}
Beyond correctness, we have discussed how further quality properties of software systems according to the ISO~25010 standard~\cite{iso25010} apply to transformation networks.
We have identified how they are influenced by the network topology and which of them are contradictory in the sense that determining a specific topology of the transformation network induces a trade-off decision between them.
This especially applies to the two essential properties of correctness and reusability of the individual transformations within other transformation networks.
We especially found that correctness can be optimized in specific kinds of tree topologies of transformation networks, whereas reusability of the individual transformations is optimized if the transformation network forms a complete graph.

\mnote{The \commonalities approach}
From the insights regarding effects of topologies on properties, we have derived the \emph{\commonalities approach}, which is a construction approach for transformation networks that mitigates these trade-offs by introducing additional auxiliary models.
On the one hand, the approach introduces a different way of thinking about consistency in terms of explicitly defining common concepts represented redundantly to be kept consistency rather than implicitly encoding them into rules of transformations.
On the other hand, the approach mitigates the trade-off between correctness and reusability.

\mnote{The \commonalities language}
To support the construction of transformation networks according to the \commonalities approach, we have discussed how a specialized language can support that process and proposed a realization in terms of the \emph{\commonalities language}.
It provides a problem-specific, concise syntax for specifying consistency by means of common concepts, from which a compiler then derives an ordinary transformation network.

\mnote{Practical applicability evaluation}
While the trade-off mitigation, as the essential benefit of the approach, is given by construction if a specific kind of tree topology of the network is achieved, whether such a topology can be achieved in practice was subject to an empirical evaluation by means of a case study.
In this evaluation, we have also evaluated the benefits provided by the \commonalities language in terms of reducing the specification effort.
The evaluation revealed initial indicators for the practical applicability of the approach and the benefits of the language, but additional studies still need to provide further evidence.

\mnote{Benefits}
In general, our contributions provide systematic knowledge about the effects of network topologies on quality properties and about their systematic improvement.
The \commonalities approach is supposed to be applied only in specific situation, in which consistency actually concerns redundant representations of common concepts, whereas it may not be well applicable when consistency describes more complicated dependencies.
In situations for which the approach fits, it gives more guarantees regarding specific quality properties than ordinary transformation networks and thus relieves the transformation developer from ensuring them.
Especially in comparison to defining ordinary transformations, the transformation developers must take less care of ensuring correctness of the defined transformation network.

\mnote{Relation between topics}
Due to the restriction to those specific situations, it is necessary to enable the combination of a specification with the \commonalities approach and other transformation networks defining consistency, be it in terms of another specification with the \commonalities approach or with ordinary transformations.
In consequence, the approaches for building a correct transformation network derived in \autoref{part:correctness} of the thesis must still be applied when using the \commonalities approach proposed in \autoref{part:quality} of the thesis to ensure correctness when combining it with other, ordinary transformations.


\section{Future Work}
\label{chap:conclusions:futurework}

The contributions of this thesis provide several detailed opportunities for future work, given by the limitations and specific options for improvement as discussed in the evaluations in \autoref{chap:correctness_evaluation} and \autoref{chap:commonalities_evaluation}.
In the following, we discuss relevant directions of future work, which need to be followed to make transformation networks applicable for preserving consistency in realistic, complex development scenarios.
They especially require the relaxation of some of the assumptions that we have made for this thesis.

\begin{properdescription}
\item[Concurrent Editing:] 
We have restricted ourselves to modifications of a single model (see \autoref{chap:networks:notions:check_preserve}). 
In general, multiple developers may modify several models concurrently or even a single developer may modify multiple models at a time.
The former scenario could be resolved by reapplying changes of other developers whenever one of them has published his or her modifications, comparable to rebasing commits with Git.
For example, if one developer changes an architecture model, which leads to changes to the code through transformations, and he or she publishes his or her changes, another developer, who may have also adapted the code, reapplies his or her changes to the new system state.
If these changes to the code are conflicting with the ones performed by transformations to stay consistent with the architecture model, these conflicts need to be resolved manually.
It is important that two independent changes together with the changes performed by a transformation network for each of them cannot simply be merged, as there is no guarantee that a merge yield consistent models (see \autoref{chap:synchronization:combination:options}).
In the latter scenario, in which even a single developer may modify multiple models, applying the changes sequentially can, however, also lead to conflicts that need to be resolved by the same developer.
Research for considering concurrent modifications within the two models kept consistent by a single transformation already exists, for example, for \glspl{TGG}~\cite{hermann2012concurrentSynchronization-FASE,orejas2020IncrementalConcurrentSynchronization-FASE} and in terms of specific algorithms conforming to our notion of synchronization~\cite{xiong2013SynchronizingConcurrentUpdates-SoSym,xiong2009parallelUpdates-ICMT}.
Supporting this for transformation networks is, however, subject to future research.
\item[User Decisions:]
We have introduced transformations to be composed of consistency relations and consistency preservation rules (see \autoref{def:synchronizingtransformation}), of which the latter are functions accepting models and changes to them and delivering new changes.
In \autoref{chap:introduction:objective:assumptions}, we have restricted the considerations of this thesis to the case in which transformations can restore consistency in a fully automated way, i.e., we have assumed the consistency preservation rules to be computable.
It may, however, be necessary to require decisions or inputs from users to properly restore consistency.
%\textcite[p.~57]{kramer2017a} proposes a classification for different levels of automation and information required to achieve it.
For example, whether a class added to the code may represent an architectural component or not may not be decidable based on information given within the code, but may be a decision of the software architect.
Relaxing consistency preservation rules to be not necessarily computable but to involve user decisions has two essential issues to be researched.
First, different transformations may require the same decisions, but they would then need to ensure that the user cannot make contradictory decisions, as already discussed in \autoref{chap:correctness_evaluation:categorization:limitations}.
This does, however, require transformation developers to align the transformations with each other, which conflicts our assumption of independent development.
Second, decisions cannot necessarily be made by the same role who performed the original change.
For example, when a software developer adds a class, whether or not it represents a component may be the decision of a software architect.
In consequence, the execution of transformation networks can become a long-running process while waiting for necessary decisions of other roles.
This requires the definition of a reasonable notion of transactions and considerations of workflows to avoid that a network has to pause somewhere in its execution while waiting for an input.
It can even be extended with explorations of the decision space to avoid that if cyclic decisions between several roles are necessary they have to be asked repeatedly, but can instead make speculative decisions based on different options for the decision of another role to be performed later.
\item[Inconsistency Toleration:]
We have introduced consistency as a total notion (see \autoref{def:consistency}), except for the partial notion for the process of repeated execution of transformations to emulate synchronizing behavior (see \autoref{chap:synchronizing:bidirectional:partial}).
This manifests in our induction assumption in \autoref{chap:correctness:formalization:incremental_inductive}, in which we assume models to be consistent before applying changes that need to be kept consistent by transformations.
In current development processes, the system description, especially for large scale systems, will, however, not always be consistent.
This may not always be by accident, but can also be intended to share temporarily inconsistent states with other stakeholders. 
Inconsistencies can be resolved later and potentially by other roles and not necessarily instantly by transformations.
It is an open question whether this can or should be covered with relaxed or potentially different levels of consistency notions, or whether tolerating such temporary inconsistencies may not be necessary with future processes enabled by consistency preservation approaches anymore.
The former case could even enable further workflows to integrate user decisions by annotating inconsistencies to temporarily inconsistent states, which can be resolved in that state rather than in a workflow that requires an explicit decision of a user.
This could enable the definition of different levels of consistency on which development can be performed, in addition to the completely consistent representation of the system and the user-local representation with inconsistencies performed by the user before restoring consistency with transformations.
Tolerating inconsistencies and managing uncertainty have already been discussed for bidirectional transformations~\cite{eramo2015uncertainty-SLE,stevens2014Partial-FASE,diskin2016UncertaintyBidirectionalTransformations-BX}, but transferring this to complete system descriptions and their consistency preservation by networks of transformations has to be considered in future research.
\item[Evidence:]
Several of our evaluation results lack evidence regarding external validity due to the restriction to few case studies.
Although we have argued why and where we expect the results to generalize despite the low number of case studies, further evidence should be provided especially for central insights, such as the relevance of the orchestration problem.
Since a realization of such case studies requires significant effort, evidence could especially be provided by community benchmarks, as recently initiated~\cite{anjorin2019bxBenchmark-SoSym}, or by practical applications of transformation networks in industrial cooperation, such that benefits not only arise from evidence for the scientific results presented in this thesis, but also from the practical usability of the case study.
\end{properdescription}

% Concurrent Editing -> Relax synchronization assumptions
% User Interaction (Transactions) -> Relax computability of functions
% Uncertainty / Tolerating inconsistencies -> Relax induction
% Hierarchic Composition (Networks and Commonalities / SUMs)
% Evidence
% e.g., Relevance of Orchestration Problem


% For commonalities:
% Since the approach is only supposed to be applied in specific situations, it is, however, necessary to combine such a specification with other ordinary specifications of transformation networks.
% In consequence, the \commonalities approach can be seen as a solution for specific consistency relations, in which it provides more guarantees regarding different quality properties than ordinary transformation networks
% In general, it must be combined with other transformations, such that for the combination correctness must again be ensured by means discussed in \autoref{part:correctness}. 


% \begin{copiedFrom}{SoSym MPM4CPS}

% \subsection*{Compatibility}

% In this article, we presented an approach to prove compatibility of consistency relations in transformation network.
% We introduced a formal notion of compatibility, describing when consistency relations are considered contradictory, and we proved correctness of a formal approach that checks whether a transformation network is compatible.
% We defined an operationalization of that approach for QVT-R and OCL, which uses the translation of OCL to first-order logic formulae and an SMT solver to prove compatibility.

% Applying the approach to different scenarios in an evaluation, we found that the approach operates correctly in the sense that it produces \emph{conservative} results.
% Further, we found that conservativeness is rather low, i.e., only few actually compatible transformation networks were not identified as such.
% More precisely, only 20\% of the compatible transformations were not identified as such, which indicates the practical applicability of the approach.
% The current limitations of the approach and the degree of conservativeness especially arise from limitations due to undecidability of OCL and missing translations of OCL constructs to first-order logic formulae.
% We did not identify conceptual issues that limit the expressiveness or applicability of our approach.

% The presented approach enables developers of transformations to independently define their transformations and combine them afterwards, without the necessity to align the underlying consistency relations a priori or to check their compatibility manually when combining them.
% This is an important contribution to the overall goal of being able to build properly working networks of independently developed transformations to foster the development of large software and cyber-physical systems that involve several models and views to describe that system under construction.

% % Applying the approach to different evaluation networks has shown that it finds an appropriate decomposition and proves compatibility in most cases, indicating its practical applicability. Its limitations especially arise from an incomplete representation of all possible OCL expressions as logical formulas and the restricted capabilities of the used SMT solver.

% \end{copiedFrom} % SoSym MPM4CPS


% \begin{copiedFrom}{ICMT}

% \subsection*{Interoperability Issues}
% Issues that can arise from the combination of independently developed bidirectional transformations to networks have not been systematically investigated yet.
% In this paper, we therefore categorized failures that can occur when executing faulty networks of bidirectional transformations.
% Additionally, we structured the process of specifying consistency into three levels: the global level, the modularization level and the operationalization level.
% These levels carry the danger for different kinds of mistakes, which we categorized and related to potential failures they can result in.
% We found that each of the levels is prone to different types of mistakes, and that each type of failure is specific for one category of mistake.
% This enables developers to easily identify the kind of mistake they made when recognizing a failure.
% Additionally, the systematic knowledge about potential mistakes, failures, and their relations makes it possible to further develop techniques to avoid them.
% We have discussed two general avoidance strategies at the modularization and operationalization level in this paper.
% In future work, we will especially investigate how far and under which assumptions bidirectional transformations can be analyzed regarding contradictions at the modularization level when they are combined.

% \end{copiedFrom} % ICMT


% \begin{copiedFrom}{VoSE}

% \subsection*{Quality Properties by Commonalities}

% In this paper, we proposed the \commonalities approach, which allows to make common concepts of different metamodels explicit.
% The central idea of the presented approach 
% %Its central idea 
% is to define \emph{\conceptmetamodels} that represent the common concepts, i.e., the \commonalities of two or more existing metamodels, and to define the relation of those metamodels to the \conceptmetamodels.
% \Conceptmetamodels can be hierarchically composed to enable the separate definition and combination of independent concepts.
% We discussed different options for designing a language that supports the specification of such \commonalities and their relations, 
% as well as for operationalizing such a specification to executable transformations.
% We outlined a language for the \commonalities approach and explained %our selection of the aforementioned options. %
% which of the aforementioned options we chose, and why.
% %We have implemented the language as a proof-of-concept and applied it to simple scenarios.
% Finally, we have applied an implementation of that language to simple scenarios as a proof-of-concept.
% The results indicate the feasibility of applying the \commonalities approach and implementing an appropriate language.

% The expected benefit of our approach is a better understandability of relations between metamodels compared to their implicit encoding in transformations.
% Additionally, we argued why our approach improves the essential properties \emph{compatibility} and \emph{modularity}, which usually contradict each other in other approaches to keep multiple models consistent, like networks of transformations that define the direct relations between metamodels.
% In ongoing work, we extend the capabilities of the language to perform a comprehensive evaluation of the functionality of the approach as well as its applicability to more sophisticated case studies.
% We will validate our claim of improved understandability in a controlled experiment.
% Nevertheless, the initial results of our proof-of-concept are a promising indicator for the applicability of the \commonalities approach.

% \end{copiedFrom} % VoSE

