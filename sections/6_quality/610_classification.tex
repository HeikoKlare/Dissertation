\chapter{Classifying Transformation Networks
    \pgsize{15 p.}
}
\label{chap:classification}

\mnote{Quality property dimension}
In the previous chapters, we have discussed how to achieve correctness of transformation networks under the assumption of independent development and modular reuse of the individual transformations.
Artifacts of the software development process, and thus also transformation networks, however, have more relevant properties than function correctness.
Other properties especially concern the quality of artifacts regarding several dimensions, as also defined by ISO standard 25010~\cite{iso25010}.
For the operation of a software, besides functionality also its performance, usability, reliability and security are relevant, whereas for the development of a software, especially its maintainability and portability are of interest~\cite[Tab. 2]{iso25010}.

\mnote{Focus on maintainability}
These dimensions of quality properties are directly related to the stakeholders for which they are relevant.
While most property dimensions are related to the operation of a system, including a transformation network, and thus relevant for users, i.e., the people developing a system preserving consistency of its artifacts with a transformation network (see \autoref{chap:networks:specification_process}), especially maintainability is important those who develop and maintain a transformation network~\cite[Tab. 2]{iso25010}.
Although all these properties are relevant and have to be considered when developing transformation networks, we explicitly put the focus on those relevant for developers of transformations and transformation network~\autoref{chap:introduction:objective:benefits}.
Thus, in the following, we particularly focus on properties regarding \emph{maintainability} of a transformation network in addition to its functionality.

\mnote{Topology effects on properties}
In our motivation~\autoref{chap:introduction}, we have derived several assumption regarding regarding the process of transformation network construction.
In particular, we have identified independent development and modular reuse of transformation to be essential assumptions in the motivated process, which directly implies that several consistency relations may be preserved transitively across different paths of transformations, thus inducing a dense graph of transformations.
Since the different qualities properties are highly dependent on the topology of a transformation network, we aim to identify these dependencies and thus discuss which topologies of transformations can be distinguished, independent from the initial assumption that we have made.
We then discuss how these topologies influence quality properties and especially identify trade-offs between these properties, especially concerning functional correctness and modularity.
Instead of assuming modular reuse and then deriving how to achieve functional correctness, as was the goal of the previous chapters, we turn around and consider topologies with inherent correctness properties and investigate how to improve quality properties, such as their independent reuse.

% Software has more properties than functional correctness.
% Software product quality can be measured in several dimensions, concerning functionality, performance, usability, reliability, security, maintainability and so on~\cite{iso25010}.
% Further properties in addition to correctness;
% Properties: Modularity, Independence, Evolvability, Universality, Correctness, Comprehensibility (last property has two dimension: comprehensibility of transformations and comprehensibility of their execution (errors));
% --> Discuss such properties

% We started with assumptions directly leading to dense graphs, namely independent development and modular reuse.
% %So we tried to find universal, correct and comprehensible strategy.
% Now we turn around and consider which different topologies can be distinguished and find how they influence properties. 
% See that there are trade-offs between properties, such as modularity and correctness.
% By now, we assumed modularity (for modular reuse) and tried to achieve correctness. Now we turn around and start with correct and comprehensible specifications and try to achieve modularity in them.

% 1. We require modularity/independence by assumption -> dense graphs by assumption --> find how to achieve correctness and comprehensibility (in previous part)
% 2. Lets start with trees and try to find a way of achieving modularity and independence by properly specifying trees.

\mnote{Subordinate contributions}
This chapter thus constitutes our contribution \autoref{contrib:quality:topologies}, which consists of two subordinate contributions: a discussion of quality properties and their manifestation in transformation networks; and a classification of transformation network topologies with a discussion about their impact on properties.
It answers the following research question:

\researchquestionrepeat{rq:quality:properties}

\mnote{Benefits of contributions}
With the insights in this chapter, transformation developers and users become aware of further quality properties of transformation networks besides correctness.
They understand how the topology of a network affects these properties and, thus, between which of them trade-off decisions for their improvement have to be made.

\mnote{Publication of contributions}
Parts of the contributions in this chapter have already been published in previous work~\cite{klare2018docsym}.
This especially concerns the identification of general relations between topologies and quality properties of transformation networks as well as the induction of trade-offs between these properties.

\section{Properties of Transformation Networks}

Transformation networks are software products to be used by software developers rather than end users, thus specific properties are of interest.
We are most concerned with universality, as introduced in \autoref{chap:introduction}, to be applicable for all consistency scenarios, also denoted as functional completeness~\cite{iso25010}, and maintainability (modularity, reusability, modifiability (changes for same context) adaptability (changes for different context))

\subsection{Correctness}
Functional correctness in ISO
(previous section)


\subsection{Universality}
Function completeness in ISO 

Universality includes that it can be applied to every project, i.e., assumptions need to be fulfillable.
One central assumption is the presence of models and their specification languages.
If they do not exist, they need to be defined.
There are several way to integrate multiple forms of artifacts, such as XML-based specifications, into modeling frameworks such as EMF (see \owncite{klare2020Vitruv-JSS} and copy citations from there).

In addition, code often contains models implicitly, thus the defined tools, whose artifacts we want to keep consistent, have definitions of metamodels of their artifacts defined within the code.
We have proposed an approach to make these implicit models explicit to use them within a modeling framework \owncite{klare2017models, klare2019modelsward}.
\todo{Discuss integration of non-modelled artifacts into process with reference to Models/Modelsward paper. Probably add one section discussing the necessity, the drawbacks of not having modelled artifacts and the results of how to integrate them from \owncite{klare2017models,klare2019modelsward}.}


\subsection{Maintainability}

Maintainability, Evolvability, 

Modularity is degree to which a program is composed of components such that changes only influence a parts.
This fits to our needs, because if we have a dense graph, modularity is low, as a change in one transformation may affect several others that need to be changed to restore compatibility and correctness.


\begin{copiedFrom}{DocSym}

%Even if independently developed transformations are interoperable, as discussed before, higher-level challenges remain when considering the way in which transformations express relations or occur if compatibility between the transformations is not given.
%Those challenges cannot be solved simultaneously, but induce trace-off decisions that have to be made regarding the way in which transformations are specified. %, as not all of them can be solved simultaneously.
%Depending on the topology of transformations that preserve the consistency, those challenges are addressed differently, which will be discussed afterwards. %in the subsequent section.
%We present already identified challenges in the following. % and discuss them regarding the combination of binary transformations. % as the state-of-the-art for multi-model consistency preservation.

% \compactsubsection{Uniqueness}
% Each consistency relation should only have to be specified once to reduce effort and the risk of contradictory specifications.
% In terms of transformations, this means that there should only be one path in the graph induced by the transformations to propagate information from one model to another.
% Using existing transformation languages, not knowing which relations have already been realized in which transformations can lead to duplication.
% This is especially the case, if one transformation is only the subsumption of others, like in \autoref{fig:binary_combination_example}. %of components and classes defined by
% %mapping \ac{PCM} to \ac{UML} components, \ac{UML} components to \ac{UML} classes, and those classes to Java classes. 
% \todo{Das folgende ist eigentlich schon im vorigen Abschnitt diskutiert worden}
% If the relation \ref{fig:Example:R3} between \ac{ADL} and Java is specified additionally to the transitive relation over \ac{UML}, the transformations derived from it must ensure that after creating an \ac{ADL} component only one Java class is created, that all necessary trace links are created, and that additional constraints, such as the convention to append \enquote{Impl} to the name, are consistently defined.

\begin{properdescription}
\item[Compatibility:]
Transformations preserve consistency, but also have to be consistent among themselves, i.e., they have to adhere to the same consistency relations, referred to as \emph{compatibility}.
%Contradictory specifications can, for example, arise from inconsistent realizations of the same consistency relations.
If, in our example in \autoref{fig:introduction:scenario_topologies}, the relation %\ref{fig:prologue:binary_combination_example:R3} 
between \gls{ADL} and Java is realized in addition to the transitive relation %$\mbox{\ref{fig:prologue:binary_combination_example:R1}} \concat \mbox{\ref{fig:prologue:binary_combination_example:R2}}$ 
over \gls{UML}, both relations must contain the same name attribute mapping.
If the \gls{ADL} to Java transformation adds an \enquote{Impl} suffix~\cite{langhammer2017a}, whereas the transformations over \gls{UML} omit that, they are \emph{incompatible}.
This can lead to propagation cycles due to alternating values, and to results depending on the transformation execution order. %depends on the transformation execution order. %, which means that the result depends on the execution order of the transformations. % (e.g. the propagation from \ac{PCM} to Java or from \ac{UML} to Java), the result differs (in the example the name of the class)
%\end{inparaenum}
While \emph{compatibility} concerns problems due to the realization of contradictory consistency relations, %the realization of the same consistency relations by different transformations, 
\emph{interoperability} concerns potentially unexpected behavior although all transformations follow to the same consistency relations.
%\todoErik{Ich finde diese Numerierungen immer ein bißchen affig, wenn man sich später nicht auf die Zahlen bezieht. \enquote{On the one hand \ldots on the other hand} sagt dasselbe aus.}
%A direct implication of inconsistent specifications is the non-uniqueness of the specifications.


\item[Modularity:]
The development of different systems requires the usage of different metamodels to describe them.
%One benefit of binary transformations is that they can be reused in different projects and especially different contexts with different selections of metamodels.
Therefore, transformations should be modular, so that an arbitrary selection of metamodels and transformations between them can be used within a concrete project.
If, in our example, transformations are specified transitively across \gls{UML}, it is impossible to use only the \gls{ADL} and Java in a concrete project, omitting the \gls{UML}. 
%This property is especially contradictory to the \emph{uniqueness} property when using transitively executed transformations.

\item[Comprehensibility:]
Maintainability of software development artifacts, including transformations, depends on their comprehensibility.
Comprehensibility can be seen as the number of transformations to consider if a specific consistency relation shall be understood.
Realizing consistency relations in transitive transformations can, for example, reduce comprehensibility, as a developer has to consider a set of transformations to understand a single consistency relation. 
%To ensure %\emph{uniqueness} and 
%transformation consistency %require consistency preservation to be only defined once between two metamodels, which
%it can be necessary to define transitive transformations %across other metamodels 
%to avoid redundant specifications.
%This can reduce comprehensibility as a developer has to consider a set of transformations to understand a single consistency relation. %, which is why this is a contradictory challenge to those others.
%\todoErik{Sie kann dadurch aber auch erhöht werden, weil die einzelnen Transformationen weniger komplex werden (divide et impera)} % Ja, das stimmt möglicherweise im Einzelfall. Aber dafür muss ein Transformationsentwickler im Allgemeinen auch potentiell wieder andere Domänen verstehen, was nicht so vorteilhaft ist.

\item[Evolvability:]
Whenever new transformations shall be defined, e.g. because a new metamodel shall be used and transformations for it have to be defined, the effort should be as low as possible.
This concerns the number of transformations to define and how many metamodels are involved in the transformations for one consistency relation if it is expressed transitively.
\end{properdescription}

%\subsection{Trade-off Solutions}

\end{copiedFrom} % DocSym


\section{Topologies of Transformation Networks}

\subsection{Topology Categories}

Dense graphs vs. trees

\begin{figure}
    \centering
    \begin{minipage}[b]{0.49\columnwidth}
        \centering
        \input{figures/quality/properties/topologies_full.tex}
        \subcaption{Dense graph}
        \label{fig:properties:topologies:full}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.49\columnwidth}
        \centering
        \input{figures/quality/properties/topologies_tree.tex}
        \vspace{1em}
        \subcaption{Tree}
        \label{fig:properties:topologies:tree}
    \end{minipage}
    \caption[Extremes of transformation network topologies]{Examples for extremes of transformation network topologies. Nodes depict metamodels and edges depict transformations. Adapted from~\owncite[Fig. 2]{klare2018docsym}.}
    \label{fig:properties:topologies}
\end{figure}



\begin{copiedFrom}{DocSym}

%As discussed during the presentation of the challenges in the previous section, 
We will focus on compatibility and modularity, as they are crucial for the applicability of transformations. %, whereas comprehensibility and development effort can be seen as usability problems. %, so we focus on those former two challenges.
Defining binary transformations %to express consistency preservation 
for a set of metamodels leads to a trade-off solution regarding those challenges, as they cannot be solved simultaneously.
The intuitive way to define transformations %preservation of consistency relations is achieved by expressing each relation in a transformation.
is to express each relation between two metamodels in one transformation, which leads to a dense graph of transformations. % between the metamodels.
In the extreme case, if all pairs of metamodels have non-empty consistency relations, the graph is complete, as shown in \autoref{fig:properties:topologies:full}.
In that case, modularity is high because each metamodel can be excluded without any drawback, %, comprehensibility is rather high as each relation is expressed directly between the involved metamodels, %(although it may be additionally expressed transitively), 
but relations are likely to be incompatible, as, in the worst case, each relation is specified over $(n-1)!$ transformation paths if $n$ metamodels are involved.
While comprehensibility is high, as each relation is explicitly expressed, adding a metamodel requires to define up to $n-1$ transformations, implying high evolution effort.
%Finally, this also implies a high development effort, as adding a metamodel requires to define transformations to all existing ones.

Another extreme case is to have each consistency relation only defined over a single path in the transformations graph, which results in a tree of transformations, as shown in \autoref{fig:properties:topologies:tree}.
In that case, compatibility of transformations is inherently given, as each relation is only defined once, but modularity is reduced, as only metamodels being leaves can be omitted.
Comprehensibility is low, as each relation may be defined in a path of up to $n-1$ transformations, but evolvability is rather good, as each relation must only be defined once. %, but in a way such that the tree structure is maintained. %requires a critical investigation about how to express the consistency relations to maintain the tree structure.
We summarize that impact of the topology in \autoref{tab:properties:topology_impact}.

%In the following sections, we discuss our proposed solutions on how to deal with those trade-offs.
\begin{table}
    \centering
    \begin{tabular} {L{8em} C{6em} C{5em}}
        \toprule
        \textbf{Challenge} & \textbf{Dense Graph} & \textbf{Tree}\\
        \midrule
    %    Uniqueness & - - & ++\\
        Compatibility & - & ++\\
        Modularity & ++ & -\\
        Comprehensibility & + & -\\
        Evolvability & - & +\\
        \bottomrule
    \end{tabular}
    \caption{Challenge fulfillment by transformation topology}
    \label{tab:properties:topology_impact}
    \vspace{-1.5em}
\end{table}

A tree topology has the drawback that it is not always applicable.
It requires that the transformation developers
%\todoErik{whom?}
find a subset of all consistency relations between the metamodels that induces a tree and whose transitive closure contains all other relations.
%This is necessary, because the transitive relations in the tree must also cover the direct relations between the metamodels that are omitted.
In general, such a subset cannot be found.
Of three metamodels, there must always be one containing the overlapping information of the two others, as only then the transitive closure of two consistency relations subsumes the third. 
In the example in \autoref{fig:properties:tree_generation}, it is necessary that two relations are contained in the transitive closure of the others to get a tree that covers all relations.
%An example for such a relation is given in the graphic.

\begin{figure}[b]
    \centering
    \input{figures/quality/properties/tree_generation.tex}
    \caption{Reducing a consistency relation graph to a tree}
    \label{fig:properties:tree_generation}
\end{figure}

In practice, the used topology will potentially be a mixture between those extremes.
The natural way to foster the independent development of transformations %to specify consistency preservation 
would be to define one transformation for each consistency relation, resulting in a dense graph with a high potential for incompatible transformations.
To deal with that, mechanisms that analyze compatibility between transformations could be researched.
Nevertheless, high expressiveness of transformation languages allows only conservative approximations. % without reducing the expressiveness of transformation languages, this easily leads to problems similar to those in static code analysis, which rely on approximations, due to the Halting problem.
In our thesis, we will therefore investigate approaches that result in tree-like specifications that directly imply compatibility between the transformations, but with increased \emph{applicability} and \emph{modularity}. %of  try to achieve a tree of transformations, as this directly implies consistency between the transformations, but with increased modularity and with applicability.

\end{copiedFrom} % DocSym

\subsection{Property Effects}

Modularity, independence, correctness and comprehensibility directly induced by specific topologies
Universality not given for trees, has to be ensures for dense graphs (depends on orchestration strategy, see existing work)
Trade-off between Modularity/Independence (inherent in dense graph) and Correctness/Comprehensibility (inherent in tree)


