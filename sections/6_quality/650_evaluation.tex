\chapter{Evaluation and Discussion 
    \pgsize{15 p.}
}
\label{chap:commonalities_evaluation}

\todo{Draw tree structure of case study PCM-UML-Java (best from thesis Lukas)}

\todo{USe table formatting from correctness evaluation}
{
\newcommand{\innerrowspacing}{0.3em}
\newcommand{\outerrowspacing}{1em}
\begin{table}
    \begin{tabular}{L{8.2em} L{20em}}
        \toprule
        \goal{Approach} & Show that concept and language can achieve consistency between several models. \\\addlinespace[\innerrowspacing]
        \question[eq:commonalities:correctness]{Correctness} & How many model changes in a case study can be properly kept consistent? \\\addlinespace[\innerrowspacing]
        \metric & \metrictext{Ratio of successfull test cases} \\\addlinespace[\outerrowspacing]
        \question[eq:commonalities:practicality]{Practicality} & How far is the assumption of defining a tree of \commonalities is achievable in practice? \\\addlinespace[\innerrowspacing]
        \metric & \metrictext{Number of cross-tree relations in a case study compared to number of relations}\\\addlinespace[\innerrowspacing]
        \midrule\addlinespace[\innerrowspacing]
        %
        \goal{Language} & Show that a specialized language improves conciseness of consistency specifications \\\addlinespace[\innerrowspacing]
        \question[eq:language:benefit]{Benefit} & How much more concise is the specification for a case study compared to a definition with direct transformations? \\\addlinespace[\innerrowspacing]
        \metric & \metrictext{Number of SLOC with \commonalities compared to number of SLOC with \reactions for same case study} \\
        \bottomrule
    \end{tabular}
    \caption[Goals, questions, metrics for commonalities]{Goals, questions and metrics for commonalities approach and language.}
    \label{tab:commonalities_evaluation:gqm}
\end{table}
}

% \gqm{Functionality}{Concept and language can achieve consistency between several models}{How many model changes in a case study can be properly kept consistent?}{Ratio of successfull test cases}

% \gqm{Practicality}{The assumption of defining a tree of \commonalities is achievable in practice}{Is the definition of cross-tree relations necessary in a case study?}{Number of cross-tree relations in a case study compared to number of relations}

% \gqm{Practicality/Benefit}{A specific language improves conciseness of consistency specifications}{How much more concise is the specification for a case study compared to a definition with direct transformations?}{Number of SLOC with \commonalities compared to number of SLOC with \reactions for same case study}

Diskussion: Erreichen der Modularität auch evaluieren? Ist per Konstruktion gegeben, könnte man aber natürlich auch noch auswerten (bringt aber nichts).


\begin{copiedFrom}{VoSE}

\section*{Proof-of-Concept}

We have proposed the \commonalities approach and a realizing language.
We have explained that we expect them to improve understandability of transformations and to reduce problems of transformation networks, such as compatibility and modularity.
Although we gave arguments that justify this expectation, it has to be evaluated empirically to increase evidence.
However, before evaluating the benefits of our approach, we first have to investigate its feasibility.
For that reason, we built an initial prototype of the language and applied it to a simple evaluation case as a proof-of-concept.
%to show the feasibility of the concept.
%This forms our contribution~\ref{contrib:proofofconcept}.

% Evaluation Goal: Show feasibility of the idea

% Evaluation Methodology: Build a proof-of-concept prototype of a language and apply it to a simple case

\subsection*{Case Study}

We have implemented a prototype of the \commonalities language, which allows to define \commonalities with simple attribute and reference mappings and to compose \commonalities.
The syntax is an extension of the example shown in \autoref{lst:quality:commonalities_language_example}.
The language comprises a compiler that derives a \conceptmetamodel, as well as a set of transformations from a specification in the language.
The generated transformations are in turn defined in the \reactionslanguage~\cite{klare2016b}, which is a delta-based transformation language that is, just like the \commonalities language itself, part of the \vitruv approach~\cite{kramer2013b}.
\vitruv is a view-based development approach that uses transformations to keep models consistent.
The implementation of the \commonalities language can be found in the GitHub repository of the \vitruv project \cite{vitruvFrameworkGithub}. %\footnote{\label{githubfootnote}\url{https://github.com/vitruv-tools/Vitruv}}.

We have applied the implementation to a simple case study that consists of four metamodels, each containing one \metaclass that represents a root element and one that represents a contained element. 
Both elements have an identifier and a name in all metamodels, and an additional single-valued and multi-valued feature of integers in two of the metamodels.
The root \metaclass additionally has a containment reference to the contained \metaclass.
We have defined two \commonalities, one for the root element and one for the contained element, which redundantly represent the same concepts in all the metamodels.
The root \commonality references the contained \commonality.
This results in one \conceptmetamodel with four manifestations.

To validate that the specifications in the \commonalities language are correctly defined and operationalized, we have
%defined 8 test cases that 
defined test cases that perform 21 different model modifications, which 
%
create and delete all possible types of elements and modify all attribute and reference values in instances of every metamodel.
They cover the set of all possible modifications that can be performed on instances of those metamodels.
This also includes change propagation across composed \commonalities.
The tests successfully validate that the modifications are correctly propagated to all other models in all cases.
The test cases and the used example metamodels are also available in the GitHub repository of the \vitruv project \cite{vitruvFrameworkGithub}. %\footnotemark[1].

% \begin{itemize}
%     \item First reference to concrete implementation here
%     \item Refer to simple example implementation showing the ability to define and run the Commonalities approach
% \end{itemize}

\subsection*{Discussion}
% Formerly: Threats to Validity

%Maybe we can omit this section, but we need to discuss that it is really, really only a proof-of-concept (some reviewers do not understand the difference to a complete benefit, scalability and effectiveness evaluation if you do not tell them again and again).

Our proof-of-concept validates the feasibility of the proposed \commonalities approach: 
It demonstrates that it is possible to apply the concept of defining consistency relations between multiple metamodels  through a central metamodel in a simple scenario. It also shows that an operationalization can be derived that preserves consistency of all instances of such metamodels.
%Our evaluation only serves as a proof-of-concept to validate feasibility of the approach that we present in this paper.
%In consequence, 
The results only give an indicator that the \commonalities concept can be applied and that a language with an internal concept definition can be designed.
To further evaluate the capabilities of such an approach, the language would have to be extended to be able to define more complex relationships.
Additionally, the approach has to be applied to larger parts of more complex metamodels and metamodels for different contexts to improve external validity of the results.
This could also reveal whether the assumption of having a tree of \commonalities is practical in realistic scenarios.

Since evaluating functional capabilities of the approach is only an---essential---first step, the evaluation of further properties such as applicability, appropriateness, effectiveness and scalability are part of ongoing work with further case studies.
As a central benefit of our approach, we claim to improve understandability of relations between metamodels, but can only give arguments for that by now.
An evaluation of that claim would require a user experiment that compares our approach to specifications of direct transformations between multiple metamodels.

Finally, one might argue that defining \conceptmetamodels leads to additional effort, as for two metamodels it is necessary to define one additional metamodel and two transformations rather than only a single transformation.
First, this is only true as long as only two metamodels are related by one \conceptmetamodel. 
If three metamodels shall be related, there would be a network of three transformations, which are not necessarily compatible without using the \commonalities approach, and one metamodel with three transformations using the \commonalities approach.
When the \commonalities approach is applied, the number of necessary transformations increases linearly with the number of metamodels that are related, whereas it increases quadratic without them.
Second, the effort for defining transformations can be reduced by using an appropriate language to define \conceptmetamodels and transformations, as we have proposed in \autoref{chap:language}. Our language only requires developers to write one specification that contains both the \conceptmetamodel and all transformations to its manifestations.

% \subsection{Limitations}
% Contradictory Commonalities specifications?

\end{copiedFrom} % VoSE
