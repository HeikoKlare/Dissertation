\section{Application Scenarios}

\subsection{Processes for Defining Commonalities}

Discuss how commonalities can be defined. Which roles are involved, especially how different domain experts can communicate. E.g. bottom-up approach: Take the most related metamodels and define their commonalities. Then define higher-level commonalities relating these concept metamodels or even the concrete metamodels. 
The problem is that combining two concept metamodels requires them to contain all necessary information, thus a concept metamodel design is not only driven by the metamodels to keep directly consistent, but also by the information that is needed to preserve consistency to other commonalities. This refers to the same scenario as if multiple commonality structures are encapsulated into projective view environments which are combined by BX. They require the exposed views to provide all information necessary to preserve consistency.


Prozess zur Erzeugung von Commonalities beschreiben:
- Optimalerweise kennt man alle MM vorher und kann sinnvolle Commonalities bauen (immer das am wenigstens redundante Konstrukt, z.B. eher Person in Familie als Persons mit Familiennamen (redundante Darstellung des Familiennamens)
- Bei Erweiterung um zusätzliche Metamodelle sind ggf. Anpassungen an Commonalities notwendig. Hier ist wieder die Lokalität bei den Commonalities vorteilhaft (interne Spezifikation), weil man dann eine Commonality insgesamt ersetzen kann statt in jeder Transformation deren Manifestierung anzupassen.

Evolutionsprozess:
- Wie eignet sich welcher Ansatz zur Erweiterung mit MM. I.d.R. reicht es nicht eine Verbindung zu ergänzen, sondern die Konzeptmetamodelle für angepasst werden für ein neuen zu koppelndes Metamodell



\subsection{Combination with Other Transformations}

\mnote{Encapsulation of Commonalities with Views}
\todo{Composing commonality structures: encapsulate them (by views?) -> refer to \autoref{chap:networks:specification_process} for different network developers composing different networks}

Discuss here, that a commonalities structure can be encapsulated in views (ref to Vitruv), which are then used to combine with other such structures in an ordinary network of BX. E.g. let there be an OO commonality for Java and UML and one CBS commonality for UML and PCM. Both are encapsulated in a projective view-based approach, which, e.g., exposes the concept metamodel. These views can than be combined by ordinary bx. This allows to build concept metamodels for subsets of the problem (subsets of the metamodels), especially for scenarios in which descriptive relations exist, which are then combined by ordinary networks. This gives the benefits of commonalities, such as extendability, modularity (which are preserved even if the concept is combined with others by bx), but also provides the flexibility of bx networks, but reduced the proneness to errors in the networks as parts are handled by inherently compatible commonalities.

See for example \autoref{fig:quality:concept_metamodel_integration} for a scenario combining normative and descriptive relations. We could compare a scenario where Java, UML class, UML comp and PCM are connected in a network, connected in an overall commonality and with two commonalities combined in a network.

Drawback of this approach is that the views exposed the structures have to provide all required information to be kept consistent with other structures. For example, the CBS commonality only contains the information shared between UML and PCM, thus if there is information in PCM to be shared with Java, but not with UML component, the concept metamodel does not contain that, but has to be exposed to be kept consistent with the OO concept. Thus, there may be more extensive views than only exposing the commonality. In fact, the structure would need to be a SUM, for which any information can be extracted. However, it is an open issue how consistency is preserved if information is derived to different views which are all modified, or if a heterogeneous view is created (cf. ModelJoin). Imagine the consistency preservation derives the commonalities view for components to modify the information shared between UML and PCM and uses the PCM view to change information only present in PCM (e.g. functionality). If a change in Java requires modifications in both views, these changes both have to be propagated to the underlying models. If there are conflicts, they have to be resolved like in a synchronization scenario (several user modify views concurrently). This problem is yet unsolved.