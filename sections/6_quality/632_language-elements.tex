\section{The \Commonalities Language}

\mnote{Section overview}
In this section, we present an overview of the \commonalities language.
It constitutes one possible realization of a language for the \commonalities approach with the conceptual design choices that we have discussed in the previous section.
This especially includes an internal specification of concepts.
To give an impression of the language, we first introduce two examples for specifications in a prototypical realization of the language with a textual syntax, which we have already proposed in previous work~\owncite{klare2019models} and which was originally developed in the bachelor's thesis of \textowncite{gleitze2017a} and extended in the master's thesis of \textowncite{hennig2020ma}.
We then give an overview of the language elements and introduced their general semantics before explaining the different categories of them in more detail at the given examples.
Since we focus on the concepts of the language rather than its detailed realization with a textual syntax, we refer for details of that realization to the theses of \textowncite{gleitze2017a} and \textowncite{hennig2020ma}.


\subsection{Examples in Textual Syntax}

\lstinputlisting[language=commonalities, float,
    caption={[Exemplary \commonality for clases]An exemplary specification for an extract of the \texttt{Class} \commonality between \gls{UML} and Java in the \commonalities language},
    captionpos=b,
    label=lst:language:class_example,
]{listings/quality/language/class_example.lst}

\lstinputlisting[language=commonalities, float,
    caption={[Exemplary \commonality for components]An exemplary specification for an extract of the \texttt{Component} \commonality between \gls{PCM}, UML and the object-oriented design \conceptmetamodel in the \commonalities language},
    captionpos=b,
    label=lst:language:component_example,
]{listings/quality/language/component_example.lst}

\mnote{Examples overview}
We depict two examples for specifications in our prototype of the \commonalities language with a textual syntax in \autoref{lst:language:class_example} and \autoref{lst:language:component_example}.
The specifications depict extracts of a \commonality for classes in \gls{UML} and Java, as well as extracts of a \commonality for components in \gls{PCM}, \gls{UML} and classes with their containing packages in the object-oriented design \conceptmetamodel.
The extracts are selected to reflect the different elements of the \commonalities language without introducing unnecessary complexity.
We sketch the meaning of the examples in the following and clarify them along with the subsequent introduction of the language elements more precisely.

\mnote{Class \commonality example}
The class \commonality, depicted in \autoref{lst:language:class_example}, is restricted to their names and methods.
In \gls{UML}, a class is represented by a class that is contained in a unique instance of a \gls{UML} model.
In Java, a class is also represented by class that is contained in a compilation unit, which depicts one file consisting of imports and class specifications as a single unit of compilation~\cite{heidenreich2009a}.
Names are represented equally in \gls{UML} and Java classes.
The name of the compilation unit is defined by the fully qualified name of the class, i.e., the concatenation of its namespace and the class name separated by a dot.
The specification expresses this as the class name to be the suffix of the compilation unit name after the namespace followed by a dot.
Methods are specified in a dedicated \commonality in the object-oriented design \conceptmetamodel, such that they are only referenced in the class \commonality, but without any specification of the relations of their contents.

\mnote{Component \commonality example}
The component \commonality, depicted in \autoref{lst:language:component_example}, is restricted to their names.
In \gls{PCM} and \gls{UML}, components are realized by explicit component or basic component \metaclasses, respectively, which share the same name.
In object-oriented design, components are defined to be represented by classes contained in a package.
Classes are only considered to represent components when their name has an \enquote{Impl} suffix and their name is then defined to be the component name with an \enquote{Impl} suffix.
The specification defines this as a prefix, analogous to the suffix for the name of a compilation unit, as it denotes that the component name is the prefix of the class name before \enquote{Impl}.
Finally, the package name is defined to be the component name but starting with a lowercase letter whereas the component name is start with an uppercase letter.
Analogous to the prefix definition for the class name, the specification defines a \texttt{firstUpper} operation as the component name shall be the package name with the first letter in uppercase.


\subsection{Elements Overview}

\mnote{Categories of elements}
The \commonalities language essentially consists of three categories of elements.
First, at a top level the structure of \commonalities needs to be defined in terms of specifying for each of them the \conceptmetamodels they belong to, as well as the features in terms of attributes and references it described.
Second, each \commonality needs to define its manifestations, i.e., the \metaclasses of \concretemetamodels or other \conceptmetamodels being its manifestation, along with conditions defining when instances of \metaclasses are to be considered a manifestation.
This defines when a manifestation relation between a \commonality and \metaclasses of another \conceptmetamodel or \concretemetamodel exist.
Third, each \commonality needs to define the relations of its features to those of its manifestations.
This defines the manifestation relations, i.e., the conditions that have to hold for considering a manifestation consistent to a \commonality.

\begin{figure}
    \centering
    \input{figures/quality/language/language_elements.tex}
    \caption[\commonalities language elements]{Class diagram with the essential elements of the \commonalities language and their relations. Elements that exist independent from the language are depicted in the top row.}
    \label{fig:language:elements}
\end{figure}

\mnote{Structural elements}
\autoref{fig:language:elements} depicts the essential elements of the \commonalities language.
At the top, it depicts metamodels, \metaclasses, references and attributes as already existing in the notion of a general modeling formalism and as specified in \concretemetamodels.
The language introduces concepts, which represent the \conceptmetamodels, and \commonalities, of which such a concept consists.
In our realization, they can be considered specializations of metamodels and \metaclasses, as they can be considered as such but with the special semantics of being only auxiliary artifacts for the \commonalities approach.
A \commonality consists of \commonality references and attributes, which, again, can be considered specializations of ordinary references attributes.
In the given examples, we have attributes for names and a reference to methods.
Additionally, a \commonality contains manifestations.
Each manifestation represents the realization of the concept represented by the \commonality in another metamodel by one or more  \metaclasses and potentially further conditions for them.
Such manifestation are, for example, a class and a compilation unit in Java for the class \commonality depicted in \autoref{lst:language:class_example}.
In preparatory work~\owncite{gleitze2017a,hennig2020ma}, as well as in the current state of prototypical implementation of the language~\owncite{vitruvFrameworkGithub}, such manifestations have also been called \emph{participation}.
Each \commonality reference and attribute is complemented by reference and attribute relations that define how these features are related to information in the manifestations.

\mnote{Relational elements}
In consequence, the manifestation conditions together with the attribute and reference relations define the consistency relations between the \commonality and its manifestations, which we have introduced as manifestation relations.
All these relations consists of operators, which define how elements are related, and operands, which define the involved elements to be considered by the operator. 
The operators can be considered specifications of transformation rules, which take operands providing the information necessary to check or preserve consistency.
In our language realization, operators can be specified by implementing according interfaces and thus dynamically extending the language with arbitrary operators.
They can, however, also be defined as a static part of the language and thus without the possibility to extend them.
Operators have a direction, as they may enforce the defined relation either in both directions or only in one of them.
For example, the name of a class in \autoref{lst:language:class_example} is related to the Java class name bidirectionally (denoted by \enquote{=}), such that a change of the Java class name leads to the change of the name of the class \commonality, which then in consequence changes the \gls{UML} class name, but also a change of the class \commonality name, e.g., because of a change of the \gls{UML} class name, leads to a change of the Java class name.
The name of a compilation unit, however, is only enforced, because it is derived from the Java class name, such that a change is propagated because of the changed Java class name anyway.

\mnote{Simplifications}
For reasons of simplicity, we omitted several elements of the actual language realization, which concerns generalizations as well as specializations of the depicted elements.
For example, manifestation conditions, reference relations and attribute relations all represent relations between the \commonality and its manifestations, especially comprising a direction, which an be represented in a common supertype \texttt{Relation}.
Likewise, the three operator types for manifestations, references and attributes can be derived from a common \texttt{Operator} supertype.


\subsection{Language and Elements Semantics}

\mnote{Consistency relations by \commonalities}
A \commonality defines which elements different manifestations have in common and how they are related.
For example, the class \commonality given in \autoref{lst:language:class_example} denotes that classes have names and methods in common and that they are related by specific naming schemes of name attributes and specific references containing representations of methods.
Thus, whenever there are elements in one model that match one of the specification for a manifestation in terms of instantiating the defined classes and fulfilling the defined conditions, there must be elements in other models matching the other manifestation specifications and fulling the defined relations for attributes and references.
In theory, from such a specification consistency relations, according to \autoref{def:consistencyrelation}, could be derived, which enumerate those tuples of instances of the \metaclasses in the manifestations, which fulfill the manifestation conditions and whose attributes and references fulfill their defined relations.

\mnote{Consistency preservation}
We especially want to preserve consistency rather than only checking it, and thus derive consistency preservation rules from such a specification.
In \autoref{chap:language:operationalization}, we discuss such an operationalization in more detail.
In general, we distinguish the instantiation, update and deletion of a \commonality, according to the scenarios depicted for \mappings the in the bidirectional \mappings language~\cite[Sec. 7.2.1]{klare2020Vitruv-JSS}.
The \commonalities language specifies a bidirectional transformation between a \commonality and each of its manifestations.
Thus the behavior of each such transformation conforms to the behavior of the \mappings language, in which we could define the transformation between a \commonality and its manifestation.

\begin{properdescription}
\item[Instantiation:] \mnote{\Commonality instantiation}
A \commonality is \emph{instantiated}, whenever elements are added to a model, such that they instantiate the \metaclasses of a manifestation of that \commonality and fulfill the defined manifestation conditions.
We say that these elements \emph{match} the manifestation of the \commonality.
In that case, an instance of the \metaclass realizing the \commonality is created and its attributes and references are initialized with values according to the relations defined in the \commonality.
Then, for each other manifestation, instances of the \metaclasses are generated and inserted into a model according to the specified manifestation conditions and defined relations of attributes and references.
For example, according to \autoref{lst:language:component_example}, whenever a Java class with the suffix \enquote{Impl} is created and inserted into a package, a component \commonality with the name of the class without that suffix is created, and a basic component in \gls{PCM}, as well as a component in \gls{UML} with that name are created.

\item[Deletion:] \mnote{\Commonality deletion}
A \commonality is \emph{deleted} whenever the elements, for which a \commonality was instantiated, do not match the manifestation anymore.
Then, the instance of the \metaclass realizing the \commonality is removed, as well as the instantiations of all \metaclasses of the other manifestations.
For example, whenever a Java class representing a component is removed, or even if only the \enquote{Impl} suffix is removed, the \commonality and all other manifestations in \gls{PCM} and \gls{UML} are removed.

\item[Update:] \mnote{\Commonality update}
A \commonality is \emph{updated} whenever any of the attribute or reference values of the elements of a manifestation, for which a \commonality was instantiated, gets changed.
In that case, the values in the \commonality and all other manifestation are updated if the changed value is used in the according attribute or reference relations, i.e., if it is one of its operands.
The relation also defines a direction to indicate whether the change is only checked in the manifestation, i.e., whether a change of any value in the manifestation leads to an update of the value in the \commonality and the other manifestations, whether the change is only enforced, i.e., whether a change of a value of the \commonality leads to change of the values in the manifestation but not vice versa, or whether it is bidirectional, i.e., both checked and enforced.
This ensures that consistency is preserved for the elements for which a \commonality is instantiated.
\end{properdescription}

\mnote{Relation to \mappings language}
While for the instantiation and deletion of a \commonality only the manifestation classes and their conditions are relevant, for an update only the attribute and reference relations are relevant.
To put this into relation to the \mappings language, manifestations and their conditions conform to \emph{single-sided conditions} of \mappings, whereas attribute and reference relations conform to \emph{bidirectionalizable conditions} of \mappings~\cite[Sec. 7.2.1]{klare2020Vitruv-JSS}.
In general, since a \commonalities specification can be seen as a combination of defining multiple \mappings in the \mappings language, large parts of the semantics and possibilities for the realization are comparable.
We thus focus on the structure that \commonalities define on top of bidirectional mappings and explicitly refer to work on \mappings for concepts that already have been well-researched and are completely reusable, such as operators and methods to define and execute them bidirectional.

\mnote{Alignment with consistency relations}
In \autoref{chap:synchronization:gap:alignment}, we have also discussion the addition, removal and change of condition elements as the relevant change types to be distinguished when realizing consistency preservation.
This conforms to the scenarios of instantiation, deletion and update of a \commonality.
The addition of a condition element of a consistency relations defined by a \commonality specification means that the according manifestation is matched and thus the \commonality is instantiated.
The removal and update conform to the deletion and update of a \commonality analogously.


\subsection{\Commonalities and Manifestations}

\mnote{\Commonalities and concepts}
The top-level elements of the \commonalities language are \commonalities.
Each of them depicts a common concept, such as a class or a component, and is associated with a \conceptmetamodel, which groups common concepts that belong together.
In the given examples, each specification contains one \commonality and starts with a specification of the \conceptmetamodel it belongs to, comparable to a package specification of a class in Java.
These \conceptmetamodels are named \emph{ObjectOrientedDesign} and \emph{ComponentBasedDesign}, according to the ones we proposed in the examples for composing \commonalities in \autoref{chap:improvement:commonalities:composition}.

\mnote{Manifestations and their classes}
The specification of each \commonality starts with its manifestations, which are \metaclass tuples of the \concretemetamodels or \conceptmetamodels in which the \commonality manifests, together with further conditions on when instances of these \metaclasses form a manifestation of a common concept.
Such a manifestation denotes which elements have to exist in a model and which conditions they have to fulfill to consider these elements a manifestation of a common concept described by the \commonality.
The \metaclass tuples are represented by \emph{manifestation classes}, which only reference an ordinary \metaclass, but may also have an alias for referencing it.
The \metaclass they reference can be ordinary classes of a \concretemetamodels, such as \gls{UML} components in \autoref{lst:language:component_example} or they may be \commonalities of a \conceptmetamodel, such as classes in object-oriented design in \autoref{lst:language:class_example}.

\mnote{Single manifestation classes}
Additionally, manifestation classes can be declared \emph{single} to denote that they only occur uniquely within one metamodel and do not share a \commonality with others, comparable to a singleton, but are still relevant for the \commonalities specification.
For example, a \gls{UML} model always has a root container of the \metaclass \emph{Model}, which does not share a \commonality with Java in the object-oriented design \conceptmetamodel and exists uniquely, as there may only be one such \gls{UML} model.
An alternative representation of such elements that need to uniquely exist in one of the manifestations but are not represented in others would be \commonalities with only one manifestation that are bootstrapped.
This means that such a \commonality and its manifestation would always exist and is thus created as soon as the developed of a system is started rather than instantiating it when a manifestation is matched.
For example, a \gls{UML} model would be created as soon as a new software development project is started.
\citeauthor{kramer2017a} uses such a bootstrap representation of elements in his \mappings language for bidirectional transformations~\cite[Sec. 7.1]{kramer2017a}.

\mnote{Manifestation conditions}
Manifestations further define manifestation conditions, which further define when instances of the \metaclasses referenced by the manifestation classes shall be considered a manifestation of the defined \commonality.
Obviously, not every instance tuple shall be considered as such.
This can further depend on properties of the single objects, or on the relation between them.
For example, for the manifestation of components in object-oriented design according to \autoref{lst:language:component_example}, only classes matching a specific naming schema shall be considered components, and only a pair of class and package in which the class is contained in that package shall be considered a component, but not any pair in which the class is not contained in the package at all.
Such conditions can be seen as restrictions on the instance or model level, whereas the \metaclass tuples only define a restriction at the type or metamodel level.

\mnote{Manifestation Operators}
A manifestation condition consists of a manifestation operator, a left operand and a list of right operands.
The left operand can be considered the reference element of the operator. 
It can be any \metaclass of the manifestation or any of its attributes or references, for which a condition shall be defined.
The operator can be any Boolean-valued condition that is evaluated for the left operand and potentially further right operands, which can, again, be \metaclasses of the manifestation or any of their features, or a literal, such as a fixed number or string.
\autoref{lst:language:component_example} contains such the operator \emph{in}, which validates whether the value of the left operand is contained within a reference given as the right operand.
In addition, the operator \emph{hasSuffix} checks whether the value of the left operand contains the right operand as a suffix.


\subsection{Features and Relations}

\mnote{\Commonality attributes and references}
In addition to manifestations, a \commonality defines features, i.e., attributes and references, which represent the information shared by several manifestations, as well as their relations to information defined in the manifestations.
Attributes only need to be identifiable by a name, whereas references, in addition, need to define the type they reference.
This type has to be a \commonality again, such as the methods reference of a class referencing the \commonality \texttt{ObjectOrientedDesign:ClassMethod} in \autoref{lst:language:class_example}.

\mnote{Attribute and reference relations}
While those attributes and references only define the structure of the \commonality and the \conceptmetamodel it belongs to, the relations defined within them express how attributes and references are represented in the manifestations.
Reference and attribute relations consist of an operator and operands.
The operator defines how the \commonality attribute or reference is related to features of the manifestations or other literal values, which are passed to the operator as operands.
For example, the name attribute of the component \commonality in \autoref{lst:language:component_example} is related to the name of a class in object-oriented design by a \emph{prefix} operator, which takes both the class name as well as an \enquote{Impl} string as operands.
That operator expresses that the name of the component \commonality is the prefix of the given class name removing \enquote{Impl}.

\mnote{Operands and direction of relations}
In comparison to manifestation conditions, attribute and reference relations only have one set of operands, because the element for which the relation is defined is implicitly given by the \commonality attribute or reference, whereas a manifestation condition must explicitly define which \metaclass or feature it belongs to.
Analogous to manifestation conditions, they do, however, define a direction.
For example, in \autoref{lst:language:component_example}, the relation between the name of the component \commonality and the name of the class in object-oriented design is defined to be bidirectional (denoted with a \enquote{=}), which means that changes of the both elements are propagated to the other.
The component name is also related to the package name, in which the class in object-oriented design is contained.
This relation is, however, defined as an \emph{enforce} relation, such that the package name is enforced whenever the name of the component changes, but a modification of the package name does not lead to any changes of the component name.

\lstinputlisting[language=Java, float,
    caption={[Implementation of a prefix operator for \commonalities]An implementation of the prefix operator for \commonalities as used in the prototypical implementation of the \commonalities language. The operator is derived from an abstract implementation for operators relating attributes to attributes. The generic type parameters denote the attribute types in the \commonality as well as in the manifestation. Adapted from the \vitruv code repository~\owncite{vitruvCBSEGithub}.},
    captionpos=b,
    label=lst:language:prefix_operator,
]{listings/quality/language/prefix_operator.lst}

\mnote{Implementation of operators}
Whenever a relation is defined as bidirectional, the operator needs to define how changes are propagated in both directions, i.e., how to update the \commonality attribute or reference among changes in any of the operands and how to update the operands whenever the \commonality attribute or reference is changed.
Our prototypical implementation allows to define such operators in Java code.
They need to be derived from a common interface to dynamically extend the language.
Each operator needs to implement methods for being applied towards the \commonality as well as towards the manifestation.
\autoref{lst:language:prefix_operator} depicts the implementation of the mentioned prefix operator.
It is initialized with the suffix to remove, such as the \enquote{Impl} suffix to remove from a class name to get the component name in our example.
The operator application towards the manifestation simply concatenates the given prefix and suffix, such that in the example \enquote{Impl} is appended to the component name.
Towards the \commonality, the operator checks whether the given name ends with the specified suffix and then returns the according prefix.
The operator is implemented such that it returns the given name whenever it does not have the defined suffix.
This is sufficient in the example, because in that case the \commonality is deleted anyway because of the manifestation condition.
In general, it may also be useful to define different behavior, such as throwing an error, asking the user for some decision about the name, or even mechanisms to reject the change.

\mnote{Contradictions of operator directions}
Since both application directions of the operator need to be implemented individually, a developer can implement contradicting behavior in both directions.
This can result in an incorrect transformation, because the consistency relation implied by a \commonality with an attribute or reference relation with such a faulty operator may be empty, as the relations encoded into the different operator directions can never be fulfilled at the same time.
To avoid this, it can be beneficial to derive the implementation of both directions from one specification of the relation, like in declarative transformation languages such as \qvtr or the \mappings language.
Especially for the latter one, \citeauthor{kramer2017a} has already proposed a methodology for defining unidirectional conditions and deriving the other direction, whenever possible~\cite[Sec. 7.4]{kramer2017a}.
In addition, he proposes a set of useful operators for defining consistency relations between elements~\cite[Sec. 7.3]{kramer2017a}.

\mnote{Compatibility of \commonalities}
Finally, operators should only employ information provided by its operands.
They should especially not use further feature of given elements or even traverse the model to retrieve further elements.
If this is the case, the graph induced by the relations between features of \commonalities and their manifestations defined through the operands represents the graph of consistency relations, which we have employed in \autoref{chap:compatibility} to define and analyze compatibility of consistency relations.
Thus, if this induced graph forms a tree, according to \autoref{def:relationtree}, the consistency relations are inherently compatible according to \autoref{theorem:treecompatibility}, as we have aimed to achieve with the construction approach of \commonalities, as proposed in \autoref{chap:improvement:commonalities:tree}.


% Implemented operators:
% * Attribute mappings operators: Mappings between attributes
% * Attribute reference operators: Mappings between attributes that serve as references, e.g., subpackages in UML and concept metamodel as explicit references whereas encoded as namespace attributes in classes in Java -> namespace attribute of Java class is mapped to package structure in UML
% * Condition operators

% \begin{copiedFrom}{VoSE}

% \section*{Language Description}

% As introduced before, our realization of the \commonalities language
% %for the previously explained \commonalities approach
% provides an internal concept definition and uses the \conceptmetamodels as additional metamodels in the operationalization.
% An example for the syntax of the \commonalities language is depicted in \autoref{lst:quality:commonalities_language_example}.

% % \begin{figure}
% %     \centering
% %     \todo{Potentially extend running example so that references are covered. At least, we do not have the package in the example}
% %     \includegraphics[width=\columnwidth]{figures/commonalities_language_example.PNG}
% %     \caption{An example for defining the common concept of components}
% %     \label{fig:commonalities_language_example}
% % \end{figure}

% % \lstinputlisting[language=commonalities, float, belowskip=-0.8 \baselineskip,
% %     caption={[Exemplary commonality for components]An exemplary specification of the \texttt{Component} \commonality between \gls{PCM}, UML and the object-oriented design concept in the \commonalities language},
% %     captionpos=b,
% %     label=lst:quality:commonalities_language_example,
% % ]{listings/quality/commonalities_language_example.lst}

% The language allows to define \conceptmetamodels by declaring \commonalities, each representing one commonality between different manifestations, such as the \texttt{Component} \commonality in our example.
% Relations between the \conceptmetamodels and their manifestations are supposed to be specified \emph{declaratively}.
% %, which is realized as a \metaclass in the \conceptmetamodel.
% For every \commonality, the \metaclasses in the manifestations that realize them are specified.
% In the example, the \texttt{Component} in \gls{PCM} and the \texttt{Class} in the object-oriented design \conceptmetamodel are %defined as representations of
% related to the \texttt{Component} \commonality.
% In our language, a \commonality is realized by a \metaclass in the metamodel that is generated for a concept, so the \texttt{Component} \commonality is realized by a \texttt{Component} \metaclass.

% Within a \commonality, attributes and references can be defined, similar to an ordinary \metaclass.
% The relations of an attribute to the manifestation are declared directly at the attribute.
% In the example, a \texttt{name} attribute is specified, which maps to the name of the component in \gls{PCM} and the name appended with an \enquote{Impl} suffix in Java.
% The language %defined by \textcite{gleitze2017a} 
% provides several operators for attribute relations, apart from equality relations.
% The example depicts a prefix operator that allows to compose a String attribute.
% Such operators can be defined independently and added to the language dynamically.
% References can be defined comparably to attributes but can be enriched with a definition of containment relations.

% % Introduce the idea of \enquote{Concepts} and \enquote{Commonalities}, explain how attributes and references are mapped.
% % \todo{We have to align the definition of Concept, Commonality etc. in the paper with the implementation}

% The actually conceptualized and implemented language by \textcite{gleitze2017a} is far more sophisticated than the simple overview we provide here. 
% It supports different kinds of bidirectional operators for attribute mappings, containment specifications (so-called \emph{participations}), attribute checks as preconditions for \commonality instantiation, and more.

% \end{copiedFrom} % VoSE
