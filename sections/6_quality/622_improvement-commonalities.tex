\section{The \commonalities Approach}
\label{chap:improvement:commonalities}

\mnote{Approach overview}
We have motivated the idea of representing common concepts of redundantly or dependently represented elements of different metamodels in terms of \commonalities in explicit \conceptmetamodels rather than implicitly encoding them in direct consistency relations between the metamodels.
In the following, we discuss the specification of \conceptmetamodels and the notion of manifestation relations in more detail.
We also depict how further benefits can be generated by composing \conceptmetamodels in terms of defining a hierarchy of them.
We call this approach of defining and composing \conceptmetamodels of \commonalities the \emph{\commonalities approach}.
Essential for the central benefit of this approach, which is mitigation of trade-offs between quality properties of transformation networks, is the inherent possibility to achieve a specific kind of tree topology, which we derive from the approach before discussing different options for its operationalization.


\subsection{Concept Metamodels}

\mnote{Structure of metamodels}
The inherent benefits of the \commonalities approach are given by the definition of additional \conceptmetamodels, across which consistency relations are expressed, instead of defining consistency relations between the \concretemetamodels.
How these \conceptmetamodels and the manifestation relations between them and the \concretemetamodels look like is not that relevant.
Still, we discuss how elements can represented as \commonalities in a \conceptmetamodel and which situations instead of pure redundancies representing exactly the same information as in the manifestation can exist.

\begin{figure}
    \centering
    \input{figures/quality/improvement/multiple_commonalities_example.tex}
    \caption[Multiple \commonality example for object-oriented design]{\Conceptmetamodel for object-oriented design with a \texttt{Class}, an \texttt{Association} and a \texttt{Package} \commonality and its relations to the \concretemetamodels \gls{UML} and Java with a different representation of associations as fields and packages as attributes of classes in Java.}
    \label{fig:improvement:multiple_commonalities_example}
\end{figure}

\mnote{Representation of packages}
\autoref{fig:improvement:multiple_commonalities_example} depicts an extension of the example given in \autoref{fig:improvement:one_commonality_example}.
In addition to classes, it contains the representation of packages and associations.
A package is represented as a dedicated \metaclass in \gls{UML}, which references the classes contained in that package.
Java, however, does not have an explicit representation of packages, but encodes them into the package names specified within classes and, additionally, represents them in a folder structure in which the source code files of the classes are persisted.
A \conceptmetamodel used to preserve consistency between packages represented in \gls{UML} and Java must represent this information in any way such that changes in Java code can be propagated into a \gls{UML} model to preserve their consistency and vice versa.
To sketch an extreme, this could even be achieved with some string attribute in the \conceptmetamodel that encodes this information in such a unique way that the necessary information for both instances of the \concretemetamodels can be generated.
Actually, a \conceptmetamodel should represent such information in a reasonable structure, whose concrete characteristics have to be defined the transformation developer.
For packages, either the representation in Java as attributes of classes or the representation in \gls{UML} as a dedicated \metaclass can be chosen.
In the given example, we define packages in the \conceptmetamodel as explicit \metaclasses, as this makes the containment structure of classes in packages explicit.
In addition, in the complete \gls{UML} and Java metamodel packages are represented hierarchically, which is also easier to express as a relation between dedicated elements rather than their implicit encoding in the package names of classes.

\mnote{Representation of associations}
Associations in \gls{UML} are used to define that classes are related to each other.
Each association defines two classes, denoting from which class to which class the association is defined.
Java does not provide an explicit representation of associations, which usually results in their implicit representation as fields of the class from which the association is defined and having the type of the class to which it is defined.
In the example, we have chosen to represent an association explicitly in the \conceptmetamodel.
Fields can, in the complete Java and \gls{UML} metamodels, be related to further elements than associations, thus having this distinction within the \conceptmetamodel gives it more semantics.
In addition, we have chosen to have the class from which the association is defined reference the association instead having this reference in the opposite direction as in the \gls{UML} metamodel.
No matter whether or not this is beneficial, still all necessary information to keep Java fields and \gls{UML} associations consistent is represented by the \conceptmetamodel.
It shows that for the \conceptmetamodel even a representation that differs from all its manifestations can be chosen.

\mnote{General rule for \conceptmetamodels}
As mentioned before, the only requirement to a \conceptmetamodel is that it must be able to represent all information that is necessary for defining manifestation relations to the \concretemetamodels, such that they are able to preserve consistency according to some consistency relation between the \concretemetamodels.
A general, but rather informal rule, which has proven to be beneficial in the implementation of a case study for our evaluation, is to select among different representation options the semantically richest.
In the example, we have thus chosen to represent packages explicitly instead of implicitly encoding them in package names of classes.
This improves expressiveness of the \conceptmetamodel and makes its information easier to use for defining manifestation relations without interpreting implicitly encoded information in each of these relations.


\subsection{Composition of Concepts}

\mnote{Multiple \commonalities}
We have so far discussed the idea of defining an additional \conceptmetamodel to represent the common concepts of two or more \concretemetamodels.
For the depicted example for Java and \gls{UML}, it seems reasonable to define the group the common concepts in object-oriented design in such a metamodel.
In \autoref{fig:improvement:running_example}, we have also considered \gls{PCM} components and their consistency relations to classes in \gls{UML} and Java.
Although we could define a component \commonality for \gls{PCM} components and classes in \gls{UML} and Java, and consider this \commonality next to the class \commonality for classes in \gls{UML} and Java, we will likely not do so because of several drawbacks.
First, a component \commonality does, semantically, not fit into the discussed \conceptmetamodel for object-oriented design. Thus, the \conceptmetamodel would have to be considered broader, potentially only as a generic \conceptmetamodel.
Second, and more importantly, such a construction would introduce further redundancies, as the relation between classes in \gls{UML}and Java is expressed via two \commonalities, once the class \commonality and once the component \commonality.

\mnote{Monolithic \commonalities}
To solve the problem of a redundant specification of the relation between classes in \gls{UML} and Java via class and component \commonalities, we could combine these two \commonalities to a single one, representing all necessary common information.
If, however, further elements share information with classes and components, they also have to be merged into the same \commonality.
In the extreme case, this could result in only having one large \commonality that is able to represent all related information.
The manifestation relations would then have to make all kinds of distinctions based on the information given in such a \commonality.

\mnote{Exemplary \commonality hierarchy}
An intuitive solution for the example scenario is to not consider classes in \gls{UML} and Java as manifestations of a component \commonality, but to consider the class \commonality as a manifestation of the component \commonality.
Then the relation between classes in \gls{UML} and Java is still represented across one specific class \commonality, whereas the manifestation relation of the component \commonality only has to be defined for the concept of classes instead of their concrete manifestations.

\begin{figure}
    \centering
    \input{figures/quality/improvement/composed_commonalities_example.tex}
    \caption[Hierarchic composition of \conceptmetamodels]{\Conceptmetamodels for component-based and object-oriented design and their manifestation relations between each other and to \concretemetamodels for the example introduced in \autoref{fig:improvement:running_example}. Adapted from \owncite[Fig.~3]{klare2019models}.}
    \label{fig:improvement:composed_commonalities_example}
\end{figure}

\mnote{Hierarchic composition of \commonalities}
Abstracting from this concrete example, we propose to define hierarchies of \commonalities and \conceptmetamodels, such that a manifestation of a \commonality must not necessarily be some classes of a \concretemetamodel, but can also be \commonalities of other \conceptmetamodels.
We depict such a structure for the example of classes and components in \autoref{fig:improvement:composed_commonalities_example}.
This allows to define one \conceptmetamodel for each kind of concept, such as object-oriented design or component-based design, and then compose these concepts hierarchically.
In consequence, this avoids the specification of a single \conceptmetamodel that may be become unmanageably large and again suffers from bad modularity as it needs combine information from as many \concretemetamodels as are supposed to be kept consistent.

\mnote{Restriction to tree topology}
Since constructing such hierarchies induces a tree topology between the concrete and \conceptmetamodels, this construction suffers from the drawbacks regarding completeness, which we have already discussed in \autoref{chap:classification:topologies:effects}.
Given two concrete or \conceptmetamodels, there must be one that can be considered the manifestation of the other, or it must be possible to define a \conceptmetamodel for them, such that finally a tree of concrete and \conceptmetamodels is achieved.
First, this is actually an assumption and thus limitation of the approach, for which we provide preliminary results regarding applicability in our evaluation in \autoref{chap:commonalities_evaluation}.
Second, we further discuss these requirements regarding a tree structure in the following subsection to relax the restriction currently defined at the level of metamodels and consider a more fine-grained restriction at the level of \metaclasses.


\subsection{Tree Topology}

\begin{figure}
    \centering
    \input{figures/quality/improvement/extended_composed_commonalities_example.tex}
    \caption[Example for tree topology of \commonalities]{\Conceptmetamodels for component-based and object-oriented design and their manifestation relations between each other and to \concretemetamodels for the example introduced in \autoref{fig:improvement:running_example} and extended by components in \gls{UML}. Adapted from \owncite[Fig.~3]{klare2019models}.}
    \label{fig:quality:extended_composed_commonalities_example}
\end{figure}

Discuss that metamodel borders are virtual.
Refer to non-interference of Stevens.


\subsection{Operationalization}



\begin{copiedFrom}{DocSym} % ABOUT TREES

The most crucial part of this approach is the necessity to build a tree of \glspl{CMM}.
This will not be possible if always considering whole metamodels and their relations, but can be possible if independent concepts are extracted to be treated individually.
%For that, we will apply our findings on consistency relation decomposition (see \autoref{chap:improvement:approach}).
%This is similar to decomposing consistency relations, as introduced in \autoref{sec:approach:decomposition}, which is why we will apply our findings therefrom.
Additionally, the approach specifically aims to improve the specification of transformations for descriptive relations.
In consequence, it must be combined with transformations expressing the normative relations between \glspl{CMM} and other metamodels.

\end{copiedFrom} % DocSym


\begin{copiedFrom}{VoSE}

% The state-of-the-art approach to keep models consistent automatically is the application of transformation languages.
% If instances of multiple (i.e., more than two) metamodels are to be kept consistent, one can either use multidirectional transformation approaches, or compose bidirectional transformations to a network of transformations~\cite{cleve2019dagstuhl}.
% Following sentence moved to introduction
%Such a network can be regarded as a graph, formed by metamodels as its nodes and transformations as its edges.
% When an instance of one metamodel is changed in such a network, the transformations are executed successively to propagate the change transitively across all models.
% There are strategies to find one ordering of transformations to apply~\cite{stevens2020BidirectionalTransformationLarge-SoSym} and strategies to perform a fixpoint iteration until no further changes are conducted~\cite{klare2019icmt}.

% %Short introduction of transformation network, what nodes and edges are and so on.
% In this section, we propose a different approach for keeping two or more models consistent by specifying their common concepts rather than their direct consistency relations.
% This forms our contribution~\autoref{contrib:quality:improvement}.
% % \subsection{Defining Consistency Relations}
% % Different metamodels provide

% Consistency relations are usually defined declaratively (what constraints have to hold) or imperatively (how are constraints enforced) between two (or sometimes more) metamodels.
% This is a definition of when instances of that metamodels are considered consistent.
% Consistency constraints can be either \emph{declarative} or \emph{normative}. Declarative constraints exist (e.g. because they are somehow \enquote{natural} and have to be formalized to be checked or preserved by a tools. Normative constraints do not have to adhere to an existing notion of consistency and thus implicitly define what is considered consistent.
% In our running example, the constraints between UML and Java exist and only have to be specified in a declarative manner.
% On the other hand, the constraints between architecture and OO design (i.e. PCM and UML/Java) were normatively defined by \textcite{langhammerconstraints}. There is no single correct mapping between architecture and OO design but several possible.





% \subsection*{Composing \commonalities}

% We have explained how multiple metamodels can be kept consistent using one \conceptmetamodel.
% This allows, theoretically, the definition of one large \conceptmetamodel that contains all \commonalities for all \concretemetamodels.
% It would at first sight be similar to a \gls{SUMM}, as introduced by \textcite{atkinson2010a}.
% However, it would be less complex than a \gls{SUMM}, which is able to express all information about the software system and thus contains the union of all \concretemetamodels.
% %In fact, the resulting \conceptmetamodel would be comparable to a \summ according to \textcite{atkinson2010a}, which is able to express all information about the software system, whereas the instances of the \concretemetamodels would only serve as projectional views that do not provide further information.
% Nevertheless, one large \conceptmetamodel would still become unmanageably large due to the fact that it had to contain the union of all pairwise intersections of the \concretemetamodels, as mentioned before.

% \begin{figure}
%     \centering
%     \input{figures/quality/composed_commonalities_example.tex}
%     \caption[Concept metamodels for the running example]{\Conceptmetamodels (dark) and their relations to \concretemetamodels (light) for the running example.}
%     \label{fig:quality:composed_commonalities_example}
% \end{figure}

% To avoid the specification of such a monolithic \conceptmetamodel, we propose to compose \commonalities from different \conceptmetamodels.
% Instead of having only \commonalities that relate to \metaclasses in \concretemetamodels, \commonalities may also have relations to other \commonalities.
% Consider the \conceptmetamodel for component-based design in \autoref{fig:quality:composed_commonalities_example}.
% It contains the \commonality \texttt{Component}, which is represented by an equally named \metaclass in \gls{PCM},
% as well as in the \commonality \texttt{Class} in the \conceptmetamodel for object-oriented design, conforming to the relations proposed by \textcite{langhammer2015a}.
% This induces a tree structure with \commonalities as inner nodes and \metaclasses of \concretemetamodels as leaves.
% With such a composition structure, a \emph{«manifests»} relation may not only exist between a %concrete and a concept metamodel but also between two \conceptmetamodels.
% \commonality of a \conceptmetamodel and a \metaclass in a \concretemetamodel but also between two \commonalities.
% However, a concrete or \conceptmetamodel that is lower in the hierarchy is supposed to represent how a \metaclass or \commonality in the higher one manifests, which is why we call it a \emph{manifestation}.
% %Due to that, we call concrete and \conceptmetamodels that contain \metaclasses or \commonalities with a \emph{«manifests»} relation to another \conceptmetamodel a \emph{manifestation} of that \conceptmetamodel.
% For example, the object-oriented design \conceptmetamodel is a manifestation of the component-based design \conceptmetamodel.

% \begin{figure}
%     \centering
%     \input{figures/quality/extended_composed_commonalities_example.tex}
%     \caption[Concept metamodels in the running example]{\Conceptmetamodels (dark) and \concretemetamodels (light) of the running example, extended by UML components, with their relations.}
%     \label{fig:quality:extended_composed_commonalities_example}
% \end{figure}

Our goal is to achieve a tree structure of commonalities. In the extended example in \autoref{fig:quality:extended_composed_commonalities_example}, a \texttt{Component} in the \conceptmetamodel for component-based design does not only manifest in a \gls{PCM} \texttt{Component} as well as a \texttt{Class} in object-oriented design, but also in \gls{UML}.
Since a \texttt{Class} in object-oriented design manifests both in Java and \gls{UML}, we do not have a tree structure of the induced relations between the metamodels anymore, due to \texttt{Class} and \texttt{Component} both being represented in \gls{UML}.
However, This still induces a tree structure between \metaclasses and \commonalities, with the \commonalities being inner nodes and \metaclasses of \concretemetamodels being leaves.

%
% How are Commonalities composed to keep multiple models consistent? What about overlaps?
% Apply to OO and PCM case
%
% \begin{figure}
%     \centering
% %    \includegraphics[width=\columnwidth]{figures/dag_example.pdf}\\
%     \input{figures/quality/dag_example.tex} %\\[1em]
%     %\input{figures/dag_example_alternative.tex}
%     \caption{\Concretemetamodels (light) and \conceptmetamodels (dark) of the running example forming a \acs{DAG}}
%     \label{fig:quality:dag_example}
% \end{figure}

%Since we only assume a tree of \commonalities,  rather than a tree of \conceptmetamodels, 
A metamodel may have several \commonalities in different \conceptmetamodels with different other metamodels.
For example, in \autoref{fig:improvement:composed_commonalities_example}, the UML metamodel contains a \texttt{Class} and a \texttt{Component} \metaclass, which have two different \commonalities in two different \conceptmetamodels.

%We currently assume that all concept metamodels and relations to their manifestations can be represented as a tree.
% In general, %, this will not be possible, 
% the assumption of having a tree of \conceptmetamodels may not be satisfiable if
% metamodels have several \commonalities with different metamodels.
% In fact, we can relax that assumption: 
% The essential requirement is that each change is only propagated across one path between two models, which is inherently given in a tree.
% If the \commonalities of two \conceptmetamodels manifest in disjoint sets of elements of the same manifestation, that manifestation can be---virtually---separated into two metamodels, for which the network forms a tree again.
% In consequence, if we consider the transformations as directed edges from a \conceptmetamodel to its manifestations, we only have to require a \ac{DAG}, % induced by these edges, 
% as long as the manifestations of all \commonalities are disjoint.
% %If we consider the transformations as directed edges from a \conceptmetamodel to its manifestations, we only have to require a \ac{DAG} induced by these edges, as long as the \conceptmetamodels represent disjoint sets of elements of their manifestations.
% %This relaxation is possible due to the fact that the essential requirement is to have only one path between two models across which a change can be propagated.
% %If different \conceptmetamodels relate to disjoint parts of their manifestations, these manifestations can be virtually separated into different metamodels, which then form a tree again.
% \autoref{fig:dag_example} exemplifies this relaxation: % on our running example:
% If the UML is also considered a manifestation of component-based design by providing the \texttt{Component} \metaclass, the network does not constitute a tree because of the relations between the UML and the \conceptmetamodels for component-based design and object-oriented design.
% However, it forms a \ac{DAG} and the redundant paths to the UML metamodel are unproblematic, because the relation to object-oriented design affects the part of the UML metamodel considering classes (\emph{Class}), whereas the relation to component-based design affects the part of the UML metamodel considering components (\emph{Comp}). 
% The elements in these parts of the UML metamodel are disjoint.

\subsection*{Transformation Operationalization}
\label{chap:commonalities:approach:operationalization}

To actually keep models consistent, the specification of a hierarchy of \conceptmetamodels has to be operationalized.
Two options for operationalization can be distinguished:

\begin{description}[leftmargin=\parindent]
    \item[\Conceptmetamodels as additional metamodels:] The \conceptmetamodels are actually instantiated and the transformations are executed as they are defined between the \conceptmetamodels and their manifestations. In consequence, instances of the \conceptmetamodels have to be maintained.
    \item[Transformations between \concretemetamodels:] The \conceptmetamodels and the relations between them and their manifestations are used to derive bidirectional transformations between the \concretemetamodels. For example, from the \conceptmetamodel for object-oriented design in \autoref{fig:improvement:one_commonality_example}, a bidirectional transformation between Java and UML is derived.
\end{description}

A drawback of the first option is that additional models have to be managed and persisted. 
In consequence, the user has to version these models although they should be transparent to him or her, as long as no appropriate framework abstracts from such tasks.
%Additionally, it is not easily possible to derive the direct relations between two concrete metamodels from such a specification. For example, the direct relation between classes in UML and Java is not accessible but only implicitly expressed by the transitive relation across the concept metamodel for object-oriented design.
A drawback of the second option is that the types of supported relations that can be described in the transformations are limited.
First, only relations may be defined that can be composed with any other relation, such that a direct transformation between two metamodels can be derived.
Second, it is possible to define $n$-ary relations between more than two metamodels that cannot be decomposed into binary relations between them, but only into $n$ binary relations between those metamodels and an additional one~\cite{stevens2020BidirectionalTransformationLarge-SoSym}.
In consequence, the first option provides higher expressiveness.

While the first option can be realized without an additional language by just defining the \conceptmetamodels and the transformations with existing languages, the second option requires a mechanism that generates the transformations between the \concretemetamodels from those between the \conceptmetamodels and their manifestations.

\end{copiedFrom} % VoSE