\section{Properties of Transformation Networks}

\mnote{Further functional properties}
The most essential property of transformation networks, which we have also considered in the last chapters, is correctness, or more precisely \emph{functional correctness}, according to ISO standard 25010~\cite{iso25010}.
In addition to its correctness, functionality can be regarded in terms of completeness and appropriateness~\cite{iso25010}.
While completeness is concerned with the degree to which functions cover all intended objectives, appropriateness is the degree to which functions facilitate the conduction of tasks to achieve the intended objectives.
In terms of a transformation network, completeness means whether the network is able to preserve all consistency relations, which requires transformations for all existing relations to keep consistent to be defined.
In contrast, appropriateness is not that relevant, at least in cases in which the process is fully automated. Appropriateness would especially be of interest if the user is involved in the consistency preservation process by clarifying its intent or making necessary decisions to complete models for being consistent, which can influence how far the automation facilitates the process of consistency preservation.
Thus, in addition to functional correctness we also discuss functional completeness as a relevant property and relate it to our requirement of \emph{universality}, defined in \autoref{chap:introduction}.

\mnote{Quality properties regarding maintainability}
In our work, we focus on properties of transformation networks that are relevant for their developers~\autoref{chap:introduction:objective:benefits}.
Thus, in addition to functional properties of such networks, we especially consider properties regarding their maintainability~\cite[Tab.\ 2]{iso25010}, which describe the \enquote{degree of effectiveness and efficiency with which a product or system can be modified by the intended maintainers}~\cite[p.\ 14]{iso25010}.
Maintainability includes the properties modularity, reusability, analyzability, modifiability and testability.
While have already implicitly covered the former to properties of modularity and reusability in our assumption of \emph{modular reuse}, as well as analyzability in the goal of \emph{comprehensibility}.


\subsection{Correctness}

\mnote{Central importance of correctness}
According to the ISO standard 25010~\cite{iso25010}, functional correctness describes to which degree a system, in our case a transformation network, provides correct results.
We have intensively discussed this property in the previous chapters, starting with a definition of \emph{correct results} in \autoref{chap:correctness} and discussing how to achieve transformation networks that fulfill such a correctness notion in \autoref{chap:compatibility} to \autoref{chap:orchestration}.
We do thus not discuss that property in detail again, but emphasize its central importance for a transformation network to be useful, as an incorrect transformation network leading to models of a system description that are inconsistent, in the worst case without informing the developer about it, will hardly provide relevant benefits.


\subsection{Completeness}

\mnote{Universality}
According to the ISO standard 25010~\cite{iso25010}, functional completeness describes to which degree provided functions cover all objectives.
Applied to transformation networks this means to which degree such a network preserves consistency to consistency relations, be they explicitly defined or only intended by a transformation developer.
Both completeness of the individual transformations as well as of the transformation are covered by their notions of correctness (see \autoref{def:synchronizingtransformationcorrectness} and \autoref{def:transformationnetworkcorrectness}).
It does, however, assume an even broader notion of what we introduced as \emph{universality} in \autoref{chap:introduction}.
While we have introduced universality as the ability to process transformation networks of arbitrary topology, an even broader notion would require the applicability of transformation network to every project in which artifacts need to be kept consistent.
Thus, it would first require that the artifacts to keep consistent are represented in a form that is required to define transformations between them.
More precisely, the artifacts to keep consistent need to conform to some kind of modeling formalism, such as the one we proposed in \autoref{chap:networks:models} based on the \gls{EMOF} standard~\cite{mof}.

\mnote{Non-modeled artifacts}
If the artifacts, or more generally the models, to keep consistent are not represented in a format conforming to such a modeling formalism, a metamodel for them needs to be defined and their representation may need to be transformed into an instance of such a metamodel.
This is especially the case for proprietary tools that do not use a common format to represent their artifacts.
For many popular tools, however, metamodels based on \gls{EMOF} or Ecore have already been reverse-engineered, such as 
MATLAB/Simulink~\cite{heinzemann2013Reconfiguration-CBSE,son2012Simulink-CAGGIE,armengaud2011Safety-WCE}.
In addition, \gls{EMF} as a popular modeling framework provides an importer for XML-based specifications of metamodels~\cite[pp.\ 86]{steinberg2009emf}.
Tools, especially from the engineering domain, often provide XML-based representations of their artifacts, such as the electronic circuit design tool EPLAN~\cite{eplan} or the exchange format for automation system design in AutomationML~\cite{automationML}.
Such a process is, however, necessary whenever modeling tools shall be applied, for which transformations for preserving consistency is only one example.
Frameworks for generating graphical editors or model analyses could be further tools to be applied~\owncite{klare2017models}.
Thus, such an integration of artifacts into model-driven processes is part of separate research.

\mnote{Integration approach}
We have also developed and proposed an approach to integrate artifacts into model-driven processes in our work~\owncite{klare2017models, klare2019modelsward}.
It is based on the insight that code often contain models implicitly.
The tools, whose artifacts we want to keep consistent, usually have definitions of metamodels of their artifacts defined within the code, but only as a simple structure of classes instead of a metamodel according to some modeling formalisms.
For example, Java graph libraries need to contain a metamodel for representing graphs, but this is usually just represented by a set of classes and not an explicit metamodel according to some modeling framework.
This also applies to programming languages, for which parsers contains metamodels for their \gls{AST} representations.
We have proposed an approach that makes these implicit metamodels explicit to apply metamodel-based tooling, such as transformations for consistency preservation, to them~\owncite{klare2017models, klare2019modelsward}.
Since that topic and especially that proposed approach is important for applying transformation networks, but also has further, broader application areas, we do not further discuss it here but refer to our previous work for details it.


\subsection{Maintainability}

\mnote{Influencing factors}
We have already identified maintainability as a dimension of quality properties with central importance for developers of transformations and transformation networks.
According to \cite{iso25010}, maintainability includes modularity, reusability, analyzability, modifiability and testability.
We discuss for these properties how they manifest in transformation networks and especially how they are related to each other.
We do not aim to measure these properties, which is why we do not proposed specific metrics for them.
It has been shown to be hard to assess quality of code, e.g., to measure modifiability in terms of a correlation with the number of defects~\cite{Gyimothy2005ValidationMetrics-TSE, Yu2002FaultPrediction-ECSMR}, and that only few metrics provide a correlation between to, for example, the number of defects.
In fact, we only aim at identifying the influencing factors for these properties instead of a measure for them anyway, especially with respect to topologies of the transformation network, which we discuss afterwards.

\begin{properdescription}
    \item[Modularity:] 
    Modularity is the degree to which a program, and thus also a transformation network, is composed of components such that changes only influence a part of it~\cite{iso25010}.
    This property is degraded by having multiple paths expressing the same relations, as then these paths depend on each other and may be contradictory. 
    Having such multiple paths can lead to incompatibilities (cf.\ \autoref{chap:compatibility}) or situations in which no consistent orchestration of the transformations exists (cf.\ \autoref{chap:orchestration}), thus such multiple paths degrade modularity.
    \item[Reusability:]
    Reusability is the degree to which assets, such as the single transformations of a transformation network, can be used in more than one system~\cite{iso25010}.
    In terms of a transformation network, reusability of a transformation is given if it is independent from the other transformation and can be used together with others in a different context.
    This conforms to our notion of independent development and modular reuse, given as assumptions in \autoref{chap:introduction}.
    Reusability profits from having all relations between the involved metamodels expressed explicitly, thus leading to multiple paths of transformations expressing the same relations.
    In that case, subsets of the transformations can be used in a different context, in which only a subset of the metamodels is used, as transformations can directly be reused and do not rely on transitively expressed relations.
    For example, having the relation between \gls{PCM} and Java expressed directly instead of only expressing it transitively across \gls{UML} enables its reuse in other system development scenarios in which \gls{UML} is not used at all.
    Thus, reusability degrades with improved modularity.    
    \item[Analysability:] 
    Analysability is the degree to which the impact of a change can be assessed effectively and efficiently or to which defects can be identified afterwards~\cite{iso25010}.
    On the one hand, this is important for the single transformations, as analyzing the impact of a change especially concerns the intended change of the behavior of a transformation. That is, however, also a topic of dedicated research about transformation validation and verification~\cite{cabot2010VerificationInvariants-JSS, rahim2015SurveyTransformationVerification-SoSym, azizi2017ContractVerification-ICCKE, vallecillo2012FormalTesting-FMMDE}.
    On the other hand, this is important for the interplay of transformations, thus how a change to one transformation affects interoperability with the others.
    This is, again, directly related to the existence of multiple paths of transformations preserving consistency to the same relations, as this influences how many other transformations may be affected and potentially need to be updated due to the modification to one of them.
    Consequently, the more relations are preserved across multiple paths of transformations, the more transformations may be affected by a single change and introduce interoperability problems that may be hard to analyze (cf.\ \autoref{chap:orchestration}).
    Analyzability is also related to the notion of comprehensibility that we have introduced in \autoref{chap:introduction}. The lower analyzability is, the harder it becomes for a transformation developer to comprehend what the combination of transformations actually does and how an intended change can be performed and what its impact is.
    We have also used comprehensibility to motivate the design of our orchestration algorithm in \autoref{chap:orchestration:algorithm}, which is driven by the goal of easing the analysis of failures of the transformation network, analogous to analyzability.
    Thus, analyzability improves with modularity.
    \item[Modifiability:]
    Modifiability is the degree to which a system can be modified without introducing defects or degrading quality~\cite{iso25010}.
    It is directly influenced by modularity and analyzability, as also stated by the ISO standard~\cite{iso25010}.
    In terms of a transformation network this can include the adaptation of existing transformations or the extension of an existing network with further metamodels and transformations.
    The same arguments as for modularity and analyzability apply and thus modifiability improves and degrades with modularity of the transformation network.
    For example, the complexity of adding a new transformation, which is covered by modifiability, depends on the number of transformations that already, and in particular transitively, preserve relations between the two metamodels to define the new transformation between.
    \item[Testability:]
    Testability is the degree with which test criteria can be effectively and efficiently established and evaluated by test cases for a product~\cite{iso25010}, such as a transformation network.
    While there are many influencing factors for testability, such as encapsulation and coupling within the implementation, it is, again, also influenced by the number of paths across which consistency relations are defined.
    This is because the more paths of transformations preserving the same consistency relations exist, the larger is the set of models to be considered and transformations to be executed for testing correctness of preserving consistency according to a certain relation.
    This increases complexity of the tests to perform.
    Testability is also highly related to the notion of comprehensibility that we have introduced in \autoref{chap:introduction} and also discussed for the property of analyzability. 
    The higher the number of transformations that need to be executed to detect a failure, the more complex we can expect the process of identifying the causing mistake to be (cf.\ \autoref{chap:errors}).
    Testability just like analyzability and modifiability thus improves with modularity.
\end{properdescription}

\mnote{Opposed properties}
The discussion shows that the existence of multiple paths of transformations preserving consistency to the same consistency relations reduces modularity, modifiability, analyzability and testability, while improving reusability.
This is due to the fact that multiple representations of the same consistency relations induce dependencies, which reduce modularity, and can contain conflicts, reducing modifiability.
The increased complexity reduces analyzability and testability.
Reusability is, however, improved, because relations are not only represented transitively.
In the following, we identify relevant topologies of transformation networks, which reflect the effects on properties of having multiple transformation paths preserving consistency to the same relations, and discuss their impact on properties.

%Modularity is degree to which a program is composed of components such that changes only influence a parts.
%This fits to our needs, because if we have a dense graph, modularity is low, as a change in one transformation may affect several others that need to be changed to restore compatibility and correctness.


% \begin{copiedFrom}{DocSym}

% %Even if independently developed transformations are interoperable, as discussed before, higher-level challenges remain when considering the way in which transformations express relations or occur if compatibility between the transformations is not given.
% %Those challenges cannot be solved simultaneously, but induce trace-off decisions that have to be made regarding the way in which transformations are specified. %, as not all of them can be solved simultaneously.
% %Depending on the topology of transformations that preserve the consistency, those challenges are addressed differently, which will be discussed afterwards. %in the subsequent section.
% %We present already identified challenges in the following. % and discuss them regarding the combination of binary transformations. % as the state-of-the-art for multi-model consistency preservation.

% % \compactsubsection{Uniqueness}
% % Each consistency relation should only have to be specified once to reduce effort and the risk of contradictory specifications.
% % In terms of transformations, this means that there should only be one path in the graph induced by the transformations to propagate information from one model to another.
% % Using existing transformation languages, not knowing which relations have already been realized in which transformations can lead to duplication.
% % This is especially the case, if one transformation is only the subsumption of others, like in \autoref{fig:binary_combination_example}. %of components and classes defined by
% % %mapping \ac{PCM} to \ac{UML} components, \ac{UML} components to \ac{UML} classes, and those classes to Java classes. 
% % \todo{Das folgende ist eigentlich schon im vorigen Abschnitt diskutiert worden}
% % If the relation \ref{fig:Example:R3} between \ac{ADL} and Java is specified additionally to the transitive relation over \ac{UML}, the transformations derived from it must ensure that after creating an \ac{ADL} component only one Java class is created, that all necessary trace links are created, and that additional constraints, such as the convention to append \enquote{Impl} to the name, are consistently defined.

% \begin{properdescription}
% \item[Compatibility:]
% Transformations preserve consistency, but also have to be consistent among themselves, i.e., they have to adhere to the same consistency relations, referred to as \emph{compatibility}.
% %Contradictory specifications can, for example, arise from inconsistent realizations of the same consistency relations.
% If, in our example in \autoref{fig:introduction:scenario_topologies}, the relation %\ref{fig:prologue:binary_combination_example:R3} 
% between \gls{ADL} and Java is realized in addition to the transitive relation %$\mbox{\ref{fig:prologue:binary_combination_example:R1}} \concat \mbox{\ref{fig:prologue:binary_combination_example:R2}}$ 
% over \gls{UML}, both relations must contain the same name attribute mapping.
% If the \gls{ADL} to Java transformation adds an \enquote{Impl} suffix~\cite{langhammer2017a}, whereas the transformations over \gls{UML} omit that, they are \emph{incompatible}.
% This can lead to propagation cycles due to alternating values, and to results depending on the transformation execution order. %depends on the transformation execution order. %, which means that the result depends on the execution order of the transformations. % (e.g. the propagation from \ac{PCM} to Java or from \ac{UML} to Java), the result differs (in the example the name of the class)
% %\end{inparaenum}
% While \emph{compatibility} concerns problems due to the realization of contradictory consistency relations, %the realization of the same consistency relations by different transformations, 
% \emph{interoperability} concerns potentially unexpected behavior although all transformations follow to the same consistency relations.
% %\todoErik{Ich finde diese Numerierungen immer ein bißchen affig, wenn man sich später nicht auf die Zahlen bezieht. \enquote{On the one hand \ldots on the other hand} sagt dasselbe aus.}
% %A direct implication of inconsistent specifications is the non-uniqueness of the specifications.


% \item[Modularity:]
% The development of different systems requires the usage of different metamodels to describe them.
% %One benefit of binary transformations is that they can be reused in different projects and especially different contexts with different selections of metamodels.
% Therefore, transformations should be modular, so that an arbitrary selection of metamodels and transformations between them can be used within a concrete project.
% If, in our example, transformations are specified transitively across \gls{UML}, it is impossible to use only the \gls{ADL} and Java in a concrete project, omitting the \gls{UML}. 
% %This property is especially contradictory to the \emph{uniqueness} property when using transitively executed transformations.

% \item[Comprehensibility:]
% Maintainability of software development artifacts, including transformations, depends on their comprehensibility.
% Comprehensibility can be seen as the number of transformations to consider if a specific consistency relation shall be understood.
% Realizing consistency relations in transitive transformations can, for example, reduce comprehensibility, as a developer has to consider a set of transformations to understand a single consistency relation. 
% %To ensure %\emph{uniqueness} and 
% %transformation consistency %require consistency preservation to be only defined once between two metamodels, which
% %it can be necessary to define transitive transformations %across other metamodels 
% %to avoid redundant specifications.
% %This can reduce comprehensibility as a developer has to consider a set of transformations to understand a single consistency relation. %, which is why this is a contradictory challenge to those others.
% %\todoErik{Sie kann dadurch aber auch erhöht werden, weil die einzelnen Transformationen weniger komplex werden (divide et impera)} % Ja, das stimmt möglicherweise im Einzelfall. Aber dafür muss ein Transformationsentwickler im Allgemeinen auch potentiell wieder andere Domänen verstehen, was nicht so vorteilhaft ist.

% \item[Evolvability:]
% Whenever new transformations shall be defined, e.g. because a new metamodel shall be used and transformations for it have to be defined, the effort should be as low as possible.
% This concerns the number of transformations to define and how many metamodels are involved in the transformations for one consistency relation if it is expressed transitively.
% \end{properdescription}

% %\subsection{Trade-off Solutions}

% \end{copiedFrom} % DocSym

