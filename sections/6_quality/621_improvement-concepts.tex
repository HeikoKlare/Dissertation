\section{Consistency Relations as Common Concepts}

Modern %software and 
software-intensive systems are usually described by different \emph{models}, also considered as \emph{views}, such as code, architecture, deployment specifications and other role- or concern-specific models.
%\modified{Those models can also be considered as views of the system, which synthetically form the complete description of a system.}
Since all these models describe the same system, but focus on specific properties or use different levels of abstraction, they typically share information that is represented in the models redundantly, or at least induces dependencies between them.
Such redundancies have to be kept consistent to achieve a contradiction-free specification of the %software 
system.

But no matter how a transformation is defined, it specifies a \emph{relation} between two (or more) metamodels.
However, redundant elements are representations of a \emph{common concept} rather than independent elements that have to be directly related.
In consequence, we think that it is natural to make the common concept, which the redundant elements are supposed to describe, explicit. 
We can then specify how this concept manifests itself in the different metamodels, instead of defining directly how the redundant elements are related.
For example, %we assume that it is 
it appears to be more natural to say that classes in UML and Java are different manifestations of the concept of a class in object-oriented design, rather than saying that a UML class should be related to a corresponding Java class.
Such a common concept is what we call a \emph{\commonality}.




\subsection{Running Example}

\subsection{Explicit Commonalities}

\subsection{Descriptive Consistency Specifications}



\begin{copiedFrom}{VoSE}

\section*{Running Example}

We use a running example throughout the paper to explain the \commonalities idea.
It relies on three metamodels: UML class models, Java code, whose grammar definition can be treated as a metamodel~\cite{heidenreich2010a}, and the \gls{PCM}~\cite{reussner2016a}, a component-based architecture description language.
The consistency relations between Java and UML class models are mostly one-to-one mappings, as they provide the same concepts of object-oriented design. %provide redundant representations of the same concepts, so the consistency relations between them define mostly one-to-one mappings.
Consistency relations between \gls{PCM} and Java were proposed by \textcite{langhammer2015a}.
For this paper, only the one-to-one mapping between components in \gls{PCM} and classes in Java---or generally all object-oriented languages---are relevant, whereby each component is mapped to a class but not vice versa.

For the examples in this paper, a minimalist subset of those metamodels, depicted in \autoref{fig:quality:running_example}, is sufficient.
It only comprises classes in UML and Java and components in \gls{PCM}, which all have a name.
The name shall be equal between corresponding classes in UML and Java, whereas the classes realizing a component shall have the same name as the component, complemented by an \enquote{Impl} suffix (cf.~\cite{langhammer2015a}).
With state-of-the-art techniques, those constraints could be implemented as relations in declarative or as enforcing routines in imperative transformation languages.

\begin{figure}
	\centering
	\input{figures/quality/running_example.tex}
	\caption[Consistency relations for extracts of Java, UML and PCM]{Metamodel extracts for Java, UML and \gls{PCM} and consistency relations ({\protect\tikz[baseline=-0.5ex] \protect\draw[latex-latex, consistency related element] (0,0) -- (1.5em,0);}) between them}
	\label{fig:quality:running_example}
\end{figure}

In this paper, we consider metamodels that conform to the \gls{EMOF} standard~\cite{mof}.
Such metamodels consist of classes, which we denote as \emph{\metaclasses} to avoid confusion with classes in exemplary metamodels such as Java and UML.
\Metaclasses can in turn contain attributes and associations to other classes, which may be containments.
\subsection*{Making Common Concepts Explicit}

The redundancies between different metamodels are an expression of common concepts that are represented redundantly.
We already gave the example of a class in UML and Java, which are different representations of the common concept of a class in general object-oriented design.
We propose to make common concepts explicit rather than encoding them into the rules of a transformation.
This can be achieved by creating a \emph{\conceptmetamodel}, which defines those common concepts, and specifying the relations between the \conceptmetamodel and the existing metamodels.
We refer to the existing metamodels as \emph{\concretemetamodels}.
The relation specifications can be used to derive transformations between the \concretemetamodels and the \conceptmetamodel.

\autoref{fig:quality:commonalities_example} shows the \metaclasses for a \texttt{Class} as extracts of the \concretemetamodels for UML and Java and the \metaclass for the common concept of a \texttt{Class} in the \conceptmetamodel for object-oriented design.
We denote a single common concept as a \emph{\commonality}.
Further \commonalities in object-oriented design could, for example, be interfaces or methods.
The relation between the \texttt{Class} \commonality and its realizations in the \concretemetamodels are shown by a \emph{«manifests»} relation.
%Such a relation can be defined in a transformation.
In our simplified example, the relation would especially define that the names of the classes have to be equal. %an equality relationship.

\begin{figure}
    \centering
    \input{figures/quality/one_commonality_example.tex}
    \caption[Concept metamodel for object-oriented design]{\Conceptmetamodel for object-oriented design with a \texttt{Class} \commonality and its relations to UML and Java.}
    \label{fig:quality:commonalities_example}
\end{figure}

When another \concretemetamodel that represents the same concepts shall be added, it is only necessary to define its relation to the \conceptmetamodel.
For example, adding \cplusplus as another metamodel representing object-oriented design would require the definition of the relation between the \texttt{Class} \commonality in object-oriented design and its representation in \cplusplus.
Adding an additional metamodel may require the \conceptmetamodel to be extended by \commonalities that were not relevant for the already considered metamodels.
In general, a \conceptmetamodel has to contain \commonalities for redundancies in all \concretemetamodels, which---mathematically speaking---can be expressed as the union of all pairwise intersections of the \concretemetamodels.

% Short description of the Commonalities concept and application to example (UML and Java classes, could e.g. be extended by C++)
% Necessary artifacts: the Commonalities metamodel and the transformations.
% But: one can define a language to specify the Commonalities metamodel together with a specification of how the elements and properties manifest in the concrete metamodels, which we will explain in more detail in \autoref{sec:language}.
% Introduce terms: \emph{Commonality} (metamodel with common concepts), concrete metamodel (a metamodel that is accessed by a user) and \emph{Manifestation} (the concrete metamodels that realize a Commonality).


\subsection*{Making Common Concepts Explicit}

The redundancies between different metamodels are an expression of common concepts that are represented redundantly.
We already gave the example of a class in UML and Java, which are different representations of the common concept of a class in general object-oriented design.
We propose to make common concepts explicit rather than encoding them into the rules of a transformation.
This can be achieved by creating a \emph{\conceptmetamodel}, which defines those common concepts, and specifying the relations between the \conceptmetamodel and the existing metamodels.
We refer to the existing metamodels as \emph{\concretemetamodels}.
The relation specifications can be used to derive transformations between the \concretemetamodels and the \conceptmetamodel.

\autoref{fig:quality:commonalities_example} shows the \metaclasses for a \texttt{Class} as extracts of the \concretemetamodels for UML and Java and the \metaclass for the common concept of a \texttt{Class} in the \conceptmetamodel for object-oriented design.
We denote a single common concept as a \emph{\commonality}.
Further \commonalities in object-oriented design could, for example, be interfaces or methods.
The relation between the \texttt{Class} \commonality and its realizations in the \concretemetamodels are shown by a \emph{«manifests»} relation.
%Such a relation can be defined in a transformation.
In our simplified example, the relation would especially define that the names of the classes have to be equal. %an equality relationship.

\begin{figure}
    \centering
    \input{figures/quality/one_commonality_example.tex}
    \caption[Concept metamodel for object-oriented design]{\Conceptmetamodel for object-oriented design with a \texttt{Class} \commonality and its relations to UML and Java.}
    \label{fig:quality:commonalities_example}
\end{figure}

When another \concretemetamodel that represents the same concepts shall be added, it is only necessary to define its relation to the \conceptmetamodel.
For example, adding \cplusplus as another metamodel representing object-oriented design would require the definition of the relation between the \texttt{Class} \commonality in object-oriented design and its representation in \cplusplus.
Adding an additional metamodel may require the \conceptmetamodel to be extended by \commonalities that were not relevant for the already considered metamodels.
In general, a \conceptmetamodel has to contain \commonalities for redundancies in all \concretemetamodels, which---mathematically speaking---can be expressed as the union of all pairwise intersections of the \concretemetamodels.

% Short description of the Commonalities concept and application to example (UML and Java classes, could e.g. be extended by C++)
% Necessary artifacts: the Commonalities metamodel and the transformations.
% But: one can define a language to specify the Commonalities metamodel together with a specification of how the elements and properties manifest in the concrete metamodels, which we will explain in more detail in \autoref{sec:language}.
% Introduce terms: \emph{Commonality} (metamodel with common concepts), concrete metamodel (a metamodel that is accessed by a user) and \emph{Manifestation} (the concrete metamodels that realize a Commonality).
\end{copiedFrom} % VoSE


\begin{copiedFrom}{DocSym}

\section*{Making Common Concepts Explicit} 

% \subsection{Approach
%     \pgsize{1 p.}
%     \dl{16.06.2017}
%     \complete{0}}

%\todoConference{A description of the proposed solution and which other work (e.g., methods or tools) it depends on.}
%\todoHeiko{One Solution: Add additional models. Already proposed by Stevens, but just to solve constraints. Here, we make overlaps explicit}
%\todo{Referenz zu Aussage von Stevens hinzufügen}
%\todoHeiko{Discuss necessity to provide orthogonal concept metamodels}

%\todoHeiko{Why ''virtual``? Because they are transparent to the user and nothing he has to deal with}
%\todo{Referenz auf Grafik und Optimalfall davon erklären}
Based on the decomposition of consistency relations, we propose another approach to achieve a tree structure of transformations, which inherently optimizes \emph{modularity}.
%In the following, we propose another solution option to achieve a tree structure of consistency relations, next to decomposing consistency relations into independent subsets.
%This approach called \emph{\acp{CMM}} ensures consistency between specifications inherently given by the tree structure, but also optimizes modularity, so that an arbitrary subset of the metamodels can be used.
%It also reuses the concepts for decomposing consistency relations.
% In \autoref{sec:Introduction}, we discussed reasons for specifying consistency using binary transformations instead of defining multiary relations.
% Nevertheless, as discussed in the previous section, trade-off decisions regarding the identified challenges have to made with that approach.
% Therefore, we propose an approach called \emph{\acp{CMM}} for a certain kind of relations that addresses all those identified challenges.
The idea bases on the insight that we can distinguish two kinds of consistency relations:
\begin{description}[leftmargin=\parindent]
    \item[Descriptive consistency relations] are \enquote{naturally} given when two metamodels represent common \emph{concepts} %with common properties
    redundantly or at least with dependent properties. This is, for example, the case for \gls{UML} class models and Java realizing \gls{OO}. %, and for \ac{UML} component models and \ac{PCM} models realizing a component concept.
    %They have to be expressed by transformations in a way that they describe the underlying consistency relations.
    \item[Normative consistency relations] prescribe consistency and %are induced by transformations and that 
    do not exist \enquote{naturally}. This is especially the case if metamodels represent different abstractions or domains of a system, which have no implicit relation, such as an \gls{ADL} and Java. % in our example.
\end{description}

While descriptive consistency relations between two metamodels are usually definite, such as those between \gls{OO} design in \gls{UML} and Java, normative consistency relations may vary depending on the project context.
For example, several possible relations can be defined between an \gls{ADL} and \gls{OO} design, for example the realization of each component as a class or as a complete project~\cite{langhammer2017a}.
%$For example, the relation between \ac{OO} design in \ac{UML} and Java will usually be definite and not depend on the context, whereas there may be several possible relations between an \ac{ADL} and OO-design.
%Depending on the context, a component could be realized by a class or a complete project, and a class realizing an architectural component may be placed anywhere or in a specific package, as discussed by \textcite{langhammer2017a}.

Transformations for descriptive consistency relations implicitly encode %the preservation of consistency between 
the common concepts.
%Descriptive consistency relations base on the fact that different metamodels represent similar or equal concepts.
%In consequence, transformations are supposed to define the preservation of consistency between those common concepts.
%Instead of implicitly encoding those common concepts in transformations, 
Instead, we propose to make these common concepts explicit in so-called \emph{\glspl{CMM}} and define relations between them and the concrete metamodels.
We illustrate this in \autoref{fig:quality:concept_metamodel_integration}.
The descriptive consistency relation \ref{fig:quality:concept_metamodel_integration:R1} is converted into a \gls{CMM} for the metamodels \ref{fig:quality:concept_metamodel_integration:A} and \ref{fig:quality:concept_metamodel_integration:B} with new relations \ref{fig:quality:concept_metamodel_integration:R4} and \ref{fig:quality:concept_metamodel_integration:R5} between the concrete metamodels and the \gls{CMM}.
The existing normative consistency relations \ref{fig:quality:concept_metamodel_integration} and \ref{fig:quality:concept_metamodel_integration:R3} to metamodel \ref{fig:quality:concept_metamodel_integration:C} are replaced by a new relation \ref{fig:quality:concept_metamodel_integration:R6} to the \gls{CMM}. % to the metamodel \ref{fig:concept:C}.
The \gls{CMM} and its consistency relations have to be appropriately defined to replace the original ones, as depicted in \autoref{fig:quality:concept_metamodel_integration}. %, have to be fulfilled by appropriately defining the \ac{CMM}.
It will be part of our research to figure out how to define such a \gls{CMM}, so that it can also be combined with other metamodels. %, without estimating the additional information that may be necessary in the \ac{CMM} a-priori.
While it basically has to contain the common concepts of the metamodels sharing a descriptive consistency relations, it may also need to contain additional information depending on consistency relations to other metamodels, which are not known a-priori.

\begin{figure}
    \centering
    \input{figures/quality/concept_metamodel_integration.tex}
    \caption{Definition of a concept metamodel}
    \label{fig:quality:concept_metamodel_integration}
    \todo{We can use this for showing how to integrate commonalities with ordinary direct relations, maybe there should be a section about that.}
\end{figure}

%%%As one concrete example, instead of specifying transformations between \ac{OO} design in \ac{UML} and Java, an OO-\ac{CMM}, with concepts like classes, inheritance and so on, and the relations of \ac{UML} and Java to this \ac{CMM} could be defined.
% These concept metamodels can be seen as additional metamodels 
% of metamodels having inherent consistency relations explicit within a \ac{VOMM} and to define a mapping between concrete metamodels and \acp{VOMM}. We claim that prescribed consistency is actually not specific for concrete metamodels, but for concepts as represented by our \acp{VOMM}, which means that metamodels with prescribed consistency relations can be kept consistent by specifying consistency preservation between their \acp{VOMM}. In our example, this means that consistency relations between \ac{PCM} and Java should be expressed as relations between OO and component concept. 

%%%%% CBSE-EXAMPLE REMOVED!
% In \autoref{fig:cmm_example}, we illustrate the usage of such \acp{CMM} to define an OO-concept and a concept for component-based architecture descriptions, relating component models of \ac{UML} and the \acf{PCM} to.
% Relations between those \acp{CMM} can again be defined using other \acp{CMM}, or by defining ordinary transformations between them. 
% We discuss the impact of that decision in the following.

% \begin{figure}
%     \vspace{-0.7em}
%     \begin{center}
%         \input{figures/cmm_example.tex}
%     \end{center}
%     \vspace{-0.7em}
%     \caption{Exemplary \acp{CMM} and their consistency relations}
%     \label{fig:cmm_example}
% \end{figure}

%\todoHeiko{Das mit der Baumstruktur ist ein Knackpunkt. Kommt der gut genug rüber?}
% To avoid the drawbacks of transitive transformation execution between \acp{VOMM}, it is necessary that only one propagation path between two metamodels exists. This requires to define \ac{VOMM} relations in a way such that they induce an an acyclic graph by also extracting common concepts of \acp{VOMM} in another \ac{VOMM}. 
%In the example, the component \ac{VOMM} could be seen as an abstracted concept of the OO \ac{VOMM}. 
% It will be part of our research to identify if such an ordering of concepts can be achieved in different case studies.

%%% REMOVED THE FOLLOWING, AS NOT A RELEVANT "DRAWBACK"
%Such \acp{CMM} are technically similar to introducing new metamodels and defining transformations between them and existing metamodels.
%Nevertheless, they are conceptually different.
%First, they are supposed to be transparent to the user of the concrete models.
%Additionally, 
This approach addresses all identified challenges % identified in \autoref{sec:approach:challenges} 
and solves them under the assumption that all consistency relations %of a system 
are described using \glspl{CMM}. %if their specification is encapsulated in a specialized language, our challenges identified in \autoref{sec:approach:challenges} can be addressed.
%Under the assumption that all consistency relations of a system can be described using \acp{CMM}, we would be able to solve all identified challenges, as using \acp{CMM} allows to have the expressiveness of a graph of transformations, but abstracted to a tree structure with all its advantages.
%We achieve \emph{uniqueness} by extracting common concepts into \acp{CMM} having to define only one relation of a metamodel to the \ac{CMM}. 
We achieve inherent transformation compatibility by avoiding more than one transformation path %for the propagation of one change 
between two metamodels by design. %Therefore, it is necessary to define \acp{CMM} relations in a way such that they induce a tree by also extracting common concepts of \acp{CMM} in other \acp{CMM}.  
Since metamodels are only coupled across \glspl{CMM} and thus represent leaves of the transformation tree, any subset of them can be selected, maximizing modularity. % can be performed in a concrete usage scenario, maximizing modularity.
%Finally, we assume that expressing consistency with explicit common concepts improves comprehensibility, %over combining binary consistency specifications
%as it is a more natural representation and especially no transformations paths have to be traversed to understand a specific relation. % and expressing common information in common concepts is more natural than expressing it in transformations.
%An approach of adding additional metamodels is also shortly discussed in \cite{stevens2020BidirectionalTransformationLarge-SoSym}, but with the focus on definability of multiary relations rather than the optimization regarding certain challenges.
Finally, we assume that making common concepts explicit improves comprehensibility.

The most crucial part of this approach is the necessity to build a tree of \glspl{CMM}.
This will not be possible if always considering whole metamodels and their relations, but can be possible if independent concepts are extracted to be treated individually.
For that, we will apply our findings on consistency relation decomposition (see \autoref{chap:commonalities:approach}).
%This is similar to decomposing consistency relations, as introduced in \autoref{sec:approach:decomposition}, which is why we will apply our findings therefrom.
Additionally, the approach specifically aims to improve the specification of transformations for descriptive relations.
In consequence, it must be combined with transformations expressing the normative relations between \glspl{CMM} and other metamodels.

% Introduction of the \emph{MultiCons} approach for consistency between multiple, heterogeneous models with the specification of virtual overlap metamodels.

% \begin{itemize}
%     \item Why do we keep two models consistent?
%     \begin{enumerate}
%         \item They represent a common \emph{concept} with common properties of the system under development, which induces their redundant representation or at least dependencies between properties of the models, e.g. both UML class models and Java code realize an OO-concept.
%         \item They represent different abstractions of or views on a system, but a prescription of consistency preservation rules exists. For example, for descriptions of the component-based software architecture with the Palladio Component Model (PCM) and Java code a consistency specification was developed by \textcite{langhammer2017a}.
%     \end{enumerate}
%     \item We call this overlap of information that is represented in several models and that requires consistency preservation a \emph{semantic overlap}, as models overlap because they contain information with the same or dependent semantics.
%     \item Currently, consistency preservation tools require the specification of relations between two models, which implicitly defines the common properties. E.g. specifying the relations between Java code and UML class models implicitly contains a specification of the common properties of both metamodels
%     \item Idea: 
%     \begin{enumerate}
%         \item Make the common properties explicit in \emph{virtual overlap metamodels (VOMMs)} and define how these properties map to the concrete properties of existing metamodels
%         \item Define consistency relations between metamodels representing different abstractions or views on the systems between VOMMs rather than the actual metamodels.
%     \end{enumerate}
% \end{itemize}



% Envisioned benefits of this approach are:
% \begin{itemize}
%     \item Reduction of risk of inconsistent consistency specifications by design and thus reductions of risk of propagation cycles: Refer to challenge in introduction
%     \item Modular consistency specifications: Relations between two metamodels are defined across VOMMs, such that single metamodels can be omitted without losing necessary consistency relations (transitive relations)
%     \item Comprehensibility: Defining common concepts and their relations is (hopefully) better comprehensible than defining relations between pairs of metamodels
% \end{itemize}

% Known drawbacks:
% \begin{itemize}
%     \item Specification is more elaborate in simple cases (two metamodels only), as the VOMM has to be defined additionally
%     \item 
% \end{itemize}

\end{copiedFrom} % DocSym
