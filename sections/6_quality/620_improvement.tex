\chapter{Mitigating Trade-offs with Commonalities 
    \pgsize{20 p.}
}
\label{chap:commonalities}

\todo{Start discussion from topologies and properties.
Then again start the discussion from the idea of common concept definition.
Then unify the two argumentations.}

\todo{Instead of only discussion compatibility (which for sure is also true), discuss that in Commonalities there is always a consistent orchestration and that the shortest orchestration has an upper bound depending on the number of transformations. Discuss why this is not a drawback regarding such a bound in ordinary networks (especially discuss the previous example, where ping-pong was required, whereas here the required information is automatically added within the Commonalities and then only needs to be propagated back). However, there can still be scenarios that cannot be handled (due to the same reasons as for ordinary networks), but we already questioned there, although theoretically possible, whether they are practically relevant. In contrast to ordinary networks, Commonalities encode the limitation into the approach strategy and thus make it explicit for the developer rather then defining individual transformation without knowing how often they are executed later on.}

\todo{Composing commonality structures: encapsulate them (by views?) -> refer to \autoref{chap:networks:specification_process} for different network developers composing different networks}

\begin{copiedFrom}{VoSE}

% CONTEXT
% What we need transformations for
Modern %software and 
software-intensive systems are usually described by different \emph{models}, also considered as \emph{views}, such as code, architecture, deployment specifications and other role- or concern-specific models.
%\modified{Those models can also be considered as views of the system, which synthetically form the complete description of a system.}
Since all these models describe the same system, but focus on specific properties or use different levels of abstraction, they typically share information that is represented in the models redundantly, or at least induces dependencies between them.
Such redundancies have to be kept consistent to achieve a contradiction-free specification of the %software 
system.

% \begin{itemize}
%     \item When several models are used to describe the same software system, they usually share some information
%     \item Two models can describe different properties of the systems, or describe the same properties on a different level of abstraction
%     \item This leads to dependencies or even redundancies between the models
%     \item While arbitrary dependencies often base on manually defined consistency relations (e.g. an architectural component shall be represented as a class in OO-design and implementation), redundancies occur because the same elements are represented in different models
% \end{itemize}


% PROBLEM
% What transformations are
In practice, redundancies are often kept consistent manually~\cite{sax2017survey, guissouma2018study}.
A common means to automate consistency preservation are \emph{incremental model transformations}.
Such transformations define how an instance of one metamodel has to be updated to restore consistency whenever an instance of another was modified.
A transformation can be declared in different ways: %can be defined on different abstraction levels: it 
it may either specify what has to be changed to restore consistency %after a modification 
(\emph{imperative}), or only the consistency constraints that have to hold, from which the rules to restore consistency are derived automatically (\emph{declarative}).
%A transformation can be rather imperative, defining what has to be changed to restore consistency after a modification, or rather declarative, defining only the consistency constraints that have to hold and automatically deriving rules to restore consistency when a constraint gets violated.
But no matter how a transformation is defined, it specifies a \emph{relation} between two (or more) metamodels.
However, redundant elements are representations of a \emph{common concept} rather than independent elements that have to be directly related.
In consequence, we think that it is natural to make the common concept, which the redundant elements are supposed to describe, explicit. 
We can then specify how this concept manifests itself in the different metamodels, instead of defining directly how the redundant elements are related.
For example, %we assume that it is 
it appears to be more natural to say that classes in UML and Java are different manifestations of the concept of a class in object-oriented design, rather than saying that a UML class should be related to a corresponding Java class.
Such a common concept is what we call a \emph{\commonality}.

% Transformations:
% \begin{itemize}
%     \item Incremental transformations are a common means to keep several models consistent
%     \item A transformation defines, how elements in different models are related and what should be done if one of them is changed
%     \item Consistency relations are usually defined declaratively (what constraints have to hold) or imperatively (how are constraints enforced) between two (or sometimes more) metamodels. This is a definition of when instances of that metamodels are considered consistent.
%     \item However, if transformations have to preserve consistency especially of redundant elements, these redundant elements in fact represent a common element in different ways
%     \item Instead of defining how redundant elements are related, it would be more natural to define that there is common element to be describe, and how this common element manifests in the different models
%     \item This is what we call a \emph{Commonality}
% \end{itemize}

% APPROACH
In this paper, we present the \emph{\commonalities approach}. %, which is based on the Bachelor's thesis of \textcite{gleitze2017a}.
% Vorschlag:
It defines \commonalities between metamodels explicitly and thereby allows to state clearly which common concepts they share.
%, instead of encoding this information implicitly in a transformation.
%The approach aims to explicitly define commonalities of metamodels for describing their consistency relations rather than implicitly encoding them in a transformation.
From such a specification, transformations are derived that keep instances of those metamodels consistent.
We discuss options how to derive such transformations, strategies to hierarchically compose \commonalities, as well as benefits and limitations of the approach.
Additionally, we discuss design options for a language that supports the specification of \commonalities and present the \emph{\commonalities language}, which we have developed as a proof-of-concept.
It is based on the Bachelor's thesis of \textcite{gleitze2017a}. 
% Commonalities approach, based on thesis by \textcite{gleitze2017a}:
% \begin{itemize}
%     \item We propose the \emph{Commonalities Approach} that aims to explicitly define commonalities of models for describing their consistency relations rather than encoding them in a transformation
%     \item From the description of such Commonalities, transformations to keep the models consistent can be derived
%     \item We discuss how such Commonalities can be defined and how they can be composed to describe consistency between multiple, heterogeneous models (i.e. instances of different metamodels)
% \end{itemize}

% CONTRIBUTIONS
% Our main contributions in this paper are:
% \begin{description}[leftmargin=\parindent]
%     \item[\contributionlabel{contrib:approach}{Commonalities Approach}{C1}:] We propose an approach for making common concepts of different metamodels explicit rather than encoding them implicitly in constraints of a transformation.
%     \item[\contributionlabel{contrib:language}{Commonalities Language}{C2}:] We discuss design options for a language to define \commonalities and outline one language to specify them.
%     %\item[Dynamic Extensibility:] We provide an approach that allows to dynamically extend a declarative specification language.
%     \item[\contributionlabel{contrib:proofofconcept}{Proof-of-Concept}{C3}:] We give an indicator for the applicability of the approach by providing a proof-of-concept implementation and applying it to a scenario with four simple metamodels sharing common concepts. % that have to be kept consistent.
% \end{description}

% BENEFITS
We expect several benefits from our approach, i.e. specifying \commonalities, in comparison to direct transformation specifications between metamodels.
First, we claim to achieve \emph{better understandability} of relations between metamodels, because common concepts are made explicit. % rather than encoding them implicitly in transformations.
Second, the approach \emph{reduces errors} when more than two metamodels are to be kept consistent.
Transformations usually relate two metamodels, especially because multidirectional relations are hard to express~\cite{stevens2020BidirectionalTransformationLarge-SoSym},
%\modified{either because the developer does not know about multidirectional relations or due to cognitive limitations~\cite{stevens2020BidirectionalTransformationLarge-SoSym},} %keep instances of two metamodels consistent 
and therefore have to be combined to a network of transformations to keep instances of more than two metamodels consistent.
% Following sentence moved from approach section
Such a network can be regarded as a graph, formed by metamodels as its nodes and transformations as its edges.
However, such a network can easily raise compatibility problems if there exists more than one path of transformations between two metamodels.
A hierarchy of \commonality specifications is, by design, not prone to such problems.
Finally, we \emph{improve reusability} in comparison to a network of transformations, %regarding a network of transformations, 
because an arbitrary subset of metamodels, between which \commonalities are defined, can be selected to keep their instances consistent.
In contrast, removing metamodels from a transformation network can easily lead to missing transformation paths between two metamodels.

% Benefits:
% \begin{itemize}
%     \item \emph{Better understandability} of relations, as common concepts are explicitly defined rather than implicitly encoding them in transformations
%     \item \emph{Improved reusability / partial usability} (regarding networks of binary transformations), because an arbitrary selection of concrete metamodels can be used and kept consistent
%     \item \emph{High expressiveness}, because no restriction due to predefined sets of statements, as expression can be added dynamically. This can be also improve analyzability of transformations, as additional metadata could be defined for each of the extensions.
% \end{itemize}

\end{copiedFrom} % VoSE


\begin{copiedFrom} % VoSE

\section{Running Example}

We use a running example throughout the paper to explain the \commonalities idea.
It relies on three metamodels: UML class models, Java code, whose grammar definition can be treated as a metamodel~\cite{heidenreich2010a}, and the \ac{PCM}~\cite{reussner2016a}, a component-based architecture description language.
The consistency relations between Java and UML class models are mostly one-to-one mappings, as they provide the same concepts of object-oriented design. %provide redundant representations of the same concepts, so the consistency relations between them define mostly one-to-one mappings.
Consistency relations between \ac{PCM} and Java were proposed by \textcite{langhammer2015a}.
For this paper, only the one-to-one mapping between components in \ac{PCM} and classes in Java---or generally all object-oriented languages---are relevant, whereby each component is mapped to a class but not vice versa.

For the examples in this paper, a minimalist subset of those metamodels, depicted in \autoref{fig:quality:running_example}, is sufficient.
It only comprises classes in UML and Java and components in \ac{PCM}, which all have a name.
The name shall be equal between corresponding classes in UML and Java, whereas the classes realizing a component shall have the same name as the component, complemented by an \enquote{Impl} suffix (cf.~\cite{langhammer2015a}).
With state-of-the-art techniques, those constraints could be implemented as relations in declarative or as enforcing routines in imperative transformation languages.

\begin{figure}
	\centering
	\input{figures/quality/running_example.tex}
	\caption{Metamodel extracts for Java, UML and \ac{PCM} and consistency relations ({\protect\tikz[baseline=-0.5ex] \protect\draw[latex-latex, consistency related element] (0,0) -- (1.5em,0);}) between them}
	\label{fig:quality:running_example}
\end{figure}

In this paper, we consider metamodels that conform to the \ac{EMOF} standard~\cite{mof}.
Such metamodels consist of classes, which we denote as \emph{\metaclasses} to avoid confusion with classes in exemplary metamodels such as Java and UML.
\Metaclasses can in turn contain attributes and associations to other classes, which may be containments.

\end{copiedFrom} % VoSE


\begin{copiedFrom}{DocSym}

\section{Making Common Concepts Explicit} 

% \subsection{Approach
%     \pgsize{1 p.}
%     \dl{16.06.2017}
%     \complete{0}}

%\todoConference{A description of the proposed solution and which other work (e.g., methods or tools) it depends on.}
%\todoHeiko{One Solution: Add additional models. Already proposed by Stevens, but just to solve constraints. Here, we make overlaps explicit}
%\todo{Referenz zu Aussage von Stevens hinzufügen}
%\todoHeiko{Discuss necessity to provide orthogonal concept metamodels}

%\todoHeiko{Why ''virtual``? Because they are transparent to the user and nothing he has to deal with}
%\todo{Referenz auf Grafik und Optimalfall davon erklären}
Based on the decomposition of consistency relations, we propose another approach to achieve a tree structure of transformations, which inherently optimizes \emph{modularity}.
%In the following, we propose another solution option to achieve a tree structure of consistency relations, next to decomposing consistency relations into independent subsets.
%This approach called \emph{\acp{CMM}} ensures consistency between specifications inherently given by the tree structure, but also optimizes modularity, so that an arbitrary subset of the metamodels can be used.
%It also reuses the concepts for decomposing consistency relations.
% In \autoref{sec:Introduction}, we discussed reasons for specifying consistency using binary transformations instead of defining multiary relations.
% Nevertheless, as discussed in the previous section, trade-off decisions regarding the identified challenges have to made with that approach.
% Therefore, we propose an approach called \emph{\acp{CMM}} for a certain kind of relations that addresses all those identified challenges.
The idea bases on the insight that we can distinguish two kinds of consistency relations:
\begin{description}[leftmargin=\parindent]
    \item[Descriptive consistency relations] are \enquote{naturally} given when two metamodels represent common \emph{concepts} %with common properties
    redundantly or at least with dependent properties. This is, for example, the case for \ac{UML} class models and Java realizing \ac{OO}. %, and for \ac{UML} component models and \ac{PCM} models realizing a component concept.
    %They have to be expressed by transformations in a way that they describe the underlying consistency relations.
    \item[Normative consistency relations] prescribe consistency and %are induced by transformations and that 
    do not exist \enquote{naturally}. This is especially the case if metamodels represent different abstractions or domains of a system, which have no implicit relation, such as an \ac{ADL} and Java. % in our example.
\end{description}

While descriptive consistency relations between two metamodels are usually definite, such as those between \ac{OO} design in \ac{UML} and Java, normative consistency relations may vary depending on the project context.
For example, several possible relations can be defined between an \ac{ADL} and \ac{OO} design, for example the realization of each component as a class or as a complete project~\cite{langhammer2017a}.
%$For example, the relation between \ac{OO} design in \ac{UML} and Java will usually be definite and not depend on the context, whereas there may be several possible relations between an \ac{ADL} and OO-design.
%Depending on the context, a component could be realized by a class or a complete project, and a class realizing an architectural component may be placed anywhere or in a specific package, as discussed by \textcite{langhammer2017a}.

Transformations for descriptive consistency relations implicitly encode %the preservation of consistency between 
the common concepts.
%Descriptive consistency relations base on the fact that different metamodels represent similar or equal concepts.
%In consequence, transformations are supposed to define the preservation of consistency between those common concepts.
%Instead of implicitly encoding those common concepts in transformations, 
Instead, we propose to make these common concepts explicit in so-called \emph{\acfp{CMM}} and define relations between them and the concrete metamodels.
We illustrate this in \autoref{fig:quality:concept_metamodel_integration}.
The descriptive consistency relation \ref{fig:quality:concept_metamodel_integration:R1} is converted into a \ac{CMM} for the metamodels \ref{fig:quality:concept_metamodel_integration:A} and \ref{fig:quality:concept_metamodel_integration:B} with new relations \ref{fig:quality:concept_metamodel_integration:R4} and \ref{fig:quality:concept_metamodel_integration:R5} between the concrete metamodels and the \ac{CMM}.
The existing normative consistency relations \ref{fig:quality:concept_metamodel_integration} and \ref{fig:quality:concept_metamodel_integration:R3} to metamodel \ref{fig:quality:concept_metamodel_integration:C} are replaced by a new relation \ref{fig:quality:concept_metamodel_integration:R6} to the \ac{CMM}. % to the metamodel \ref{fig:concept:C}.
The \ac{CMM} and its consistency relations have to be appropriately defined to replace the original ones, as depicted in \autoref{fig:quality:concept_metamodel_integration}. %, have to be fulfilled by appropriately defining the \ac{CMM}.
It will be part of our research to figure out how to define such a \ac{CMM}, so that it can also be combined with other metamodels. %, without estimating the additional information that may be necessary in the \ac{CMM} a-priori.
While it basically has to contain the common concepts of the metamodels sharing a descriptive consistency relations, it may also need to contain additional information depending on consistency relations to other metamodels, which are not known a-priori.

\begin{figure}
    \centering
    \input{figures/quality/concept_metamodel_integration.tex}
    \caption{Definition of a concept metamodel}
    \label{fig:quality:concept_metamodel_integration}
    \todo{We can use this for showing how to integrate commonalities with ordinary direct relations, maybe there should be a section about that.}
\end{figure}

%%%As one concrete example, instead of specifying transformations between \ac{OO} design in \ac{UML} and Java, an OO-\ac{CMM}, with concepts like classes, inheritance and so on, and the relations of \ac{UML} and Java to this \ac{CMM} could be defined.
% These concept metamodels can be seen as additional metamodels 
% of metamodels having inherent consistency relations explicit within a \ac{VOMM} and to define a mapping between concrete metamodels and \acp{VOMM}. We claim that prescribed consistency is actually not specific for concrete metamodels, but for concepts as represented by our \acp{VOMM}, which means that metamodels with prescribed consistency relations can be kept consistent by specifying consistency preservation between their \acp{VOMM}. In our example, this means that consistency relations between \ac{PCM} and Java should be expressed as relations between OO and component concept. 

%%%%% CBSE-EXAMPLE REMOVED!
% In \autoref{fig:cmm_example}, we illustrate the usage of such \acp{CMM} to define an OO-concept and a concept for component-based architecture descriptions, relating component models of \ac{UML} and the \acf{PCM} to.
% Relations between those \acp{CMM} can again be defined using other \acp{CMM}, or by defining ordinary transformations between them. 
% We discuss the impact of that decision in the following.

% \begin{figure}
%     \vspace{-0.7em}
%     \begin{center}
%         \input{figures/cmm_example.tex}
%     \end{center}
%     \vspace{-0.7em}
%     \caption{Exemplary \acp{CMM} and their consistency relations}
%     \label{fig:cmm_example}
% \end{figure}

%\todoHeiko{Das mit der Baumstruktur ist ein Knackpunkt. Kommt der gut genug rüber?}
% To avoid the drawbacks of transitive transformation execution between \acp{VOMM}, it is necessary that only one propagation path between two metamodels exists. This requires to define \ac{VOMM} relations in a way such that they induce an an acyclic graph by also extracting common concepts of \acp{VOMM} in another \ac{VOMM}. 
%In the example, the component \ac{VOMM} could be seen as an abstracted concept of the OO \ac{VOMM}. 
% It will be part of our research to identify if such an ordering of concepts can be achieved in different case studies.

%%% REMOVED THE FOLLOWING, AS NOT A RELEVANT "DRAWBACK"
%Such \acp{CMM} are technically similar to introducing new metamodels and defining transformations between them and existing metamodels.
%Nevertheless, they are conceptually different.
%First, they are supposed to be transparent to the user of the concrete models.
%Additionally, 
This approach addresses all identified challenges % identified in \autoref{sec:approach:challenges} 
and solves them under the assumption that all consistency relations %of a system 
are described using \acp{CMM}. %if their specification is encapsulated in a specialized language, our challenges identified in \autoref{sec:approach:challenges} can be addressed.
%Under the assumption that all consistency relations of a system can be described using \acp{CMM}, we would be able to solve all identified challenges, as using \acp{CMM} allows to have the expressiveness of a graph of transformations, but abstracted to a tree structure with all its advantages.
%We achieve \emph{uniqueness} by extracting common concepts into \acp{CMM} having to define only one relation of a metamodel to the \ac{CMM}. 
We achieve inherent transformation compatibility by avoiding more than one transformation path %for the propagation of one change 
between two metamodels by design. %Therefore, it is necessary to define \acp{CMM} relations in a way such that they induce a tree by also extracting common concepts of \acp{CMM} in other \acp{CMM}.  
Since metamodels are only coupled across \acp{CMM} and thus represent leaves of the transformation tree, any subset of them can be selected, maximizing modularity. % can be performed in a concrete usage scenario, maximizing modularity.
%Finally, we assume that expressing consistency with explicit common concepts improves comprehensibility, %over combining binary consistency specifications
%as it is a more natural representation and especially no transformations paths have to be traversed to understand a specific relation. % and expressing common information in common concepts is more natural than expressing it in transformations.
%An approach of adding additional metamodels is also shortly discussed in \cite{stevens2020BidirectionalTransformationLarge-SoSym}, but with the focus on definability of multiary relations rather than the optimization regarding certain challenges.
Finally, we assume that making common concepts explicit improves comprehensibility.

The most crucial part of this approach is the necessity to build a tree of \acp{CMM}.
This will not be possible if always considering whole metamodels and their relations, but can be possible if independent concepts are extracted to be treated individually.
For that, we will apply our findings on consistency relation decomposition (see \autoref{chap:commonalities:approach}).
%This is similar to decomposing consistency relations, as introduced in \autoref{sec:approach:decomposition}, which is why we will apply our findings therefrom.
Additionally, the approach specifically aims to improve the specification of transformations for descriptive relations.
In consequence, it must be combined with transformations expressing the normative relations between \acp{CMM} and other metamodels.

% Introduction of the \emph{MultiCons} approach for consistency between multiple, heterogeneous models with the specification of virtual overlap metamodels.

% \begin{itemize}
%     \item Why do we keep two models consistent?
%     \begin{enumerate}
%         \item They represent a common \emph{concept} with common properties of the system under development, which induces their redundant representation or at least dependencies between properties of the models, e.g. both UML class models and Java code realize an OO-concept.
%         \item They represent different abstractions of or views on a system, but a prescription of consistency preservation rules exists. For example, for descriptions of the component-based software architecture with the Palladio Component Model (PCM) and Java code a consistency specification was developed by \textcite{langhammer2017a}.
%     \end{enumerate}
%     \item We call this overlap of information that is represented in several models and that requires consistency preservation a \emph{semantic overlap}, as models overlap because they contain information with the same or dependent semantics.
%     \item Currently, consistency preservation tools require the specification of relations between two models, which implicitly defines the common properties. E.g. specifying the relations between Java code and UML class models implicitly contains a specification of the common properties of both metamodels
%     \item Idea: 
%     \begin{enumerate}
%         \item Make the common properties explicit in \emph{virtual overlap metamodels (VOMMs)} and define how these properties map to the concrete properties of existing metamodels
%         \item Define consistency relations between metamodels representing different abstractions or views on the systems between VOMMs rather than the actual metamodels.
%     \end{enumerate}
% \end{itemize}



% Envisioned benefits of this approach are:
% \begin{itemize}
%     \item Reduction of risk of inconsistent consistency specifications by design and thus reductions of risk of propagation cycles: Refer to challenge in introduction
%     \item Modular consistency specifications: Relations between two metamodels are defined across VOMMs, such that single metamodels can be omitted without losing necessary consistency relations (transitive relations)
%     \item Comprehensibility: Defining common concepts and their relations is (hopefully) better comprehensible than defining relations between pairs of metamodels
% \end{itemize}

% Known drawbacks:
% \begin{itemize}
%     \item Specification is more elaborate in simple cases (two metamodels only), as the VOMM has to be defined additionally
%     \item 
% \end{itemize}

\end{copiedFrom} % DocSym


\section{The Commonalities Approach}
\label{chap:commonalities:approach}

\begin{copiedFrom}{VoSE}

The state-of-the-art approach to keep models consistent automatically is the application of transformation languages.
If instances of multiple (i.e., more than two) metamodels are to be kept consistent, one can either use multidirectional transformation approaches, or compose bidirectional transformations to a network of transformations~\cite{cleve2019dagstuhl}.
% Following sentence moved to introduction
%Such a network can be regarded as a graph, formed by metamodels as its nodes and transformations as its edges.
When an instance of one metamodel is changed in such a network, the transformations are executed successively to propagate the change transitively across all models.
There are strategies to find one ordering of transformations to apply~\cite{stevens2020BidirectionalTransformationLarge-SoSym} and strategies to perform a fixpoint iteration until no further changes are conducted~\cite{klare2019icmt}.

%Short introduction of transformation network, what nodes and edges are and so on.
In this section, we propose a different approach for keeping two or more models consistent by specifying their common concepts rather than their direct consistency relations.
This forms our contribution~\ref{contrib:approach}.
% \subsection{Defining Consistency Relations}
% Different metamodels provide

% Consistency relations are usually defined declaratively (what constraints have to hold) or imperatively (how are constraints enforced) between two (or sometimes more) metamodels.
% This is a definition of when instances of that metamodels are considered consistent.
% Consistency constraints can be either \emph{declarative} or \emph{normative}. Declarative constraints exist (e.g. because they are somehow \enquote{natural} and have to be formalized to be checked or preserved by a tools. Normative constraints do not have to adhere to an existing notion of consistency and thus implicitly define what is considered consistent.
% In our running example, the constraints between UML and Java exist and only have to be specified in a declarative manner.
% On the other hand, the constraints between architecture and OO design (i.e. PCM and UML/Java) were normatively defined by \textcite{langhammerconstraints}. There is no single correct mapping between architecture and OO design but several possible.


\subsection{Making Common Concepts Explicit}

The redundancies between different metamodels are an expression of common concepts that are represented redundantly.
We already gave the example of a class in UML and Java, which are different representations of the common concept of a class in general object-oriented design.
We propose to make common concepts explicit rather than encoding them into the rules of a transformation.
This can be achieved by creating a \emph{\conceptmetamodel}, which defines those common concepts, and specifying the relations between the \conceptmetamodel and the existing metamodels.
We refer to the existing metamodels as \emph{\concretemetamodels}.
The relation specifications can be used to derive transformations between the \concretemetamodels and the \conceptmetamodel.

\autoref{fig:quality:commonalities_example} shows the \metaclasses for a \texttt{Class} as extracts of the \concretemetamodels for UML and Java and the \metaclass for the common concept of a \texttt{Class} in the \conceptmetamodel for object-oriented design.
We denote a single common concept as a \emph{\commonality}.
Further \commonalities in object-oriented design could, for example, be interfaces or methods.
The relation between the \texttt{Class} \commonality and its realizations in the \concretemetamodels are shown by a \emph{«manifests»} relation.
%Such a relation can be defined in a transformation.
In our simplified example, the relation would especially define that the names of the classes have to be equal. %an equality relationship.

\begin{figure}
    \centering
    \input{figures/quality/one_commonality_example.tex}
    \caption{\Conceptmetamodel for object-oriented design with a \texttt{Class} \commonality and its relations to UML and Java}
    \label{fig:quality:commonalities_example}
\end{figure}

When another \concretemetamodel that represents the same concepts shall be added, it is only necessary to define its relation to the \conceptmetamodel.
For example, adding \cplusplus as another metamodel representing object-oriented design would require the definition of the relation between the \texttt{Class} \commonality in object-oriented design and its representation in \cplusplus.
Adding an additional metamodel may require the \conceptmetamodel to be extended by \commonalities that were not relevant for the already considered metamodels.
In general, a \conceptmetamodel has to contain \commonalities for redundancies in all \concretemetamodels, which---mathematically speaking---can be expressed as the union of all pairwise intersections of the \concretemetamodels.

% Short description of the Commonalities concept and application to example (UML and Java classes, could e.g. be extended by C++)
% Necessary artifacts: the Commonalities metamodel and the transformations.
% But: one can define a language to specify the Commonalities metamodel together with a specification of how the elements and properties manifest in the concrete metamodels, which we will explain in more detail in \autoref{sec:language}.
% Introduce terms: \emph{Commonality} (metamodel with common concepts), concrete metamodel (a metamodel that is accessed by a user) and \emph{Manifestation} (the concrete metamodels that realize a Commonality).


\subsection{Composing \commonalities}

We have explained how multiple metamodels can be kept consistent using one \conceptmetamodel.
This allows, theoretically, the definition of one large \conceptmetamodel that contains all \commonalities for all \concretemetamodels.
It would at first sight be similar to a \ac{SUMM}, as introduced by \textcite{atkinson2010a}.
However, it would be less complex than a \ac{SUMM}, which is able to express all information about the software system and thus contains the union of all \concretemetamodels.
%In fact, the resulting \conceptmetamodel would be comparable to a \summ according to \textcite{atkinson2010a}, which is able to express all information about the software system, whereas the instances of the \concretemetamodels would only serve as projectional views that do not provide further information.
Nevertheless, one large \conceptmetamodel would still become unmanageably large due to the fact that it had to contain the union of all pairwise intersections of the \concretemetamodels, as mentioned before.

\begin{figure}
    \centering
    \input{figures/quality/composed_commonalities_example.tex}
    \caption{\Conceptmetamodels (dark) and their relations to \concretemetamodels (light) for the running example}
    \label{fig:quality:composed_commonalities_example}
\end{figure}

To avoid the specification of such a monolithic \conceptmetamodel, we propose to compose \commonalities from different \conceptmetamodels.
Instead of having only \commonalities that relate to \metaclasses in \concretemetamodels, \commonalities may also have relations to other \commonalities.
Consider the \conceptmetamodel for component-based design in \autoref{fig:quality:composed_commonalities_example}.
It contains the \commonality \texttt{Component}, which is represented by an equally named \metaclass in \ac{PCM},
as well as in the \commonality \texttt{Class} in the \conceptmetamodel for object-oriented design, conforming to the relations proposed by \textcite{langhammer2015a}.
This induces a tree structure with \commonalities as inner nodes and \metaclasses of \concretemetamodels as leaves.
With such a composition structure, a \emph{«manifests»} relation may not only exist between a %concrete and a concept metamodel but also between two \conceptmetamodels.
\commonality of a \conceptmetamodel and a \metaclass in a \concretemetamodel but also between two \commonalities.
However, a concrete or \conceptmetamodel that is lower in the hierarchy is supposed to represent how a \metaclass or \commonality in the higher one manifests, which is why we call it a \emph{manifestation}.
%Due to that, we call concrete and \conceptmetamodels that contain \metaclasses or \commonalities with a \emph{«manifests»} relation to another \conceptmetamodel a \emph{manifestation} of that \conceptmetamodel.
For example, the object-oriented design \conceptmetamodel is a manifestation of the component-based design \conceptmetamodel.

\begin{figure}
    \centering
    \input{figures/quality/extended_composed_commonalities_example.tex}
    \caption{\Conceptmetamodels (dark) and \concretemetamodels (light) of the running example, extended by UML components, with their relations}
    \label{fig:quality:extended_composed_commonalities_example}
\end{figure}

Our goal is to achieve a tree structure of commonalities. In the extended example in \autoref{fig:quality:extended_composed_commonalities_example}, a \texttt{Component} in the \conceptmetamodel for component-based design does not only manifest in a \ac{PCM} \texttt{Component} as well as a \texttt{Class} in object-oriented design, but also in \ac{UML}.
Since a \texttt{Class} in object-oriented design manifests both in Java and \ac{UML}, we do not have a tree structure of the induced relations between the metamodels anymore, due to \texttt{Class} and \texttt{Component} both being represented in \ac{UML}.
However, This still induces a tree structure between \metaclasses and \commonalities, with the \commonalities being inner nodes and \metaclasses of \concretemetamodels being leaves.

%
% How are Commonalities composed to keep multiple models consistent? What about overlaps?
% Apply to OO and PCM case
%
% \begin{figure}
%     \centering
% %    \includegraphics[width=\columnwidth]{figures/dag_example.pdf}\\
%     \input{figures/quality/dag_example.tex} %\\[1em]
%     %\input{figures/dag_example_alternative.tex}
%     \caption{\Concretemetamodels (light) and \conceptmetamodels (dark) of the running example forming a \acs{DAG}}
%     \label{fig:quality:dag_example}
% \end{figure}

%Since we only assume a tree of \commonalities,  rather than a tree of \conceptmetamodels, 
A metamodel may have several \commonalities in different \conceptmetamodels with different other metamodels.
For example, in \autoref{fig:quality:composed_commonalities_example}, the UML metamodel contains a \texttt{Class} and a \texttt{Component} \metaclass, which have two different \commonalities in two different \conceptmetamodels.

%We currently assume that all concept metamodels and relations to their manifestations can be represented as a tree.
% In general, %, this will not be possible, 
% the assumption of having a tree of \conceptmetamodels may not be satisfiable if
% metamodels have several \commonalities with different metamodels.
% In fact, we can relax that assumption: 
% The essential requirement is that each change is only propagated across one path between two models, which is inherently given in a tree.
% If the \commonalities of two \conceptmetamodels manifest in disjoint sets of elements of the same manifestation, that manifestation can be---virtually---separated into two metamodels, for which the network forms a tree again.
% In consequence, if we consider the transformations as directed edges from a \conceptmetamodel to its manifestations, we only have to require a \ac{DAG}, % induced by these edges, 
% as long as the manifestations of all \commonalities are disjoint.
% %If we consider the transformations as directed edges from a \conceptmetamodel to its manifestations, we only have to require a \ac{DAG} induced by these edges, as long as the \conceptmetamodels represent disjoint sets of elements of their manifestations.
% %This relaxation is possible due to the fact that the essential requirement is to have only one path between two models across which a change can be propagated.
% %If different \conceptmetamodels relate to disjoint parts of their manifestations, these manifestations can be virtually separated into different metamodels, which then form a tree again.
% \autoref{fig:dag_example} exemplifies this relaxation: % on our running example:
% If the UML is also considered a manifestation of component-based design by providing the \texttt{Component} \metaclass, the network does not constitute a tree because of the relations between the UML and the \conceptmetamodels for component-based design and object-oriented design.
% However, it forms a \ac{DAG} and the redundant paths to the UML metamodel are unproblematic, because the relation to object-oriented design affects the part of the UML metamodel considering classes (\emph{Class}), whereas the relation to component-based design affects the part of the UML metamodel considering components (\emph{Comp}). 
% The elements in these parts of the UML metamodel are disjoint.

\subsection{Transformation Operationalization}
\label{sec:approach:operationalization}

To actually keep models consistent, the specification of a hierarchy of \conceptmetamodels has to be operationalized.
Two options for operationalization can be distinguished:

\begin{description}[leftmargin=\parindent]
    \item[\Conceptmetamodels as additional metamodels:] The specified \conceptmetamodels are actually instantiated and the transformations are executed as they are defined between the \conceptmetamodels and their manifestations. In consequence, instances of the \conceptmetamodels have to be maintained.
    \item[Transformations between \concretemetamodels:] The \conceptmetamodels and the relations between them and their manifestations are used to derive bidirectional transformations between the \concretemetamodels. For example, from the \conceptmetamodel for object-oriented design in \autoref{fig:quality:commonalities_example}, a bidirectional transformation between Java and UML is derived.
\end{description}

A drawback of the first option is that additional models have to be managed and persisted. 
In consequence, the user has to version these models although they should be transparent to him or her, as long as no appropriate framework abstracts from such tasks.
%Additionally, it is not easily possible to derive the direct relations between two concrete metamodels from such a specification. For example, the direct relation between classes in UML and Java is not accessible but only implicitly expressed by the transitive relation across the concept metamodel for object-oriented design.
A drawback of the second option is that the types of supported relations that can be described in the transformations are limited.
First, only relations may be defined that can be composed with any other relation, such that a direct transformation between two metamodels can be derived.
Second, it is possible to define $n$-ary relations between more than two metamodels that cannot be decomposed into binary relations between them, but only into $n$ binary relations between those metamodels and an additional one~\cite{stevens2020BidirectionalTransformationLarge-SoSym}.
In consequence, the first option provides higher expressiveness.

While the first option can be realized without an additional language by just defining the \conceptmetamodels and the transformations with existing languages, the second option requires a mechanism that generates the transformations between the \concretemetamodels from those between the \conceptmetamodels and their manifestations.


\subsection{Benefits of \commonalities}
\label{sec:approach:benefits}

We suppose the \commonalities approach to provide two kinds of benefits:
First, we expect that it improves understandability of relations between metamodels, because common concepts are not encoded in transformations implicitly but modelled explicitly.
This is even a benefit if instances of only two metamodels shall be kept consistent.
Second, it reduces problems that can occur if several bidirectional transformations are combined into a network of transformations to keep multiple models consistent.

% Two types of benefits:
% \begin{itemize}
%     \item Independent from network size: Understandability (explicit commonalities rather than implicit encoding in constraints)
%     \item Benefits for transformation networks (in the following)
% \end{itemize}

\begin{figure}
    \centering
    %includegraphics[width=\columnwidth]{figures/topologies.png}
    \begin{minipage}[b]{0.4\columnwidth}
        \centering
        \input{figures/quality/topologies_full.tex}
        \vspace{-1em}
        \subcaption{Dense Graph}
        \label{fig:quality:topologies:full}
    \end{minipage}
    \hspace{2em}
    \begin{minipage}[b]{0.4\columnwidth}
        \centering
        \input{figures/quality/topologies_tree.tex}
        \subcaption{Tree}
        \label{fig:quality:topologies:tree}
    \end{minipage}
    \caption{Extremes of transformation network topologies: nodes represent metamodels, edges represent transformations (\conceptmetamodels in a tree of \commonalities in dark gray), adapted from \cite{klare2018docsym}}
    \label{fig:quality:topologies}
\end{figure}

Networks of transformations can have two extremes of topologies, as depicted in \autoref{fig:quality:topologies}.
If transformations between all metamodels are defined, the network forms a dense graph (see \autoref{fig:quality:topologies:full}).
In contrast, if there exists exactly one path of transformations between each pair of metamodels, the network forms a tree (see \autoref{fig:quality:topologies:tree}).
Several properties for such %transformation 
networks have been identified by \textcite{gleitze2017a} and \textcite{klare2018docsym}.
Two essential properties %, defined in \cite{klare2018docsym}, 
are \emph{compatibility} and \emph{modularity}~\cite{klare2018docsym}, which, unfortunately, contradict each other.
The \commonalities approach, however, improves both of them. %, which is an essential benefit that we discuss in the following. %We discuss the benefits of the \commonalities approach regarding those properties.
\emph{Compatibility} means that transformations do not define contradictory constraints.
Consider the relations introduced for the running example in \autoref{fig:quality:running_example}.
The names of the same class in Java and UML are defined to be equal.
If a class in Java and UML realizes a \ac{PCM} component, it shall have the same name appended with an \enquote{Impl} suffix.
If transformations realize the three relations between \ac{PCM}, UML and Java, and the one between \ac{PCM} and Java adds that suffix whereas the one between \ac{PCM} and UML omits it, the constraints can never be fulfilled.
%If the three relations between Java, UML and \ac{PCM} are defined in transformations and the one between \ac{PCM} and Java adds that suffix whereas the one between \ac{PCM} and UML omits it, the constraints can never be fulfilled.
In that case, the transformations are considered incompatible.
Incompatibility may arise whenever more than one transformation path between two metamodels exists.
In consequence, compatibility cannot be guaranteed in dense network, whereas it is inherently high if the network forms a tree.
\emph{Modularity} means that any subset of the metamodels can be used without loosing consistency because of missing transformations.
Modularity is high if any metamodel can be removed from the network and the remaining transformations still define consistency between all remaining metamodels.
In consequence, modularity is high in a dense network, because all metamodels are directly related, while it is low if the network is a tree, because inner nodes cannot be removed without their children not being related by a transformation anymore.
Since redundant paths between metamodels improve modularity but reduce compatibility, these properties are inherently contradicting.

The \commonalities approach improves both these properties due to the fact that additional metamodels are introduced in the specification.
The transformations between \metaclasses in \concretemetamodels and \commonalities in \conceptmetamodels induce a tree, thus compatibility is high.
Additionally, only the leaves of the tree are \concretemetamodels, which are actually used to describe a system and whose instances are modified, whereas the inner nodes only represent auxiliary metamodels, exemplarily marked in \autoref{fig:quality:topologies:tree}. 
In consequence, taking an arbitrary subset of \concretemetamodels removes only leaves and can thus be done without removing any transformations that are necessary to keep instances of the remaining metamodels consistent.
This constitutes a major benefit of the \commonalities approach as compared to ordinary networks of transformations.


% \subsection{Limitations of \commonalities}
% \label{sec:approach:limitations}
% ONE PART MOVED TO COMPOSITION (DAG INSTEAD OF TREES), ONE MOVED TO LIMITATIONS IN EVALUATION SECTION

\end{copiedFrom} % VoSE



\section{Composition of Commonalities with Views}

Discuss here, that a commonalities structure can be encapsulted in views (ref to Vitruv), which are then used to combine with other such structures in an ordinary network of BX. E.g. let there be an OO commonality for Java and UML and one CBS commonality for UML and PCM. Both are encapsulated in a projective view-based approach, which, e.g., exposes the concept metamodel. These views can than be combined by ordinary bx. This allows to build concept metamodels for subsets of the problem (subsets of the metamodels), especially for scenarios in which descriptive relations exist, which are then combined by ordinary networks. This gives the benefits of commonalities, such as extendability, modularity (which are preserved even if the concept is combined with others by bx), but also provides the flexibility of bx networks, but reduced the proneness to errors in the networks as parts are handled by inherently compatible commonalities.

See for example \autoref{fig:quality:concept_metamodel_integration} for a scenario combining normative and descriptive relations. We could compare a scenario where Java, UML class, UML comp and PCM are connected in a network, connected in an overall commonality and with two commonalities combined in a network.

Drawback of this approach is that the views exposed the structures have to provide all required information to be kept consistent with other structures. For example, the CBS commonality only contains the information shared between UML and PCM, thus if there is information in PCM to be shared with Java, but not with UML component, the concept metamodel does not contain that, but has to be exposed to be kept consistent with the OO concept. Thus, there may be more extensive views than only exposing the commonality. In fact, the structure would need to be a SUM, for which any information can be extracted. However, it is an open issue how consistency is preserved if information is derived to different views which are all modified, or if a heterogeneous view is created (cf. ModelJoin). Imagine the consistency preservation derives the commonalities view for components to modify the information shared between UML and PCM and uses the PCM view to change information only present in PCM (e.g. functionality). If a change in Java requires modifications in both views, these changes both have to be propated to the underlying models. If there are conflicts, they have to be resolved like in a synchronization scenario (several user modifiy views concurrently). This problem is yet unsolved.



\section{Processes for Defining Commonalities}

Discuss how commonalities can be defined. Which roles are involved, especially how different domain experts can communicate. E.g. bottom-up approach: Take the most related metamodels and define their commonalities. Then define higher-level commonalities relating these concept metamodels or even the concrete metamodels. 
The problem is that combining two concept metamodels requires them to contain all necessary information, thus a concept metamodel design is not only driven by the metamodels to keep directly consistent, but also by the information that is needed to preserve consistency to other commonalities. This refers to the same scenario as if multiple commonality structures are encapsulated into projective view environments which are combined by BX. They require the exposed views to provide all information necessary to preserve consistency.