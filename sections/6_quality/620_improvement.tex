\chapter{Mitigating Trade-offs with Commonalities 
    \pgsize{35 p.}
}
\label{chap:improvement}

\mnote{Topologies and Properties}
We have identified in the previous chapter that the topology of the graph induced by the metamodels and transformations of a transformation network directly influences several of its quality properties, such as function correctness and completeness, as well as maintainability in terms of modularity and reusability.
The extreme topologies of complete graphs and trees imply extremes in the optimization or degradation of these properties, which induces a trade-off between these properties by means of the topology.

%\todo{Start discussion from topologies and properties.
%Then again start the discussion from the idea of common concept definition.
%Then unify the two argumentations.}

\mnote{Benefits of trees}
In \autoref{part:correctness}, we have focused on achieving correctness for networks of arbitrary topology, thus in general not inducing a tree but any graph topology that can be extended to a complete graph, which inherently optimizes reusability and completeness, but requires high effort for achieving completeness.
On the other hand, a tree structure, although not that easy to achieve, provides inherent correctness guarantees while reducing reusability and completeness, as identified in \autoref{chap:classification:topologies:effects}.
In this chapter, we discuss how a network having a tree topology can be constructed by introducing additional metamodels, such that correctness is still inherently given but reusability and completeness is improved.

\mnote{Common concepts}
The idea of adding metamodels is not just a conceptual necessity to improve quality properties, but also motivated by practical benefits.
Since consistency relations often define how common information represented in instances of several metamodels multiple times, we propose to represent this common information explicitly by means of additional metamodels instead.
Then, only the manifestation of this information in the models to keep consistent has to be defined rather than an implicit encoding of common information in the consistency relations between each pair of metamodel.
These manifestation relations can, of course, again be represented by transformation.
That way of specifying consistency relations in terms of explicit metamodels representing common information can inherently lead to a transformation network with a tree topology.

%\todo{Motivation for Comnmonalities idea: it is common in other domains (cf. Albers) to model the overlaps of models for preserving consistency (check slides of SFB and reference their publications)}

\mnote{Subordinate contributions}
This chapter constitutes our contribution \autoref{contrib:quality:improvement}, which consists of four subordinate contributions: a discussion of how common information can be represented explicitly in dedicated metamodels and when this is reasonable; a proposal of the \commonalities approach to construct such metamodels and transformations for describing the manifestations of common information in the original metamodels; a discussion of the expected benefits of the approach, especially in terms of mitigating trade-offs between quality properties; and finally an outlook to processes of applying the approach and of combining it with other transformations. It answers the following research question:

\researchquestionrepeat{rq:quality:topology}

\mnote{Benefits of contributions}
The insights in this chapter support transformation developers in constructing networks of correct, complete and reusable transformations.
It gives a different view on consistency and the possibilities to describe it besides consistency relations, which we expect to improve comprehensibility due to common concepts being represented explicitly rather than implicitly encoding them in consistency relations.
The proposed construction approach for transformation networks inherently improves several quality properties reducing the effort to achieve correctness of transformation networks as discussed in \autoref{part:correctness} and mitigating necessary trade-offs.
It especially improves reusability and completeness in comparison to an ordinary construction of a network having a tree topology.

\mnote{Publication of contributions}
The initial idea for the contributions in this chapter has already been published~\owncite{klare2018docsym}, as well as the proposed \commonalities approach with its expected benefits~\owncite{klare2019models}.
The approach along with a language that supports it, which we present in the subsequent chapter, has originally been developed in the Bachelor's thesis of \textcite{gleitze2017a}, which was supervised by the author of this thesis.


\input{sections/6_quality/621_improvement-concepts.tex}
\input{sections/6_quality/622_improvement-commonalities.tex}
\input{sections/6_quality/623_improvement-benefits.tex}
\input{sections/6_quality/624_improvement-application.tex}
\input{sections/6_quality/625_improvement-summary.tex}


% \begin{copiedFrom}{VoSE}

% CONTEXT
% What we need transformations for
% Modern %software and 
% software-intensive systems are usually described by different \emph{models}, also considered as \emph{views}, such as code, architecture, deployment specifications and other role- or concern-specific models.
% %\modified{Those models can also be considered as views of the system, which synthetically form the complete description of a system.}
% Since all these models describe the same system, but focus on specific properties or use different levels of abstraction, they typically share information that is represented in the models redundantly, or at least induces dependencies between them.
% Such redundancies have to be kept consistent to achieve a contradiction-free specification of the %software 
% system.

% \begin{itemize}
%     \item When several models are used to describe the same software system, they usually share some information
%     \item Two models can describe different properties of the systems, or describe the same properties on a different level of abstraction
%     \item This leads to dependencies or even redundancies between the models
%     \item While arbitrary dependencies often base on manually defined consistency relations (e.g. an architectural component shall be represented as a class in OO-design and implementation), redundancies occur because the same elements are represented in different models
% \end{itemize}

% PROBLEM
% What transformations are
% In practice, keeping redundancies consistent is a task that is often performed manually~\cite{sax2017survey, guissouma2018study}.
% A common means to automate consistency preservation are \emph{incremental model transformations}.
% Such transformations define how an instance of one metamodel has to be updated to restore consistency whenever an instance of another was modified.
% A transformation can be declared in different ways: %can be defined on different abstraction levels: it 
% it may either specify what has to be changed to restore consistency %after a modification 
% (\emph{imperative}), or only the consistency constraints that have to hold, from which the rules to restore consistency are derived automatically (\emph{declarative}).
% %A transformation can be rather imperative, defining what has to be changed to restore consistency after a modification, or rather declarative, defining only the consistency constraints that have to hold and automatically deriving rules to restore consistency when a constraint gets violated.
% But no matter how a transformation is defined, it specifies a \emph{relation} between two (or more) metamodels.
% However, redundant elements are representations of a \emph{common concept} rather than independent elements that have to be directly related.
% In consequence, we think that it is natural to make the common concept, which the redundant elements are supposed to describe, explicit. 
% We can then specify how this concept manifests itself in the different metamodels, instead of defining directly how the redundant elements are related.
% For example, %we assume that it is 
% it appears to be more natural to say that classes in UML and Java are different manifestations of the concept of a class in object-oriented design, rather than saying that a UML class should be related to a corresponding Java class.
% Such a common concept is what we call a \emph{\commonality}.

% Transformations:
% \begin{itemize}
%     \item Incremental transformations are a common means to keep several models consistent
%     \item A transformation defines, how elements in different models are related and what should be done if one of them is changed
%     \item Consistency relations are usually defined declaratively (what constraints have to hold) or imperatively (how are constraints enforced) between two (or sometimes more) metamodels. This is a definition of when instances of that metamodels are considered consistent.
%     \item However, if transformations have to preserve consistency especially of redundant elements, these redundant elements in fact represent a common element in different ways
%     \item Instead of defining how redundant elements are related, it would be more natural to define that there is common element to be describe, and how this common element manifests in the different models
%     \item This is what we call a \emph{Commonality}
% \end{itemize}

% APPROACH
% In this paper, we present the \emph{\commonalities approach}. %, which is based on the Bachelor's thesis of \textcite{gleitze2017a}.
% % Vorschlag:
% It defines \commonalities between metamodels explicitly and thereby allows to state clearly which common concepts they share.
% %, instead of encoding this information implicitly in a transformation.
% %The approach aims to explicitly define commonalities of metamodels for describing their consistency relations rather than implicitly encoding them in a transformation.
% From such a specification, transformations are derived that keep instances of those metamodels consistent.
% We discuss options how to derive such transformations, strategies to hierarchically compose \commonalities, as well as benefits and limitations of the approach.
% Additionally, we discuss design options for a language that supports the specification of \commonalities and present the \emph{\commonalities language}, which we have developed as a proof-of-concept.
% It is based on the Bachelor's thesis of \textcite{gleitze2017a}. 
% Commonalities approach, based on thesis by \textcite{gleitze2017a}:
% \begin{itemize}
%     \item We propose the \emph{Commonalities Approach} that aims to explicitly define commonalities of models for describing their consistency relations rather than encoding them in a transformation
%     \item From the description of such Commonalities, transformations to keep the models consistent can be derived
%     \item We discuss how such Commonalities can be defined and how they can be composed to describe consistency between multiple, heterogeneous models (i.e. instances of different metamodels)
% \end{itemize}

% CONTRIBUTIONS
% Our main contributions in this paper are:
% \begin{description}[leftmargin=\parindent]
%     \item[\contributionlabel{contrib:approach}{Commonalities Approach}{C1}:] We propose an approach for making common concepts of different metamodels explicit rather than encoding them implicitly in constraints of a transformation.
%     \item[\contributionlabel{contrib:language}{Commonalities Language}{C2}:] We discuss design options for a language to define \commonalities and outline one language to specify them.
%     %\item[Dynamic Extensibility:] We provide an approach that allows to dynamically extend a declarative specification language.
%     \item[\contributionlabel{contrib:proofofconcept}{Proof-of-Concept}{C3}:] We give an indicator for the applicability of the approach by providing a proof-of-concept implementation and applying it to a scenario with four simple metamodels sharing common concepts. % that have to be kept consistent.
% \end{description}

% BENEFITS
% We expect several benefits from our approach, i.e. specifying \commonalities, in comparison to direct transformation specifications between metamodels.
% First, we claim to achieve \emph{better understandability} of relations between metamodels, because common concepts are made explicit. % rather than encoding them implicitly in transformations.
% Second, the approach \emph{reduces errors} when more than two metamodels are to be kept consistent.
% Transformations usually relate two metamodels, especially because multidirectional relations are hard to express~\cite{stevens2020BidirectionalTransformationLarge-SoSym},
% %\modified{either because the developer does not know about multidirectional relations or due to cognitive limitations~\cite{stevens2020BidirectionalTransformationLarge-SoSym},} %keep instances of two metamodels consistent 
% and therefore have to be combined to a network of transformations to keep instances of more than two metamodels consistent.
% % Following sentence moved from approach section
% Such a network can be regarded as a graph, formed by metamodels as its nodes and transformations as its edges.
% However, such a network can easily raise compatibility problems if there exists more than one path of transformations between two metamodels.
% A hierarchy of \commonality specifications is, by design, not prone to such problems.
% Finally, we \emph{improve reusability} in comparison to a network of transformations, %regarding a network of transformations, 
% because an arbitrary subset of metamodels, between which \commonalities are defined, can be selected to keep their instances consistent.
% In contrast, removing metamodels from a transformation network can easily lead to missing transformation paths between two metamodels.

% % Benefits:
% % \begin{itemize}
% %     \item \emph{Better understandability} of relations, as common concepts are explicitly defined rather than implicitly encoding them in transformations
% %     \item \emph{Improved reusability / partial usability} (regarding networks of binary transformations), because an arbitrary selection of concrete metamodels can be used and kept consistent
% %     \item \emph{High expressiveness}, because no restriction due to predefined sets of statements, as expression can be added dynamically. This can be also improve analyzability of transformations, as additional metadata could be defined for each of the extensions.
% % \end{itemize}

% \end{copiedFrom} % VoSE

