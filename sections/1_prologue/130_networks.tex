\chapter{Models, Consistency and Processes
    \pgsize{10 p.}
}

\section{Consistency Types}

Discuss which types of consistency may exist (from Ellwangen retreat), how far they can be checked and what the mismatch is between pragmatic types of consistency and their verifiability.

Structural, behavioral, quality

Map to decidability (Turing completeness)

Discuss pragmatic distinction vs. decidability distinction

\todo{Derive limitations: for which types does our approach work?}



\section{Consistency Specification Processes}

\subsection{Roles}
* Define the process and roles:
** Domain expert
** Transformation developer
** Transformation network developer
** Transformation user
** Multiplicities
* Refer to Dagstuhl report with Mattias
* We call the users of transformation "engineers" (do we?) and the developers "domain experts"?

\subsection{Scenarios}

Discuss different scenarios: 

1. Put together transformations (COTS) and find out what is wrong or achieve that they work together
2. Develop transformations concurrently and find out whether they work together on-the-finally

\todoDiss{Discuss different benefits / scenarios more clearly, especially second benefit / application scenario: User define relations and wants on-the-fly feedback on compatibility to other existing relations, rather then a posteriori checking}



\section{Models and Metamodels}

We give an overview of the used elements in \autoref{tab:notation}.

\begin{table}
\centering
\renewcommand{\arraystretch}{1.4}%
%\rowcolors{2}{white}{gray!15}
%\setlength\tabcolsep{4 pt}
\begin{tabular}{R{4.8cm} L{5cm}}
\toprule
\multicolumn{2}{c}{Properties and Classes}\\
$P$                 
    & Property (attribute or reference) \\
$\metamodelinstances{P} = \setted{p_1, p_2, \dots}$     
    & Property values of a property $P$ \\
$\class{C}{} = \tupled{P_1, \dots, P_n}$
    & Class \\
$\metamodelinstances{C} = \setted{o = \tupled{p_1, \dots, p_n} \mid p_i \in \metamodelinstances{P_i}}$ 
    & Instances (objects) of a class $\class{C}{}$\\
$\object{o}{} \in \metamodelinstances{C}$
    & Object of a class $\class{C}{}$ \\
\midrule
\multicolumn{2}{c}{(Meta-)Models}\\
$\metamodel{M}{} = \setted{\class{C}{1}, \dots, \class{C}{m}}$
    & Metamodel\\
$\metamodelinstances{M} = \setted{m \mid m \subseteq \bigcup_{\class{C}{} \in \metamodel{M}{}} \metamodelinstances{C}}$
    & Instances of a metamodel\\
$\metamodelset{M} = \setted{\metamodel{M}{1}, \dots, \metamodel{M}{k}}$
    & Set of metamodels\\
$\metamodelinstances{\metamodelset{M}} = \setted{ \setted{\model{m}{1}, \dots, \model{m}{k}} \mid \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}}$
    & Instances of a metamodel set $\metamodelset{M}$\\
$\model{m}{} \in \metamodelinstances{M}$
    & Model of metamodel $\metamodel{M}{}$\\
$\modelset{m} \in \metamodelinstances{\metamodelset{M}}$
    & Model set of a metamodel set $\metamodelset{M}$\\
\bottomrule
\end{tabular}
\caption{Models, metamodels, their elements and notations}
\label{tab:prologue:elements}
\end{table}

\subsection{Notation}

In general, we use variables of uppercase letters for all elements at the metamodel level, such as $\metamodel{M}{}$ for a metamodel or $\class{C}{}$ for a class, whereas we use lowercase letters for all elements at the model level, such as $\model{m}{}$ for a model and $\object{o}{}$ for an object.
If not further specified, we use the same indices on related elements on the metamodel and the model level, such as model $\model{m}{1}$ being an instance of metamodel $\metamodel{M}{1}$.

\subsection{Elements}

In general, we consider metamodels as a composition of meta-classes, which in turn are composed of properties representing attributes or references.
Models instantiate metamodel and are composed of objects, which are instances of meta-classes and in turn consist of property values, which instantiate properties.

We denote \emph{properties}, which are the information a meta-class consists of, such as attributes or references, as $P$ and the \emph{property values} as instances of a property as $\metamodelinstances{P} = \setted{p_1, p_2, \dots}$ of property $P$. 
We do not need to further differentiate different types of properties into attributes and references, like it is done in other formalizations, such as the OCL standard~\cite[A.1]{ocl} or the thesis of \citeauthor{kramer2017a}~\cite[2.3.2]{kramer2017a}.

We denote \emph{meta-classes}, in the following shortly called \emph{classes}, as tuples of properties $\class{C}{} = \tupled{P_1, \dots, P_n}$. 
Instances of a \emph{class} are \emph{objects}, each being a tuple of instances of the properties of the class and we denote all instances of a class $\class{C}{}$ as $\metamodelinstances{C} = \setted{o = \tupled{p_1, \dots, p_n} \mid p_i \in \metamodelinstances{P_i}}$.

We denote a metamodel $\metamodel{M}{} = \setted{\class{C}{1}, \dots, \class{C}{m}}$ as a finite set of classes.
The instances of a metamodel are sets of objects $\metamodelinstances{M} = \setted{m \mid m \subseteq \bigcup_{\class{C}{} \in \metamodel{M}{}} \metamodelinstances{C}}$.
Each instance, denoted as a \emph{model}, is a finite set of objects that instantiate the classes in the metamodel.
For a set of metamodels $\metamodelset{M} = \setted{\metamodel{M}{1}, \dots, \metamodel{M}{k}}$, we denote the set that contains all sets of instances of that metamodels as $\metamodelinstances{\metamodelset{M}} = \setted{ \setted{\model{m}{1}, \dots, \model{m}{k}} \mid \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}}$.

%We use an extensional definition of metamodels, models and consistency relations, i.e. we enumerate the valid instances of a metamodel or the consistent pairs of models instead of intensionally describing how to derive them.
%Although actual modeling frameworks, such as EMF, and languages, such as QVT-R, use intensional specifications, the mathematical foundations of our approach are easier to describe in an extensional specification.
%However, expressiveness is the same, since an intensional specification can be, at least virtually, transformed into an extensional specification by enumerating all elements that fulfill the intensional specification.

%In general, we denote elements at the metamodel level with upper case letters and elements at the instance level with lower case letters. Tuples are denoted in angle brackets $\tupled{t}$.

%We denote models with lower case letters and indices $\model[1]{M}, \model[2]{M}, \ldots$.
%We denote elements of a model, such as meta-class instances, attributes values or reference instances, with lower case letters $e_1, e_2, f_2, f_2, \ldots$.

%We denote the instantiation relation between metamodels and models, as well as metamodel elements and model elements with instance sets:
%$\metamodelinstances{M}$ denotes the valid instances of a $\metamodel{M}$.
%$\metamodelinstances{E}$ denotes the instances of a metamodel element $E$.

\begin{definition}[Model]
A model $M = \{e_1, e_2, \ldots\}$ is a finite set of not further defined elements, such as objects, attribute and reference values.
\end{definition}

The exact representation of the model contents is not relevant for our work, which is why we use this lightweight definition. 
It allows us to transfer the insights to arbitrary models, such as models that are conform to the \ac{EMOF}~\cite{mof}.

\begin{definition}[Model Type]
A model type $\mathcal{M} = \{M_1, M_2, \dots\}$ is the (usually but not necessarily infinite) set of all models $M_1, M_2, \dots$ that are instances of $\mathcal{M}$.
\end{definition}

%So for a model type $\mathcal{M}$, a model $M$ is considered an instance of $\mathcal{M}$ iff $M \in \mathcal{M}$.
In the following, let a model $M_i$ be always an instance of model type $\mathcal{M}_i$.
This definition constitutes an \emph{extensional description} of models and does not explicitly consider actual instantiation relations between classes and objects, attributes and their values etc., other than containment in the respective model type. 
We also use the term \emph{metamodel} when referring to an abstract syntax of classes, attributes and associations, as defined in the OCL standard~\cite[A.1]{ocl}. 
A metamodel constitutes an \emph{intensional description} of models, from which the model type could be derived by enumerating all valid instances, i.e., all models with arbitrary instantiations of classes, their attributes and associations.

\subsection{Assumptions}

We assume models to be finite, so for each model $\model{m}{}$, we assume that $|\model{m}{}| < \infty$.
Additionally, our formalism assumes objects to be unique within a model $\model{m}{}$. 
This is already implicitly covered by the definition of $\metamodelinstances{M}$ for the instances of a metamodel $\metamodel{M}{}$. 
In practice, it is usually allowed to have the same object, i.e., an element with the same type, attribute and reference values, multiple times within the same model. 
This is, however, only a matter of identity, which we assume, without loss of generality, to be represented within the objects, whereas identity in practice is given by different objects being placed at specific places in memory.

% Our definition of models does not restrict validity of models apart from being a collection of instances of the classes in the metamodel.
% It is possible to define further constraints for metamodels that restrict their valid instances.
% We intentionally do not consider such restrictions of valid models, because even a single transformation 

\todoDiss{Discuss valid models, why we do not consider them and prove that invariants + consistency relations can express any consistency relation.
A single relation can consider constraints on the single models, but combination (even within one transformation) can easily contradict constraints of a model.}




\section{Running Example}







