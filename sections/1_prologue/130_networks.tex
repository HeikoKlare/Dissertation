\chapter{Models, Consistency and Processes
    \pgsize{10 p.}
}

\section{Consistency Types}

Discuss which types of consistency may exist (from Ellwangen retreat), how far they can be checked and what the mismatch is between pragmatic types of consistency and their verifiability.

Structural, behavioral, quality

Map to decidability (Turing completeness)

Discuss pragmatic distinction vs. decidability distinction

\todo{Derive limitations: for which types does our approach work?}



\section{Consistency Specification Processes}

\subsection{Roles}
* Define the process and roles:
** Domain expert
** Transformation developer
** Transformation network developer
** Transformation user
** Multiplicities
* Refer to Dagstuhl report with Mattias
* We call the users of transformation "engineers" (do we?) and the developers "domain experts"?

\subsection{Scenarios}

Discuss different scenarios: 

1. Put together transformations (COTS) and find out what is wrong or achieve that they work together
2. Develop transformations concurrently and find out whether they work together on-the-finally

\todoDiss{Discuss different benefits / scenarios more clearly, especially second benefit / application scenario: User define relations and wants on-the-fly feedback on compatibility to other existing relations, rather then a posteriori checking}



\section{Models and Metamodels}

We give an overview of the used elements in \autoref{tab:notation}.

\begin{table}
\centering
\renewcommand{\arraystretch}{1.4}%
%\rowcolors{2}{white}{gray!15}
%\setlength\tabcolsep{4 pt}
\begin{tabular}{R{4.8cm} L{5cm}}
\toprule
\multicolumn{2}{c}{Properties and Classes}\\
$P$                 
    & Property (attribute or reference) \\
$\metamodelinstances{P} = \setted{p_1, p_2, \dots}$     
    & Property values of a property $P$ \\
$\class{C}{} = \tupled{P_1, \dots, P_n}$
    & Class \\
$\metamodelinstances{C} = \setted{o = \tupled{p_1, \dots, p_n} \mid p_i \in \metamodelinstances{P_i}}$ 
    & Instances (objects) of a class $\class{C}{}$\\
$\object{o}{} \in \metamodelinstances{C}$
    & Object of a class $\class{C}{}$ \\
\midrule
\multicolumn{2}{c}{(Meta-)Models}\\
$\metamodel{M}{} = \setted{\class{C}{1}, \dots, \class{C}{m}}$
    & Metamodel\\
$\metamodelinstances{M} = \setted{m \mid m \subseteq \bigcup_{\class{C}{} \in \metamodel{M}{}} \metamodelinstances{C}}$
    & Instances of a metamodel\\
$\metamodelset{M} = \setted{\metamodel{M}{1}, \dots, \metamodel{M}{k}}$
    & Set of metamodels\\
$\metamodelinstances{\metamodelset{M}} = \setted{ \setted{\model{m}{1}, \dots, \model{m}{k}} \mid \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}}$
    & Instances of a metamodel set $\metamodelset{M}$\\
$\model{m}{} \in \metamodelinstances{M}$
    & Model of metamodel $\metamodel{M}{}$\\
$\modelset{m} \in \metamodelinstances{\metamodelset{M}}$
    & Model set of a metamodel set $\metamodelset{M}$\\
\bottomrule
\end{tabular}
\caption{Models, metamodels, their elements and notations}
\label{tab:prologue:elements}
\end{table}

\subsection{Notation}

In general, we use variables of uppercase letters for all elements at the metamodel level, such as $\metamodel{M}{}$ for a metamodel or $\class{C}{}$ for a class, whereas we use lowercase letters for all elements at the model level, such as $\model{m}{}$ for a model and $\object{o}{}$ for an object.
If not further specified, we use the same indices on related elements on the metamodel and the model level, such as model $\model{m}{1}$ being an instance of metamodel $\metamodel{M}{1}$.

\subsection{Elements}

In general, we consider metamodels as a composition of meta-classes, which in turn are composed of properties representing attributes or references.
Models instantiate metamodel and are composed of objects, which are instances of meta-classes and in turn consist of property values, which instantiate properties.

We denote \emph{properties}, which are the information a meta-class consists of, such as attributes or references, as $P$ and the \emph{property values} as instances of a property as $\metamodelinstances{P} = \setted{p_1, p_2, \dots}$ of property $P$. 
We do not need to further differentiate different types of properties into attributes and references, like it is done in other formalizations, such as the OCL standard~\cite[A.1]{ocl} or the thesis of \citeauthor{kramer2017a}~\cite[2.3.2]{kramer2017a}.

We denote \emph{meta-classes}, in the following shortly called \emph{classes}, as tuples of properties $\class{C}{} = \tupled{P_1, \dots, P_n}$. 
Instances of a \emph{class} are \emph{objects}, each being a tuple of instances of the properties of the class and we denote all instances of a class $\class{C}{}$ as $\metamodelinstances{C} = \setted{o = \tupled{p_1, \dots, p_n} \mid p_i \in \metamodelinstances{P_i}}$.

We denote a metamodel $\metamodel{M}{} = \setted{\class{C}{1}, \dots, \class{C}{m}}$ as a finite set of classes.
The instances of a metamodel are sets of objects $\metamodelinstances{M} = \setted{m \mid m \subseteq \bigcup_{\class{C}{} \in \metamodel{M}{}} \metamodelinstances{C}}$.
Each instance, denoted as a \emph{model}, is a finite set of objects that instantiate the classes in the metamodel.
For a set of metamodels $\metamodelset{M} = \setted{\metamodel{M}{1}, \dots, \metamodel{M}{k}}$, we denote the set that contains all sets of instances of that metamodels as $\metamodelinstances{\metamodelset{M}} = \setted{ \setted{\model{m}{1}, \dots, \model{m}{k}} \mid \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}}$.

%We use an extensional definition of metamodels, models and consistency relations, i.e. we enumerate the valid instances of a metamodel or the consistent pairs of models instead of intensionally describing how to derive them.
%Although actual modeling frameworks, such as EMF, and languages, such as QVT-R, use intensional specifications, the mathematical foundations of our approach are easier to describe in an extensional specification.
%However, expressiveness is the same, since an intensional specification can be, at least virtually, transformed into an extensional specification by enumerating all elements that fulfill the intensional specification.

%In general, we denote elements at the metamodel level with upper case letters and elements at the instance level with lower case letters. Tuples are denoted in angle brackets $\tupled{t}$.

%We denote models with lower case letters and indices $\model[1]{M}, \model[2]{M}, \ldots$.
%We denote elements of a model, such as meta-class instances, attributes values or reference instances, with lower case letters $e_1, e_2, f_2, f_2, \ldots$.

%We denote the instantiation relation between metamodels and models, as well as metamodel elements and model elements with instance sets:
%$\metamodelinstances{M}$ denotes the valid instances of a $\metamodel{M}$.
%$\metamodelinstances{E}$ denotes the instances of a metamodel element $E$.

\begin{definition}[Model]
A model $M = \{e_1, e_2, \ldots\}$ is a finite set of not further defined elements, such as objects, attribute and reference values.
\end{definition}

The exact representation of the model contents is not relevant for our work, which is why we use this lightweight definition. 
It allows us to transfer the insights to arbitrary models, such as models that are conform to the \ac{EMOF}~\cite{mof}.

\begin{definition}[Model Type]
A model type $\mathcal{M} = \{M_1, M_2, \dots\}$ is the (usually but not necessarily infinite) set of all models $M_1, M_2, \dots$ that are instances of $\mathcal{M}$.
\end{definition}

%So for a model type $\mathcal{M}$, a model $M$ is considered an instance of $\mathcal{M}$ iff $M \in \mathcal{M}$.
In the following, let a model $M_i$ be always an instance of model type $\mathcal{M}_i$.
This definition constitutes an \emph{extensional description} of models and does not explicitly consider actual instantiation relations between classes and objects, attributes and their values etc., other than containment in the respective model type. 
We also use the term \emph{metamodel} when referring to an abstract syntax of classes, attributes and associations, as defined in the OCL standard~\cite[A.1]{ocl}. 
A metamodel constitutes an \emph{intensional description} of models, from which the model type could be derived by enumerating all valid instances, i.e., all models with arbitrary instantiations of classes, their attributes and associations.

\subsection{Assumptions}

We assume models to be finite, so for each model $\model{m}{}$, we assume that $|\model{m}{}| < \infty$.
Additionally, our formalism assumes objects to be unique within a model $\model{m}{}$. 
This is already implicitly covered by the definition of $\metamodelinstances{M}$ for the instances of a metamodel $\metamodel{M}{}$. 
In practice, it is usually allowed to have the same object, i.e., an element with the same type, attribute and reference values, multiple times within the same model. 
This is, however, only a matter of identity, which we assume, without loss of generality, to be represented within the objects, whereas identity in practice is given by different objects being placed at specific places in memory.

% Our definition of models does not restrict validity of models apart from being a collection of instances of the classes in the metamodel.
% It is possible to define further constraints for metamodels that restrict their valid instances.
% We intentionally do not consider such restrictions of valid models, because even a single transformation 

\todoDiss{Discuss valid models, why we do not consider them and prove that invariants + consistency relations can express any consistency relation.
A single relation can consider constraints on the single models, but combination (even within one transformation) can easily contradict constraints of a model.}




\section{Running Example}

\begin{copiedFrom}{ICMT}
    
% EXEMPLARY PROBLEMS
Consider the simple consistency relations exemplified in \autoref{fig:properties:motivational_example}.
A company uses three software systems to manage (1)~personnel data, (2)~tasks and their assignment to employees, and (3)~schedules for work times of employees and the deadlines of tasks.
The domain models contain dependent information, especially the data about employees and their relations to tasks, but none of them contains a superset of information of another, which requires to define consistency between all pairs of them.
If three domain experts define %the consistency constraints between all pairs of the metamodels 
those binary constraints
independently, they can easily contradict. 
For example, imagine %that they specify 
a direct mapping of employee \emph{name} representations between the task management and scheduling system, a concatenation of \emph{firstname} and \emph{lastname} between personnel data and task management system and a comma-separated concatenation of \emph{lastname} and \emph{firstname} between personnel data and scheduling system.
These constraints are obviously incompatible, as they cannot be fulfilled at the same time.
%Additionally, even if the name mappings were compatible, specifying three transformations between all pairs of metamodels that preserve those constraints leads to redundancies within the transformations.
%In consequence, the transformation have to ensure that they no element duplications arise from that.
%%leads to redundant the operationalization of transformations that preserve these constraints has to ensure that no element duplications arise from redundant transformations paths. 
%%Additionally, even if the name mapping was compatible, the operationalization of transformations that preserve these constraints has to ensure that no element duplications arise from redundant transformations paths. 
%For example, after adding an employee to the personnel data system, a transformation adds an employee to the task management system, which is then transformed into an employee in the scheduling system. 
%The additional transformation between personnel and scheduling system must correctly consider that an employee was already created transitively.
%\todoHeiko{Checken, ob auf Duplizierungsproblem später verwiesen wird, dann hier wieder einfügen}

\begin{figure}[tb]
    \centering
    %\includegraphics[angle=270, width=\textwidth]{figures/motivation_employee_example.pdf}
    \input{figures/properties/motivational_employee_example.tex}
    %\caption{Exemplary Consistency Relations between a PCM, UML Class and Java Model}
    \caption{Exemplary Consistency Relations ({\protect\tikz[baseline=-0.5ex] \protect\draw[latex-latex, consistency related element] (0,0) -- (1.5em,0);}) between Three Simple Metamodels} %Personnel, Task Management and Scheduling System Metamodels}
    \label{fig:properties:motivational_example}
\end{figure}

% ABSTRACT PROBLEMS
While such a problem may be trivially solvable in this simple scenario, it gets difficult in systems with more and larger metamodels, %, especially in software development or system engineering scenarios, in which 
where
each domain expert only knows about the relation between two of them, but not about the others.
In consequence, each \ac{BX} has to be constructed in such a way that it can be combined with other, independently developed \acp{BX} in a \emph{black-box} manner later on.
Issues that arise from such a combination of independently developed \acp{BX} %the combination of independently developed \acp{BX} %to networks of them 
have not been investigated yet. %and categorized yet.
In consequence, potential failures, causal mistakes and techniques to avoid them by design are not systematically known.

\end{copiedFrom} % ICMT

