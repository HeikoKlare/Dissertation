\chapter{Introduction
    \pgsize{15 p.}
}

%\todo{Clearly introduce running example, removed from content section!}
%\todo{Introduce set notation, say that is it not practically applicable and a strong simplification, but just used to illustrate the problems and solution approaches} % Done at the end
%\todo{Introduce transitive operator R1 o R2 = (R1 u R2) * $\backslash$ (R1 u R2)} % Done at the end

%\todoConference{The problem the research intends to solve, the target audience of this research, and a motivation of why the problem is important and needs to be solved.}

\acl{MDSD} proposes the usage of models as primary artifacts of the %software 
development process~\cite{stahl2006a}. 
Those models describe different system properties for the interests of specific stakeholders, known as \emph{multi-view modelling}, or at different abstraction levels, representing refinements. In both cases, the models describe the same system and are thus not disjoint but contain redundant or dependent information. 
%\todoErik{Wieder: Die beschreiben ja keine Abstraktion, die sind eine Abstraktion. \enquote{Domains of the system} klingt auch komisch, ich weiß zwar, was Du meinst, aber nenne es nicht \enquote{domain}, sondern lieber \enquote{properties}}
Developers must be aware of those dependencies to ensure that models are modified consistently. 
%Otherwise, the deployed software, which is derived from those models, will potentially not operate correctly.
%\todoErik{Lenkt den Fokus etwas zu stark auf Korrektheit, die wir nicht formal beweisen. Es geht ja nicht nur darum, daß die Software nicht korrekt arbeitet -- möglicherweise tut sie das ja, obwohl die Modelle inkonsistent sind, und das Problem tritt erst bei der Wartung/Evolution auf.}

In large software systems, a single developer cannot know about all dependencies~\cite{petrenko2008a}, %which can be formulated as \emph{consistency constraints} and 
in the following referred to as \emph{consistency relations}, which inevitably leads to inconsistencies. 
Therefore, automated mechanisms that preserve consistency according to those consistency relations are necessary. 
For that purpose, incremental, bidirectional model transformations %or specialized model synchronization approaches 
are commonly used. However, most research considers \emph{binary transformations}, restricted to pairs of models, and does not explicitly consider consistency between more than two models~\cite{stevens2017a}, which we refer to as \emph{multi-model consistency}.
%In general, keeping more than two models consistent is currently not researched well.
Model transformations can either be specified imperatively or declaratively. They differ in who operalizationalizes the preservation of constraints that have to hold, in the first case the transformation developer and in the second case an automated mechanism of the transformation language. This is why we do not explicitly distinguish these approaches, as all problems apply to both approaches and only different roles have to deal with them. 
% Model transformations can either be specified imperatively, such that the transformation developer has to define how to react to a change, or declaratively, such that the transformation developers only the constraints that have to hold and an automated mechanism derives an imperative operationalization from that.
% We will not explicitly distinguish these approaches, as the identified problems and our solution proposals apply to both. The only difference is that in imperative approaches the transformation developer has to deal with them and in declarative approaches the developer of the transformation language has to consider them when defining the generation of the operalizalization.

Although it is possible to combine binary transformations by transitively executing them, it is yet unclear what problems may arise from that, especially if each transformation is developed independently and treated as a black box.
We will exemplify this on the simple example in \autoref{fig:prologue:binary_combination_example}, in which consistency relations define a mapping of a component in an \ac{ADL} to a class in object-oriented design, which is again represented by an implemented class in Java code. 
The name of the class is defined to be the component name with an \enquote{Impl} suffix (cf.~\cite{langhammer2017a}).
When all these relations are expressed in transformations, it is, for example, possible that both transformations from \ac{ADL} to Java, once over \ac{UML} (\ref{fig:prologue:binary_combination_example:R1} and \ref{fig:prologue:binary_combination_example:R2}) and once directly (\ref{fig:prologue:binary_combination_example:R3}), create a Java class after creating an \ac{ADL} component.
We refer to that as an \emph{interoperability problem}.
The transformation specification %or its execution engine 
would have to avoid an overwrite and therefore have to consider dependencies between transformations, using, for example, a shared trace model.
In general, an interoperability problem is an unexpected behavior of transformations, which only occurs if they are executed transitively, but not if each is executed on its own. %, although all preserve the same consistency relations.

Additionally, it is easy to see that %specifying multi-model consistency with combinations of 
combining binary transformations leads to trade-off decisions.
The ternary relation %between the three metamodels 
can either be expressed by three binary transformations between all pairs of metamodels or by two binary transformations with the third being %expressed by the transitive 
the combination of the two others.
The first option leads to redundancies in the specifications, as each pair of transformations has to have an equal semantics than the third.
For example, the \ac{ADL} to Java transformation for \ref{fig:prologue:binary_combination_example:R3} must be equal to the combination of the transformations \ac{ADL} to \ac{UML}~(\ref{fig:prologue:binary_combination_example:R1}) and \ac{UML} to Java~(\ref{fig:prologue:binary_combination_example:R2}).
Consequently, those transformations may be incompatible if not correctly defined, e.g., by leaving out the suffix addition in the transformation for \ref{fig:prologue:binary_combination_example:R3}.
%As an alternative, the second option is express the ternary relation with two binary consistency relation specifications.
%For example, specification \ref{fig:example:R3} can be interpreted as a combination of \ref{fig:example:R1} and \ref{fig:example:R2}.
An alternative is to omit the transformation for \ref{fig:prologue:binary_combination_example:R3} by transitively executing the two others.
However, in this case, modularity is reduced, because it is not possible to use only Java and the \ac{ADL} to develop a specific system and omit the \ac{UML}.
%Additionally, comprehensibility decreases, because the relation between \ac{ADL} and Java is only expressed transitively. 
%This becomes more problematic if transformation paths have a length higher than two.
We refer to this as \emph{specification trade-offs}.

\begin{figure}
    \centering
    \input{figures/prologue/binary_combination_example.tex}
    \caption{Example models with binary consistency relations}
    \label{fig:prologue:binary_combination_example}
\end{figure}

%Although specific approaches for expressing multiary relations, rather than using combinations of binary relations, could be developed, there are some reasons for adhering to binary transformations.
Instead of developing approaches to express multiary consistency relations, there are reasons to adhere to binary transformations, and to research their combinability.
As stated by \textcite{stevens2017a}, %there are especially strong practical reasons, as 
it is hard enough to think about binary relations. %between pairs of models.
%Defining multiary relations would require a knowledge about the relations between all metamodels used to describe a system.
Additionally, each domain expert, who specifies transformations, %in practice, 
will usually only have knowledge about the relations between two or at most a rather limited set of metamodels. %, but not of all involved metamodels. %, which would be necessary to define multiary relations.
%Thus, it is a natural goal to make the modular specification of consistency based on binary transformations possible.
%In the proposed thesis, 
We therefore plan to make the following contributions to research on multi-model consistency preservation:
%\todoErik{Ich fänd's cool, wenn die Probleme auch irgendwie hervorgehoben sind, und Du die Beiträge schon auf die Probleme beziehen kannst, also Mini-PIBA für jedes Deiner identifizierten Probleme. Würde aber erst die Probleme formulieren, dann den IBA-Teil so wie unten (wobei bei manchen noch die Beschreibung des Benefits fehlt).}
\begin{description}[leftmargin=\parindent]
    \item[Transformation interoperability.] %Under the assumption that 
        When several binary transformations are developed independently, they must be combinable in a black box manner, introduced as the \emph{interoperability problem}. We will therefore identify problems that can arise from that combination %of transformations 
        and develop a catalog of patters that can be followed by the transformation developer or language to achieve \emph{non-intrusive} interoperability of binary transformations.
    \item[Decomposition of consistency relations.] 
        The usage of binary transformations for multi-model consistency preservation leads to \emph{specification trade-offs} regarding essential challenges. We will provide a classification of those challenges and investigate the influence of the way in which transformations are specified on them.
        %Decomposing the underlying consistency relations into independent sub-relations allows a partial optimization regarding those challenges.
        %We will therefore investigate how consistency relations can be decomposed into independent subsets.
        We will especially investigate how consistency relations can be decomposed into independent subsets, as this allows a partial optimization regarding those challenges.
    %We will identify relevant properties of consistency specifications, which have to be considered when defining those specifications as they introduce trade-off decision. We already motivated some of those properties above and give a more detailed overview in \autoref{sec:multimodelconsistency}.
    \item[Make common concepts explicit.] 
        Metamodels often represent the same concepts in different ways. As another contribution to reduce \emph{specification trade-offs}, we propose an approach to make these common concepts explicit to improve comprehensibility of transformations and to improve their modular reuse.
\end{description}

% We propose an approach for multi-model consistency based on \aclp{VOMM}. 
% In those virtual metamodels, dependencies between metamodels, which we refer to as \emph{consistency relations}, are made explicit by representing common concepts, whereas in model transformations, which we refer to as \emph{consistency preservation specifications}, they are specified implicitly. 
% The envisioned benefit is an inversion of the above mentioned properties. 

Throughout this paper, we use a simplified notation for metamodels and heir consistency relations to ease their illustration. 
We consider metamodels to be sets of elements and consistency relations to be sets of symmetric, binary relations between those elements.
To ease the representation of combinations of consistency relations, we define the concatenation operation for two consistency relations $R_1$ and $R_2$ as:
\begin{equation*}
    R_1 \concat R_2 \coloneqq \{(x,y)\, |\, \exists t: x\, R_1\, t\, R_2\, y \}.
\end{equation*}
This is the subset of the transitive closure of two relations that contains only the relations transitively defined over $R_1$ and $R_2$.
It can be also expressed as the natural join of $R_1$ and $R_2$ with an additional projection that removes the common elements of both relations.
The operator is commutative since the relations are assumed symmetric.

% \todoErik{Würd ich bei so einem kurzen Paper weglassen. (Ich würde es auch oft bei langen Papern weglassen. :-))}
% In this paper, we first discuss related work in \autoref{sec:relatedwork}. 
% In \autoref{sec:approach}, we give an overview of our planned contributions by explaining the problems in detail and sketching our solution approaches. %we first discuss interoperability problems arising from the combination of independently developed binary transformations and give an overview on envisioned solution patterns.
% %We then give an introduction to the yet identified challenges inducing trade-off decisions during transformation development.
% %From this, we derive the consideration of consistency relation composition and an approach to make common concepts explicit.
% % We then discuss problems arising from the black-box combination of binary transformations and give an overview on envisioned solution patterns.
% % In \autoref{sec:vomms}, we introduce our approach to make overlaps of metamodels explicit to improve properties of multiary consistency specifications.
% Finally, we discuss the current state and planned evaluation in \autoref{sec:status} and conclude the paper in \autoref{sec:conclusion}.


% \begin{itemize}
%     \item Motivation MDSD
%     \item Several models describe single system
%     \item Information overlap between models, e.g. component architecture and code, ref to Michael
%     \item Developers must be aware of redundancies and dependencies, otherwise inconsistencies
%     \item Best: Make redundancies/dependencies explicit for (semi-)automated mechanisms for preserving consistency
%     \item Incremental model transformations can be used (refs) or specialized model consistency or model synchronization approaches (refs)
%     \item Existing approaches only concern consistency preservation between instances of two metamodels
%     \item If more than two models are involved, these approach would require that consistency preservation is executed transitively
%     \item From that, problems arise
%     \begin{itemize}
%         \item Inconsistent consistency specifications: Consistency specifications between different metamodels must be consistent. E.g. having 3 metamodels, a consistency specification between two of them can be contradictory to the two other
%         \item Consequence: Result of a modification depends on the order in which consistency specification are evaluated or even results in propagation cycle due to alternating changes -- EXAMPLE
%         \item Ordering problem: Preserving consistency after a change can require several changes in other models. The order in which they are executed can produce different results -- EXAMPLE
%         \item Confluence problem: Changes can be propagated across several paths, if more than two models are involved. This can result in conflicts, if the propagation confluences in one model. E.g. it can be necessary to create a metaclass instance in that model to preserve consistency. All confluencing change propagations require the creation of an element, but how can you achieve that only the first one creates it and the other see the new element and reference it instead?
%     \end{itemize}
% \end{itemize}

%\todoHeiko{Define metamodel vs. \modelinglanguage, Use \modelinglanguage or DSL?}
%\todoHeiko{Say: code is also a model}
%\todoHeiko{Define: \emph{consistency relation} for existing relationships between metamodels that require consistency preservation and \emph{consistency preservation specification} for mechanisms that semi-automatically preserve consistency according to an existing consistency relation}
%\todoHeiko{We refer to the process of preserving consistency due to defined consistency preservation specifications as \emph{change propagation}, as a performed change resulting in the violation of consistency relations leads is propagated to restore consistency -- Besser change propagation überall weglassen.}
%\todoHeiko{Introduce trace links and their necessity for identifying corresponding elements according to consistency relations (prescriptive vs. descriptive)}


%\todo{Klarmachen, dass es immer darum geht Konsistenzrelationen durch bidirektionale, binäre Transformationen auszudrücken. Das ist die Baseline.}

%\todo{Klarmachen, dass Kombination binärer Transformationen der state-of-the-art ist.}