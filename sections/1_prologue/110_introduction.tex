\chapter{Introduction
    \pgsize{25 p.}
}
\label{chap:introduction}

\mnote{High-level thesis summary}
In this thesis, we discuss how multiple artifacts used to develop a software or software-intensive system can be kept consistent by combining transformations between their specification languages.
We research how multiple transformations, which specify consistency and its preservation, can be developed \emph{independently}, such that their combination operates \emph{correctly} and such that they can be reused \emph{modularly}.

\mnote{Introduction outline}
In the following sections, we first introduce the context of preserving consistency between multiple artifacts and identify existing challenges. We then derive two problem statements from these challenges and define a research goal along with fine-grained questions, as well as according contributions that counter these challenges.
Finally, we give an overview of the structure of this thesis and give guidelines how to read it.


%%
%% MOTIVATION
%%
\section{Consistency of Multiple Models}

\mnote{Increasing system complexity}
Engineers develop software and software-intensive technical systems of ever increasing scale.
This leads to a continual increase in complexity of the artifacts used to describe such systems~\cite{murer2011evolution}.
As a direct consequence of the increasing system sizes, engineers inevitably have to deal with their inherent \emph{essential complexity}.
Various tools support the development process by reducing the \emph{accidental complexity} to allow engineers to focus on handling the essential complexity~\cite{brooks1987NoSilverBullet-Computer, fraser2008NoSilverBulletReloaded-Software}.

\subsection{Consistency in System Engineering}

\mnote{Fragmented information to deal with essential complexity}
To better handle the essential complexity of a system, engineers usually use multiple tools to describe and analyze different parts or properties of a system under development in different artifacts~\cite{franzago2018mdseChallenges-TSE}.
In the following, we denote all these artifacts as \emph{models}, according to the notion of \citeauthor{bezivin2005sosym} that \enquote{everything is a model}~\cite{bezivin2005sosym}, including source code, for example, written in Java~\cite{heidenreich2010jamopp-SLE}.
This reduces the information to deal with to what is relevant for the development task of each person's role~\cite{stevens2018bidirectionality-ECMFA}.
In classical engineering disciplines like construction, mechanical and electrical engineering, this has been common practice for a long time and is often called \emph{\gls{MBSE}}~\cite{estefan2007MbseSurvey}.
For example, developers of software for \glspl{ECU} in automobiles use different tools and standards for specifying the system and software architecture, such as SysML~\cite{sysml} or AUTOSAR~\cite{scheid2015autosar}, for defining the behavior, such as MATLAB/Simulink~\cite{simulink} or ASCET~\cite{ascet}, and for defining the deployment on multi-core architectures, such as Amalthea~\cite{wolff2014a}.
In software engineering, such a development methodology is also getting growing attention.
It is often referred to as \emph{\gls{MDSD}}~\cite{stahl2006mdsd-Book}.
Such a development process considers other artifacts beyond code as primary artifacts to describe the system under construction.
While code focuses on specifying the functionality of a system, other tools can be used, for example, to explicitly define the software architecture and its deployment, such as the \gls{UML}~\cite{uml}, analyzing and predicting the software performance, such as the Palladio Simulator~\cite{reussner2016a}, and for specifying requirements, like IBM Rational Doors~\cite{laplante2012RequirementsEngineering-Book}.

\mnote{Accidental complexity due to information fragmentation}
While this \emph{fragmentation} of information across models developed with different tools eases dealing with the essential complexity of a system, it increases accidental complexity.
Since all these models describe the same system, they usually share an overlap of information in terms of implicit \emph{dependencies} or \emph{redundancies}.
If modifications in overlapping information are not propagated correctly across all dependencies and redundancies, \emph{inconsistencies} can occur.
For example, requirements changes have to be reflected in the software architecture and implementation, and modifications of the architecture must be reflected in the code.
Since systems are usually developed iteratively and incrementally, dependencies are not directional but, in general, every model can be changed and require updates of others.

\mnote{Consistency of fragmented information}
The overlaps of information, for example in tools for \gls{ECU} software development~\cite{giese2010a}, are often not documented explicitly~\cite{mazkatli2017ase}, but only known by engineers.
Performing the task of updating overlapping information manually is, however, time-consuming and error-prone~\owncite{sax2017survey}.
The automation of checking and of preserving consistency of information is still poorly supported in current development processes for large systems~\ownandothercite{guissouma2018study}{paige2016evolvingModel-JSS,cicchetti2019multiview-SoSym}.
Automating that process is, however, necessary to reduce the accidental complexity induced by information fragmentation across multiple models.

\mnote{Transformations for binary consistency}
A common approach to automate the process of checking and preserving consistency of models are \emph{incremental model transformations}, which have already been applied in industrial scenarios~\cite{giese2009incrementalModelSynchronization-SoSym, giese2010a}.
Tools describe their models in specific languages, for example denoted by \gls{XML} schemes.
A transformation specifies how models of one or multiple such languages have to be updated after engineers make changes to a model of another language.
The subclass of \emph{bidirectional} model transformations~\cite{stevens2010sosym}, which specify the relations between two models and routines that restore consistency of their instances after any of them was changed, is particularly well researched~\cite{cleve2019dagstuhl,kahani2019SurveyTransformationTools-SoSym}.
System development usually involves more than two tools, and thus models of more than two languages have to be kept consistent.
The use of transformations to check and preserve consistency between more than two models is, however, less researched~\cite{stevens2020BidirectionalTransformationLarge-SoSym}.
It recently gained attention in a dedicated Dagstuhl seminar~\cite{cleve2019dagstuhl}.


\subsection{Distributed and Reusable Consistency Knowledge}

\mnote{Multidirectional transformations vs. networks}
Two general transformation-based approaches for preserving consistency of multiple models are \emph{multidirectional} transformations and combining multiple bi- or multidirectional transformations to networks of them.
In theory, a single multidirectional transformation provides higher expressiveness~\cite{stevens2020BidirectionalTransformationLarge-SoSym} and benefits from not being prone to contradictions between the transformations to be combined.
For practical application, however, multidirectional transformations suffer from missing modularity, as a single person or team must define the overall relations between all languages.
Additionally, it is difficult to think about complex multiary relations between models of multiple languages~\cite{stevens2020BidirectionalTransformationLarge-SoSym} and, even worse, the required knowledge to define such a relation may not even exist~\owncite{klare2018docsym}.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/distributed_knowledge.tex}
    %\includegraphics[width=\textwidth]{figures/prologue/introduction/distributed_knowledge.png}
    \caption[Tools and distributed knowledge in engineering processes]{Different tools and roles involved in an exemplary software development process and distributed knowledge about the relations between models of the different tools.}
    \label{fig:introduction:distributed_knowledge}
\end{figure}

\mnote{Distributed knowledge about consistency}
Domain experts deal with the tools and corresponding models they require for their tasks in developing a system.
Usually, each of them is only concerned with a subset of all tools involved in the development of a system.
For example, a performance engineer may be concerned with an instance of the \gls{PCM}, which represents a component-based architecture description of the system for the Palladio Simulator, to perform an architecture-based prediction of the system's performance and know how this description is reflected in the system implementation with Java.
A software architect may use \gls{UML} models for the architecture specification and know how they are related to the implementation as well as to the \gls{PCM} architecture models.
Finally, a requirements engineer may use IBM Rational Doors and know how requirements have to be reflected in the architecture specification and implementation to consider the models consistent.
These exemplary relations are depicted in \autoref{fig:introduction:distributed_knowledge}.
No matter whether this is how knowledge is actually present at the different roles in a concrete scenario, it emphasizes that knowledge about the relations between languages and their models will usually be distributed across different experts whenever multiple models are involved.
In large software systems, a single developer cannot know about all model dependencies~\cite{petrenko2008a}.
In consequence, a process for specifying consistency by means of transformations has to support a kind of \emph{modularity} to foster independent specification of distributed knowledge.

\mnote{Reuse of consistency specifications}
Furthermore, an automation especially proposes benefits if it is used often.
A specification of consistency and its preservation between common languages, such as the \gls{UML} and a programming language like Java, can be reused across multiple projects.
Not every project will, however, use exactly the same tools.
Considering the example in \autoref{fig:introduction:distributed_knowledge}, if the relation between \gls{PCM} and Java was, at least partly, expressed indirectly across the relations between \gls{PCM} and \gls{UML} as well as \gls{UML} and Java, it would not be possible to reuse that specification in another project that only uses \gls{PCM} and Java but omits \gls{UML}.
Thus, parts of the consistency specifications, i.e., specifications for subsets of the tools in a project, should be reusable, comparable to \glspl{RUSP}~\cite{iso25051}.
In consequence, a process for specifying consistency by means of transformations has to support the \emph{independent} specification of \emph{modular} transformations, which can be combined with arbitrary other modular transformations in different contexts.

\mnote{Context assumptions}
To support the context induced by the previous considerations, we focus on combinations of transformations, be they bidirectional or multidirectional, instead of having only a single multidirectional transformation.
We call such a combination a \emph{transformation network}.
To summarize the previous considerations, we need to cover the following context assumptions to the specification of the individual transformations of a network.
\begin{properdescription}
    \item[Modular:] Transformations are defined in a modular way, i.e., each transformation does only specify consistency and its preservation for a subset of the tools used in an actual development project.
    \item[Independent:] Transformations are defined independently, i.e., each transformation can be developed without considering the contents of the other transformations that it is to be combined with.
\end{properdescription}


\subsection{Orchestration of Transformation Networks}
\label{chap:introduction:consistency:orchestration}

\mnote{Limitations of transformation orchestration}
Combining several modular and independently developed transformations requires their \emph{orchestration}, i.e., the determination of an order in which they are executed to restore consistency.
Existing work proposes, for example, to define an execution order explicitly~\cite{pilgrim2008constructingChains-ECMDA, vanhooff2007UniTI-MODELS} or to derive a kind of topological order~\cite{stevens2020BidirectionalTransformationLarge-SoSym}.
Such approaches either require manual decisions for the orchestration or restrict the execution to specific topologies, such as directed acyclic graphs or trees.
In each case, strong assumptions to the individual transformations or the topology of the networks are made.

\mnote{Universal combination of specifications}
It is still unclear how arbitrary modular and independently developed transformations can be combined in a universal way.
It is neither known how a developer can achieve a \emph{correct} transformation network specification, i.e., transformations and an orchestration of them that delivers consistent models when applied, nor how he or she can systematically improve quality properties of the network such as \emph{comprehensibility}.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/overall_process.tex}
    %\includegraphics[width=\textwidth]{figures/prologue/introduction/overall_process.png}
    \caption[Process of specifying and executing a transformation network]{The process of specifying and executing a transformation network.
    Project-specific development artifacts (transformations) are marked orange and the universal application artifacts (orchestration with a resulting transformation network) are marked green.
    Concrete systems and changes represent runtime artifacts.
    The assumed and envisioned properties are denoted in red and italics.}
    \label{fig:introduction:process_overview}
\end{figure}

\mnote{Envisioned properties and process}
Under the assumption of a modular and independent specification of the individual transformations, we aim at an approach for executing transformation networks that has the following properties.
\begin{description}
    \item[Universal:] The approach shall be able to process transformation networks of arbitrary topology. In particular, specific topologies cannot be assumed or prescribed if independent development shall be supported.
    \item[Non-Intrusive:] The approach shall not modify the transformations. When independently developed transformations are combined to a network, they should be treated as black-boxes and there should be no need to adapt them to be used together.
    \item[Correct:] The approach shall produce correct results. When it applies transformations, it must return consistent models or indicate an error. The identification and definition of an appropriate notion of correctness is part of the contributions of this thesis.
    \item[Comprehensible:] The approach shall improve comprehensibility. If the transformations are not able to yield models that are actually consistent, it should support the user in finding the reason for that.
\end{description}
The envisioned process with the involved roles, artifacts and required properties is depicted in \autoref{fig:introduction:process_overview}.
Different domain experts specify transformations, which are combined to a network with an orchestration mechanism that decides in which order transformations have to be executed. If an actual system is developed and a system developer modifies models, the transformations of the network are applied to these models and changes to produce a consistent system description again.

\mnote{Thesis contributions}
In this thesis, we contribute to support the process of building transformation networks that have the defined properties by providing a formal foundation for transformation networks of arbitrary topology and defining a formal notion of correctness for them.
We discuss how correctness of a universal approach to orchestrate and apply the transformations of a network can be achieved by construction or at least by analysis, and which properties the different involved artifacts, such as transformations and their orchestration, have to fulfill for that.
The proposed strategy to orchestrate transformations improves comprehensibility in cases in which it is not able to execute transformations in an order such that the resulting models are consistent.
Additionally, we classify which kinds of errors can occur when the transformations and their orchestration are not defined correctly.
Finally, we analyze how topologies of networks affect the desired properties and propose an approach of defining transformations that resolves trade-offs between the envisioned properties.

\mnote{Towards detailed problem statement}
In the following, we first discuss the addressed challenges in more detail by considering a specific scenario and generalizing some of the challenges to give a first impression of the issues we have to address.
We then derive two general problem statements from the identified challenges.
Afterwards, we derive our central, general research goal and define several questions arising from that, which address the problem statements.
After more precisely specifying the context and assumptions that we make, we give a detailed overview of our contributions.



%%
%% PROBLEM DESCRIPTION -> RESEARCH GAP
%%
\section{Consistency Specification Challenges}

\mnote{Motivational scenario}
To get an impression of problems arising from the combination of modular transformations, we introduce an exemplary scenario from a software engineering process.
We motivate why we expect that multiple executions of the same transformation can be necessary and discuss some of the issues that can occur in that context.
Afterwards, we generalize that scenario and derive a more precise problem statement.

\mnote{Software engineering scenario}
We consider an extract of a software engineering scenario, in which three roles using three different tools are involved, according to \autoref{fig:introduction:distributed_knowledge}. 
A software developer implements the system with an object-oriented programming language such as Java.
An architect manages the object-oriented architecture of the system with the \gls{UML}. 
Finally, a performance engineer uses a component-based representation of the architecture with the \gls{PCM} containing an abstract behavior description at the architecture level to predict the system's performance to evaluate different design options.

\mnote{Contents of \gls{PCM}}
The basic entities in \gls{PCM} models are components, interfaces and data types.
Components are units of reuse that define which interfaces they provide or require and contain abstract service specifications for the operations of the interfaces they provide.
This allows to assemble a system of components by connecting components through their interfaces, such that every required interface of one component is provided by a defined other component.
For the consistency relations between the three languages \gls{PCM}, \gls{UML} and Java, which specify when models of those languages are to be considered consistent, we use the ones proposed by \textcite{langhammer2017a} between \gls{PCM} and object-oriented design, be it \gls{UML} or Java, and the intuitive notion of consistency between \gls{UML} and Java.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/scenario_consistency_relations.tex}
    %\includegraphics[width=\textwidth]{figures/prologue/introduction/scenario_consistency_relations.png}
    \caption[Consistency relations for \acrshort{PCM} and \acrshort{UML}/Java]{Extract of consistency relations between component-based architectures in \gls{PCM} and object-oriented design in \gls{UML}/Java according to \textcite{langhammer2017a}. (Blue) lines with arrowheads indicate that the connected elements share a consistency relation. Properties, such as names, are omitted.}
    \label{fig:introduction:scenario_consistency_relations}
\end{figure}

\mnote{Consistency relations between \gls{PCM}, \gls{UML} and Java}
Although there are several degrees of freedom when relating \gls{UML} and Java models, the extracts that we consider follow a simple one-to-one mapping.
The relevant relations between elements in \gls{PCM} and object-oriented design are depicted in \autoref{fig:introduction:scenario_consistency_relations}.
This involves a one-to-one mapping between interfaces, and the realization of \gls{PCM} components as classes. 
Provided interfaces in a \gls{PCM} model are realized by interface implementations of the class realizing the component. 
Required interfaces are realized by a field with the type of the interface and constructor parameters that ensure that the required interfaces are set on instantiation of the component.

%% CORRECTNESS
\subsection{Correctness of Transformation Networks}

One central goal of (software) engineering, and thus the construction of transformation networks as part of that process, is to achieve \emph{correctness}, more precisely \emph{functional correctness}~\cite[p.~11]{iso25010}, of the developed artifacts.

\subsubsection*{Orchestration Challenge}
\label{chap:introduction:challenges:correctness:orchestration}

% 1. Orchestration problem
\mnote{Single execution of transformations}
When we consider transformations between \gls{PCM} and \gls{UML}, as well as between \gls{UML} and Java, they can transfer each modification to the other models.
For example, adding a \gls{PCM} component creates a \gls{UML} class, which in turn creates a class in Java code.
Although in many cases each transformation only needs to be executed once, there can be situations that require transformations to be executed repeatedly.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/scenario_duplicate_execution.tex}
    %\includegraphics[width=\textwidth]{figures/prologue/introduction/scenario_duplicate_execution.png}
    \caption[Example for transformation orchestration]{Duplicate transformation execution after adding a field representing a required interface to a Java class. Arrows indicate changes performed by a user or a transformation.}
    \label{fig:introduction:scenario_duplicate_execution}
\end{figure}

\mnote{Multiple executions of same transformation}
In the process depicted in \autoref{fig:introduction:scenario_duplicate_execution}, we assume a system description that contains at least one component and class, respectively, and one interface.
If a developer adds a field to the Java class having the type of the interface, the transformation between \gls{UML} and Java transfers this field to the corresponding \gls{UML} class.
The transformation between \gls{UML} and \gls{PCM} detects that the interface is also represented as an architectural interface in the \gls{PCM} model, thus the field is supposed to represent a required interface in the architectural model.
In consequence, the transformation adds a required interface to the \gls{PCM} component.
Since the consistency relations prescribe each required interface to be represented as a constructor parameter, the transformation also adds a constructor parameter to the class in the \gls{UML} model.
This finally requires the transformation between \gls{UML} and Java to be executed again, because the constructor parameter introduced by the transformation between \gls{PCM} and \gls{UML} must also be added to the Java code.

\mnote{Orchestration challenge}
The example demonstrates that it is, in general, necessary to execute each transformation in a network more than once to achieve a consistent state of the models.
This is always the case if at least two transformations modify the same model, because the first executed transformation may need to react to changes of second one again, like the transformation between \gls{UML} and Java needs to react to the one between \gls{PCM} and \gls{UML}, because both modify the \gls{UML} model.
We consider the determination how often and in which order transformations must be executed as the \emph{orchestration challenge}.

\subsubsection*{Synchronization Challenge}
\label{chap:introduction:challenges:correctness:synchronization}

% 2. Synchronization problem
\mnote{Transformation between \gls{PCM} and Java}
Up to now, we have assumed a chain of two transformations, one between \gls{PCM} and \gls{UML} and another between \gls{UML} and Java.
There may, however, also be an overlap of information between \gls{PCM} and Java models that cannot be represented in the \gls{UML}, which requires an additional transformation between \gls{PCM} and Java.
This is especially the case for behavioral properties, which cannot be expressed in \gls{UML} class models, such as the functionality defined by Java methods and the abstract service specifications in the \gls{PCM}.
In consequence, the graph induced by those transformations contains a cycle.

\mnote{Redundancies in transformations}
Instead of only having a transformation for that overlapping information of \gls{PCM} and Java models that cannot be expressed across the \gls{UML}, the transformation may also contain the relations already expressed across the \gls{UML}.
Reasons for that can be independent development and reusability.
Independent development leads to the situation that the developer of the transformation between \gls{PCM} and Java does not know what the transformations to \gls{UML} already express.
Even if the developer has this information, he or she may want to express it again to foster reusability, i.e., to use the transformation between \gls{PCM} and Java in projects in which the \gls{UML} is not used or when the transformation is not supposed to be used in a specific network of transformations, comparable to \glspl{RUSP}.
In consequence, we need to face the situation that multiple transformations propagate the same information, i.e., they contain redundancies.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/scenario_synchronization.tex}
    %\includegraphics[width=0.8\textwidth]{figures/prologue/introduction/scenario_synchronization.png}
    \caption[Example for transformation synchronization]{Two transformations propagating the same information to Java code. Arrows indicate changes performed by a user or a transformation.}
    \label{fig:introduction:scenario_synchronization}
\end{figure}

\mnote{Two transformation paths creating Java class}
\autoref{fig:introduction:scenario_synchronization} depicts a scenario in which a user creates a \gls{PCM} component.
The transformations, in consequence, create a \gls{UML} class and, finally, both the transformation between \gls{UML} and Java as well as the one between \gls{PCM} and Java specify the creation of an appropriate Java class.
These transformations now have to consider that there may be another transformation that has already created that class.
Otherwise, there is the risk of creating a duplicate of that class or of overwriting the already created one.

\mnote{Synchronization challenge}
Such a problem can always occur if two sequences of transformations propagate the same information to the same model.
How to achieve that transformations deal with such cases constitutes the \emph{synchronization challenge}.

\subsubsection*{Contradiction Challenge}
\label{chap:introduction:challenges:correctness:contradiction}

% 3. Contradiction problem
\mnote{Equivalence of redundancies}
We have seen that it may be necessary to redundantly define the same consistency relations in different transformations.
This, however, implicitly assumes that they are true redundancies, i.e., that they equally express the same relations.
This, in turn, requires all developers to have the same \emph{notion of consistency} between the different tools.

\mnote{Contradicting relations}
The example in \autoref{fig:introduction:scenario_contradiction} informally depicts exemplary consistency relations between components and classes.
They are supposed to express that for each component or class appropriate elements in the other models have to exist that fulfill the given name relation.
The constraints for their names can, however, obviously not be fulfilled at the same time.
While the class representations are supposed to have the same name, the \gls{PCM} component is supposed to have the same name as the \gls{UML} class but the name of the Java class with an \enquote{Impl} suffix, as proposed by \textcite{langhammer2017a}.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/scenario_contradiction.tex}
    %\includegraphics[width=0.8\textwidth]{figures/prologue/introduction/scenario_contradiction.png}
    \caption[Example for transformation contradictions]{Contradicting consistency relations between components in \gls{PCM}, classes in \gls{UML}, and classes in Java. The equations are meant to express that for any existing element another element must exist such that the condition is fulfilled.}
    \label{fig:introduction:scenario_contradiction}
\end{figure}

\mnote{Different notions of consistency}
Such a situation can occur if the developers of different transformations have different notions of consistency.
According to the scenario in \autoref{fig:introduction:distributed_knowledge}, a performance engineer, who knows about the relation between \gls{PCM} and Java, and a software architect, who knows about the relation between \gls{PCM} and \gls{UML} as well as between \gls{UML} and Java, have different notions of how to represent components in object-oriented design.

\mnote{Non-termination or inconsistent termination}
If the domain experts encode the defined relations in transformations that preserve them and execute them after any of the elements is added to a model, the transformations will either terminate in an inconsistent state or never terminate at all.
Executing the transformation for a finite number of times would always result in an inconsistent state, if not removing the element just added by the user.

\mnote{Contradiction challenge}
In consequence, it is important to avoid or detect situations in which transformations with such contradicting constraints in their consistency relations are combined to a network.
We call this the \emph{contradiction challenge}.

\subsubsection*{Problem Statement}

\mnote{Systematic knowledge on correctness challenges}
We have discussed three kinds of issues, which can prohibit that a transformation network terminates consistently, and derived according challenges: orchestration, synchronization and contradiction.
These challenges only exemplify the relevant correctness issues in transformation networks. 
In fact, it is even not systematically known which issues can occur.
Thus, we derive the following general problem statement.

\begin{problemstatement}
    It is unknown how to correctly combine modular and independently developed transformations to networks to yield consistent models after they were changed.
\end{problemstatement}

%% QUALITY PROPERTIES
\subsection{Quality of Transformation Networks}

\mnote{Quality properties of networks}
Like in ordinary (software) engineering, besides the primary goal of producing \emph{correct} artifacts, several quality properties shall or need to be improved.
They can range from properties that are relevant for developers, such as reusability and modifiability, to properties relevant for users, such as performance, usability and reliability~\cite[p.~4]{iso25010}.
This also applies to transformation networks as artifacts of the (software) engineering process.

\subsubsection*{Properties and Topologies Challenge}
\label{chap:introduction:challenges:quality:properties}

\mnote{Focus on development properties}
In this thesis, we focus on further properties regarding the development of a transformation network, such as reusability and modifiability, rather than properties of its usage, such as performance.
Reusability is of most importance, because transformations may be used in different contexts within different networks of other transformations.

\begin{figure}
    \centering
    \input{figures/prologue/introduction/scenario_topologies.tex}
    %\includegraphics[width=\textwidth]{figures/prologue/introduction/scenario_topologies.png}
    \caption[Example for network topologies]{Different transformation network topologies between \gls{PCM}, \gls{UML} and Java.}
    \label{fig:introduction:scenario_topologies}
\end{figure}

\mnote{Topology extremes}
Consider the two networks sketched in \autoref{fig:introduction:scenario_topologies}.
The networks contain transformations between \gls{PCM} and \gls{UML} as well as between \gls{UML} and Java. 
One of them additionally contains a transformation between \gls{PCM} and Java.
They can be considered as representatives of extremes of transformation networks:
the graph induced by transformations may on the one end be a tree, and on the other be a complete graph.

\mnote{Topologies affect properties}
It is easy to see that properties are directly affected by the network topology.
A complete graph has the benefit of high reusability, because any subset of tools can be used for a development project without loosing consistency.
In the example, the tree network is not applicable in development projects not using the \gls{UML}, because then \gls{PCM} and Java models cannot be kept consistent.
Additionally, a complete graph profits from universality, because arbitrary relations can be expressed, whereas a tree requires that of three languages there is always one that can express the overlap of the two others.
If there are overlaps between \gls{PCM} and Java that cannot be expressed across the \gls{UML}, like discussed for behavioral specifications, a tree cannot be defined.
On the other hand, a tree has the benefit of inherent correctness guarantees.
There are no two paths of transformations between the same two languages.
Thus, no changes can be propagated across two paths to the same model.
This avoids at least two of the three introduced challenges regarding correctness, because neither synchronization problems nor contradictions can occur.

\mnote{Topologies induce trade-offs}
While each kind of topology improves certain properties, it degrades others at the same time.
In other words, topologies induce trade-offs between different properties.
For example, a tree improves correctness, but degrades reusability in comparison to a complete graph.
Deriving how to use this knowledge to mitigate trade-offs and improve different properties at the same time is our \emph{properties and topologies challenge}.

\subsubsection*{Improvement Challenge}

\mnote{Improving properties by specific topologies}
We have seen that topologies directly influence properties of transformation networks.
We will see that an appropriate strategy of building networks with a specific topology mitigates trade-offs.
Currently, however, there is no known approach that supports building transformation networks of specific topologies improving quality properties.
Research approaches have considered approaches and languages for single transformations or specific composition purposes, such as transformations between the same two languages~\cite{wagelaar2010a,wagelaar2011a}, or chains of transformations~\cite{pilgrim2008constructingChains-ECMDA, vanhooff2007UniTI-MODELS}.

\mnote{Improvement challenge}
To relieve the developer from identifying a topology to improve different properties, a universal approach to define an according topology and an appropriate language that supports its definition should be provided.
Investigating such a strategy and design options for an according specification language constitutes our \emph{improvement challenge}.

\subsubsection*{Problem Statement}

\mnote{Impact of topologies and usability for mitigating trade-offs unknown}
We have discussed that topologies affect different correctness and quality properties of transformation network and that they impose trade-offs between them.
It is unclear how this insight can be used to systematically improve different properties of transformation networks by building networks of specific topologies.
Thus, we derive the following problem statement.

\begin{problemstatement}
    It is unknown how to systematically mitigate trade-off decisions between correctness and quality properties, such as reusability, of transformation networks.
\end{problemstatement}


\subsection{Challenges Overview}

\begin{figure}
    \centering
    \input{figures/prologue/introduction/challenges.tex}
    %\includegraphics[width=0.9\textwidth]{figures/prologue/introduction/challenges.png}
    \caption[Problem statements and challenges]{The two identified problem statements and their challenges.}
    \label{fig:introduction:challenges}
\end{figure}

\mnote{Summary of problems statements and challenges}
We have discussed several issues regarding the construction of transformation networks.
\autoref{fig:introduction:challenges} summarizes the identified problem statements and challenges.
We have identified two central problem statements, one regarding the correctness of networks and another regarding the improvement of quality properties, each driven by specific challenges.
We have discussed orchestration, synchronization and contradiction as central challenges for constructing correct transformation networks.
For the improvement of quality properties, we have emphasized that the relation between properties and topologies enables the construction of topologies mitigating trade-offs.


%%
%% RESEARCH OBJECTIVE
%%
\section{Research Objective}

\mnote{Research questions, assumptions and contributions}
We have identified specific challenges and generalized problem statements in the construction of transformation networks.
In the following, we derive our research goal and the actual research questions that we answer in this thesis in response to the problem statements.
Afterwards, we summarize the context and the assumptions of our work.
Finally, we give an overview of the contributions to answer the defined research questions.

\subsection{Research Goal and Questions}

The central goal of our research can be summarized as follows.
\begin{researchgoal}
Define a notion of correctness for networks of modular, independently developed transformations and classify relevant quality properties.
Provide approaches to systematically improve correctness and quality properties of transformation networks by construction or by analysis.
\end{researchgoal}

\mnote{Benefits of achieving goal}
The benefits of achieving that goal are twofold.
First, researchers and transformation developers both gain systematic knowledge about how to achieve correctness and improve quality properties in transformation networks.
Second, transformation developers are provided with concrete techniques and languages that help to achieve correctness and improve other properties either by construction or at least by analysis.

\mnote{Parts of research goal}
The research goal consists of two parts, one regarding correctness of transformation networks and one regarding the improvement of their quality properties.
For each part, we identify fine-grained research questions.


\subsubsection*{Building Correct Transformation Networks}

\mnote{Correctness questions}
The first part of our research goal concerns correctness of transformation networks.
We want to know what \emph{correctness} means for transformation networks and which aspects of correctness we can achieve for every network.
In particular, we want to identify which of them we can achieve by proper construction of each transformation, which we can analyze, and for which we need to deal with potential incorrectness until their execution.
We derive the following research questions for the first part of our research goal.

\begin{researchquestions}
	\researchquestion{rq:correctness}{When should networks of independently developed transformations be considered \emph{correct} and how can correctness be achieved?}
	\begin{subresearchquestions}
		\subresearchquestion{rq:correctness:notions}{What are relevant notions of correctness in transformation networks and how can they be formalized?} % EV: Argumentation
		\subresearchquestion{rq:correctness:compatibility}{When are the constraints induced by transformations contradictory and how can that be analyzed?} % EV: Proof and empirical application in case study
		\subresearchquestion{rq:correctness:synchronization}{Which requirements must a transformation fulfill for being used in a network in comparison to using it on its own?} % EV: Proof and empirical application in case study
		\subresearchquestion{rq:correctness:orchestration}{How can transformations in a network be orchestrated and which properties can such an orchestration strategy fulfill?} % EV: Argumentation, Examples
		\subresearchquestion{rq:correctness:errors}{Which errors can occur in transformation networks, how can they be classified regarding their avoidability, and how severe are they?} % EV: Case Study
	\end{subresearchquestions}
\end{researchquestions}

\mnote{Relation between question and challenges}
\autoref{rq:correctness:notions} is the fundamental question to precisely define what \emph{correctness} means, beyond our up to now informally given notion.
\autoref{rq:correctness:compatibility}, \autoref{rq:correctness:synchronization} and \autoref{rq:correctness:orchestration} directly map to the previously identified challenges regarding orchestration, synchronization and contradiction.
Finally, \autoref{rq:correctness:errors} asks for the inverse, i.e., for the case in which errors occur due to incorrectness, to find out how incorrectness manifests during execution and how likely and thus severe the errors are.


\subsubsection*{Improving Quality Properties of Transformation Networks}

\mnote{Quality properties questions}
The second part of our research goal concerns quality properties of transformation networks.
We want to known how we can systematically improve the quality of transformation networks. 
This includes the identification of properties that are relevant when building transformation networks and how they are affected by different topologies. 
We use this to systematically derive a proper construction approach achieving a specific topology that resolves trade-offs between quality properties. 
We derive the following research questions for the second part of our research goal.

\begin{researchquestions}
	\researchquestion{rq:quality}{How can quality properties of transformation networks be improved systematically?}
    \begin{subresearchquestions}
        \subresearchquestion{rq:quality:properties}{What are relevant properties and topologies of transformation networks and how are they related?} % EV: Argumentation
		\subresearchquestion{rq:quality:topology}{How can topologies of transformation networks improve quality properties of transformation networks?} % EV: Argumentation
		\subresearchquestion{rq:quality:language}{How can a specialized language support the specification of a network topology that improves quality properties?} % EV: Proof-of-concept and case study
	\end{subresearchquestions}
\end{researchquestions}

\mnote{Relation between question and challenges}
\autoref{rq:quality:properties} maps to the properties and topologies challenge for identifying how topologies affect the fulfillment of properties.
\autoref{rq:quality:topology} and \autoref{rq:quality:language} map to the improvement challenge to identify how the proper construction of a topology can improve quality properties and how an appropriate language can support that.


%% CONTEXT AND ASSUMPTION
\subsection{Context and Assumptions}
\label{chap:introduction:objective:assumptions}

\mnote{Model-driven processes}
In this thesis, we consider the context of model-driven development processes for software or software-intensive technical systems.
Thus, we assume that a system under construction is described by several models containing information about different extracts or properties of the system.
We assume that they usually share some overlap of information.
Our discussions will focus on software development artifacts.
If they follow the same formalism, however, the insights and techniques may be applied to artifacts from arbitrary domains.

\mnote{Distributed knowledge and independent development}
We assume that the knowledge about different transformations to be combined to a network is distributed.
To foster the development of transformations that can be used as \glspl{RUSP}, we assume that transformations are developed independently.
Thus, transformations may not be adapted to be used within transformation networks.

\mnote{Consistency relation types}
We do not restrict the kinds of relations between models to keep consistent  in any way.
We will, however, discuss different types of consistency and their relations to different kinds of processes to preserve consistency in \autoref{chap:networks:notions:types}.
In fact, our contributions, although theoretically not restricted to that, will be best applicable to a kind of \emph{structural} dependencies rather than \emph{behavioral} dependencies.

\mnote{Semi-automatism}
Finally, transformations may not always be able to restore consistency on their own, because necessary information to do so is missing.
For example, a developer may add a class in Java code and a transformation has to decide whether that class shall represent a \gls{PCM} component or not.
That problem can either be solved by requiring the class to fulfill certain patterns, like containing \enquote{Component} in the class name, or by asking the user about his intent.
In cases where information is transformed to a semantically richer model, often further information about how to transform it is needed.
\textcite[p.~57]{kramer2017a} provides a classification for different levels of automation, starting from no automation over suggestions and semi-automated repair to fully automated repair.
In this thesis, we assume that consistency is preserved in a fully automated way, thus excluding the semi-automatic case.
We will finally discuss how our finding generalize to cases in which user decisions need to be included.


%% CONTRIBUTIONS
\subsection{Contributions}

\begin{figure}
    \centering
    \input{figures/prologue/introduction/context_problem_eq_contribution_relations.tex}
    %\includegraphics[width=\textwidth]{figures/prologue/introduction/context_problem_eq_contribution_relations.png}
    \caption[Context, problems, research questions and contributions]{Relations between context, problem statements, research questions, and contributions.}
    \label{fig:introduction:context_problem_rq_contribution_relations}
\end{figure}

\mnote{Contribution structure}
The contributions that we make in this thesis are structured along the same dimensions as the problems and the research questions, namely correctness and quality properties of transformation networks.
The contributions directly map to the research questions.
\autoref{fig:introduction:context_problem_rq_contribution_relations} gives an overview of the relations between the context of our work, the problem statements, the research questions and the contributions that we make.

We make the following contributions regarding transformation network correctness.
\begin{contributions}
    \contribution{contrib:correctness:notion}{Notion}{We discuss different notions of correctness for transformation networks and precisely define the one relevant for our context. We derive that compatibility, synchronization and orchestration constitute relevant correctness notions.}
    \contribution{contrib:correctness:compatibility}{Compatibility}{We precisely define a notion of compatibility to express when transformations contain contradictory constraints. We propose an approach that validates compatibility of transformations and prove its correctness.}
    \contribution{contrib:correctness:synchronization}{Synchronization}{We discuss how synchronization can be achieved for transformations defined with existing transformation languages. We prove that transformations fulfilling a specific property can be applied in transformation networks.
    We provide an algorithm to execute the transformations in that case and propose a strategy to fulfill the required property by construction.}
    \contribution{contrib:correctness:orchestration}{Orchestration}{We prove that transformations can, in general, neither be executed only once nor an arbitrary number of times in a fixed-point iteration without the risk of non-termination. We prove that finding an execution order of the transformations that yields consistent models is an undecidable problem and discuss why we cannot make practicable restrictions to the transformations to achieve its decidability. We propose an algorithm for orchestration that executes the transformations according to a well-defined strategy that helps to find the cause whenever it does not return consistent models.}
    \contribution{contrib:correctness:errors}{Errors}{We systematically derive which errors can occur when correctness of a transformation network is not given. We empirically evaluate the probability of the different errors to occur to classify their severity and thus the importance of avoiding them.}
\end{contributions}

We make the following contributions regarding the improvement of quality properties of transformation networks.
\begin{contributions}
    \contribution{contrib:quality:topologies}{Topologies}{We discuss how different quality properties of transformation networks are affected by the network topology. We derive that trade-off decisions have to be made regarding the improvement of different properties.}
    \contribution{contrib:quality:improvement}{Improvement}{We propose a strategy for building a specific network topology, which makes the consistency relations explicit in terms of auxiliary models rather than transformations. We show that this approach systematically improves different quality properties and mitigates necessary trade-off decisions.}
    \contribution{contrib:quality:language}{Language}{We propose a specialized language for the definition of a transformation network according to the strategy of \autoref{contrib:quality:improvement}. 
    We discuss different design options for the language and its operationalization.}
\end{contributions}


\subsection{Expected Benefits}
\label{chap:introduction:objective:benefits}

\mnote{Overall benefits}
The contributions that we make in this thesis provide several benefits for researchers, developers of transformations and transformation networks, as well as transformation (network) users.
All of them profit from systematic knowledge about what \emph{correctness} means for transformation networks, how correctness is affected and can be guaranteed, and about relevant \emph{quality properties} in transformation networks as well as how they can be improved.
The contributions, however, have an intended focus on supporting transformation and transformation network developers. 

\mnote{Benefits for researchers}
Researchers can base on our definitions for correctness of transformation networks and can thus precisely contribute to particular parts of the correctness notions, such as approaches to achieve correctness with explicitly knowing how and which kinds of potential errors of transformation networks are affected by that.
Additionally, they can base further research on the insights about property trade-offs induced by different network topologies.

\mnote{Benefits for transformation (network) developers}
The developers of actual transformation networks consist of developers of the individual transformations and the ones combining them to a network.
The development of individual transformations is supported by the provision of systematic approaches to build transformations that can be used within networks, especially in terms of supporting synchronization.
Transformation network developers benefit from the knowledge that they have to deal with undecidability of orchestration.
They also benefit from approaches to validate transformations they want to combine regarding compatibility, an actual and practical orchestration strategy to execute transformations, and an approach to build networks that mitigate property trade-offs.

\mnote{Benefits for transformation (network) users}
Finally, the users of a transformation network, i.e., those who develop a system using a transformation network to preserve consistency of its artifacts, benefit from the ability to use networks for which correctness was systematically achieved.
They also profit from an orchestration strategy that supports them in finding and understanding the reasons why the network may not be able to process certain changes to preserve consistency.



%%
%% OUTLINE
%%
\section{Thesis Outline}

\mnote{Chapter structure and contents}
The remainder of this thesis is structured as follows.
We briefly introduce fundamental terms, concepts and ideas in \autoref{chap:foundations} and define own terminology and notions on which we rely in \autoref{chap:networks}.
\autoref{part:correctness} and \autoref{part:quality} then structure the contributions along the topics of transformation network correctness and the improvement of quality properties.
Within \autoref{part:correctness}, \autoref{chap:correctness} first derives a reasonable notion of correctness for transformation networks, from which the three topics of proving compatibility (\autoref{chap:compatibility}), achieving synchronization (\autoref{chap:synchronization}), and orchestrating transformations (\autoref{chap:orchestration}) are derived.
We discuss potential errors if correctness is not given in \autoref{chap:errors}, before we evaluate approaches presented in these chapters in \autoref{chap:correctness_evaluation}.
Within \autoref{part:quality}, \autoref{chap:classification} first discusses quality properties of transformations networks and how they are affected by the network topology.
\autoref{chap:improvement} derives an approach for mitigating trade-offs between these quality properties, which is supported by a language proposed in \autoref{chap:language} and which we evaluate in \autoref{chap:commonalities_evaluation}.
Each of the Chapters \ref{chap:correctness}--\ref{chap:orchestration} and \ref{chap:classification}--\ref{chap:language} addresses one of the identified research questions and provides one of the depicted contributions, whose central insight is summarized at the end of each chapter.
After relating our work to different fields of research in \autoref{chap:relatedwork}, we conclude with a summary of future work in \autoref{chap:conclusions}.

\mnote{Reading modes}
Beyond sequential reading, there are multiple other modes for readers particularly interested in specific topics.
We suggest to always read \autoref{chap:networks} and, with less importance but for better understanding, also \autoref{chap:correctness}, as they define essential notions and notations.
Readers especially interested in topics related to correctness of transformation networks can proceed with any of the Chapters \ref{chap:compatibility}--\ref{chap:errors}, which are almost independent, and follow back references where necessary.
Readers particularly interested in the improvement of quality properties of transformation networks can skip Chapters \ref{chap:compatibility}--\ref{chap:correctness_evaluation} and proceed with Chapters \ref{chap:classification}--\ref{chap:commonalities_evaluation}, which should be read sequentially.
These chapters also refer to the insights from Chapters \ref{chap:compatibility}--\ref{chap:correctness_evaluation} but will also be comprehensible without reading them or by following back references where necessary.
Readers who only want to obtain a better general overview of the contributions of this thesis also have the option to read the insights at the ends of the chapters and the conclusions in \autoref{chap:conclusions}, potentially complemented by the fundamental notions in \autoref{chap:networks} and \autoref{chap:correctness}.

