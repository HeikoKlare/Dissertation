\chapter{Introduction
    \pgsize{15 p.}
}
\label{chap:introduction}

%%
%% MOTIVATION
%%
\section{Consistency in Software and Systems Engineering}

Allgemeine Motivation Konsistenzhaltung, Beziehungen, Transformationen



%%
%% PROBLEM DESCRIPTION -> RESEARCH GAP
%%
\section{Problems in Modular Consistency Specification}

\subsection{A Problem Scenario}
Realitätsnahe Problemstellung. Szenario von Joshua gemischt mit meinen Szenarien.

\subsection{A Generalization of Problems}
Probleme verallgemeinern vom konkreten in abstrakteres Szenario

\subsection{Problem Statement and Research Gap}
Abschließend das Problem Statement erfassen.


%%
%% RESEARCH GOAL / QUESTION
%%
\section{Research Goal and Questions}

\begin{researchgoal}
Define a notion of correctness for networks of independently developed transformations, classify relevant quality properties, and investigate how to systematically improve correctness and quality either by construction or by analysis.
\end{researchgoal}

As a benefit of achieving that goal, a transformation developer shall know about all necessary properties of a transformation network to achieve its correct execution and he or she shall be provided with techniques to guarantee these properties by construction whenever possible and otherwise techniques that allow him or her to check them.

\subsection*{Properties of Transformation Networks}

Overall Goal: We want to find out which properties are relevant when building transformation networks and how they are affected by different topologies. This is supposed to help finding ways of systematically improving those properties.

\begin{researchquestions}{1}
	\item \researchquestion{rq:properties}{What are relevant properties and topologies of transformation networks and how do they depend?}
	\begin{subresearchquestions}
		\item \researchquestion{rq:properties:properties}{Which functional and non-functional properties are relevant when defining transformation networks?}
		\item \researchquestion{rq:properties:topologies}{How can network topologies be classified regarding the properties identified in \researchquestionref{rq:properties:properties}?}
	\end{subresearchquestions}
\end{researchquestions}

% \begin{enumerate}[label=\itshape RQ \arabic*.]
% 	% Issue classification
% 	\item Which issues can occur when independently developed \acp{BX} are combined to a network?
% 	\begin{nestedenum}
% 		\item Which failures can occur, when \acp{BX} are combined to a network?
% 		\item What mistakes can be made that lead to failures?
% 		\item How can these mistakes be categorized regarding conceptual levels in the specification process for \acp{BX}?
% 	\end{nestedenum}
% 	\item How are properties of transformation networks affected by the topology?
% 	\begin{nestedenum}
% 		\item Which properties are relevant when defining networks of \acp{BX}?
% 		\item Which topologies of network exist and how do they affect that properties?
% 	\end{nestedenum}
% \end{enumerate}

% \subsubsection*{Evaluation}

% Keine dezidierte Evaluation, lediglich Argumentation


\subsection*{Building Correct Transformation Networks} % Correctness of Transformation Networks?
Overall Goal: We want to know what \emph{correctness} means for transformation networks, which parts we can build correct for every network, which can be achieved by assumption, i.e., by proper construction of transformations, which can be analyzed and for which we need to deal with potential incorrectness.

\begin{researchquestions}{2}
	\item \researchquestion{rq:correctness}{When should networks of independently developed transformations be considered \emph{correct} and how can correctness be achieved?}
	\begin{subresearchquestions}
		\item \researchquestion{rq:correctness:notions}{What are relevant notions of correctness in transformation networks and how can they be formalized?} % EV: Argumentation
		\item \researchquestion{rq:correctness:compatibility}{When are the constraints induced by transformations contradictory and how can that be analyzed?} % EV: Proof and empirical application in case study
		\item \researchquestion{rq:correctness:synchronization}{Which requirements must an individual transformation fulfill for being used in a network in comparison to using it on its own?} % EV: Proof and empirical application in case study
		\item \researchquestion{rq:correctness:orchestration}{How can transformations in a network be orchestrated and which properties can such an orchestration strategy fulfill?} % EV: Argumentation, Examples
		\item \researchquestion{rq:correctness:errors}{Which errors can occur in transformation networks, how can they be classified regarding their avoidability and how severe are they?} % EV: Case Study
	\end{subresearchquestions}
\end{researchquestions}


% \begin{enumerate}[label=\itshape RQ \arabic*.]
% 	\setcounter{enumi}{2}
	% % Contradiction analysis
	% \item How can transformations be analyzed regarding contradictions in specified constraints?
	% \begin{nestedenum}
	% 	\item What is an appropriate formalism for describing transformations that can be analyzed regarding potential contradictions?
	% 	\item Which kinds of contradictions can be detected by analyzing transformations following a specific formalism?
	% \end{nestedenum}
	% % Issue avoidance by construction
	% \item How can interoperability of independently developed \acp{BX} be achieved by construction?
	% \begin{nestedenum}
	% 	\item Which kinds of mistakes can be avoided by construction of the individual \acp{BX}?
	% 	\item How can we prove that those mistakes and only those mistakes can be avoided by construction?
	% 	\item How can each of these mistakes be avoided by a transformation developer during independent development of a single \acp{BX}?
	% \end{nestedenum}
	% % Orchestration
	% \item What is an appropriate strategy for orchestrating independently developed \acp{BX} to perform a fixed-point iteration?
	% \begin{nestedenum}
	% 	\item Which strategies for orchestrating a network of \acp{BX} exists and what are their properties?
	% 	\item How should those properties be weighted and which of the strategies should be chosen for orchestration?
	% \end{nestedenum}
% \end{enumerate}

\subsubsection*{Evaluation}

\gqm{Functionality}{The analysis can be used to find contradictions in specifications}
{Does the analysis find contradictions if they exist?}
{Recall: Ratio of true positives to true positives + false negatives}
\qm{Does the analysis find contradictions although they do not exist?}
{Precision: Ratio of true positives to true+false positives}
\qm{Does the analysis find non-contradictions although they exist?}
{Ratio of false negatives to false+true negatives}

\gqm{Functionality}{The techniques to avoid mistakes by construction actually avoid interoperabililty issues}
{Are the identified failures that can occur complete?}
{Ratio of number of identified failures to total number of failures}
\qm{Are the relations of identified mistakes to identified failures correct?}
{Ratio of failures resolved by fixing the identified mistake to all failures}
\qm{Does the application of avoidance techniques lead to interoperable transformations?}
{Ratio of changes that are propagated correctly to those that are not propagated correctly}

\gqm{Applicability}{The techniques can be applied independently to single transformations}
{Are there cases in which information about other transformations are necessary to solve issues?}
{Ratio of number of fixes that require information about other transformation to total number of fixes with user interactions\\
Ratio of number of fixes that require information about other transformation to total number of fixes without user interactions}



\subsection*{Improving Non-Functional Properties of Transformation Networks}
Overall Goal: We want to known how we can systematically improve the quality of transformation networks. First by means of a proper construction approach achieving a specific topology. Second by including models that were not explicitly modelled as such before to allow their integration into a transformation-based consistency process.

\begin{researchquestions}{3}
	\item \researchquestion{rq:quality}{How can quality properties of transformation networks be systmatically improved?}
	\begin{subresearchquestions}
		\item \researchquestion{rq:quality:topology}{How can a topologies of transformation networks improve quality properties of transformation networks?} % EV: Argumentation
		\item \researchquestion{rq:quality:language}{How can a specialied language support the specification of a network topology that improves quality properties?} % EV: Proof-of-concept and case study
		\item \researchquestion{rq:quality:process}{How can software development artifacts be integrated into a transformation-based development process?} % EV: Case study
	\end{subresearchquestions}
\end{researchquestions}

% \begin{enumerate}[label=\itshape RQ \arabic*.]
% 	\setcounter{enumi}{5}
% 	\item How can a topology of transformation be build that optimizes non-functional properties of transformation networks?
% 	\begin{nestedenum}
% 	    \item How can transformation contradictions be avoided by language design? %uniqueness of consistency specification and consistency among themselves achieved by language design?
% 	    \item How can modularity be achieved in a way such that an arbitrary set of metamodels for which consistency is specified can be used in an actual project?
% 	\end{nestedenum}
% 	% Building tree topologies
% 	\item How should a language specific for multi-model consistency be defined that supports a non-functional property-optimizing topology definition?
% 	\begin{nestedenum}
% 		\item What are the design decisions for such a language?
% 	\end{nestedenum}
% \end{enumerate}

\subsubsection*{Evaluation}

\gqm{Functionality}{Concept and language can achieve consistency between several models}{How many model changes in a case study can be properly kept consistent?}{Ratio of successfull test cases}

\gqm{Practicality}{The assumption of defining a tree of \commonalities is achievable in practice}{Is the definition of cross-tree relations necessary in a case study?}{Number of cross-tree relations in a case study compared to number of relations}

\gqm{Practicality/Benefit}{A specific language improves conciseness of consistency specifications}{How much more concise is the specification for a case study compared to a definition with direct transformations?}{Number of SLOC with \commonalities compared to number of SLOC with \reactions for same case study}

Diskussion: Erreichen der Modularität auch evaluieren? Ist per Konstruktion gegeben, könnte man aber natürlich auch noch auswerten (bringt aber nichts).



%%
%% CONTEXT AND ASSUMPTION
%%
\section{Context, Scope and Assumptions}

* Transformations are developed independently
* No global knowledge exists



%%
%% CONTRIBUTIONS
%%
\section{Contributions}



%%
%% OUTLINE
%%
\section{Outline}







\todo{Finally, even with multiary transformation, we want to be able to combine them to networks}

\begin{copiedFrom}{DocSym}

\section{From DocSym}
%\todo{Clearly introduce running example, removed from content section!}
%\todo{Introduce set notation, say that is it not practically applicable and a strong simplification, but just used to illustrate the problems and solution approaches} % Done at the end
%\todo{Introduce transitive operator R1 o R2 = (R1 u R2) * $\backslash$ (R1 u R2)} % Done at the end

%\todoConference{The problem the research intends to solve, the target audience of this research, and a motivation of why the problem is important and needs to be solved.}

\acl{MDSD} proposes the usage of models as primary artifacts of the %software 
development process~\cite{stahl2006a}. 
Those models describe different system properties for the interests of specific stakeholders, known as \emph{multi-view modelling}, or at different abstraction levels, representing refinements. In both cases, the models describe the same system and are thus not disjoint but contain redundant or dependent information. 
%\todoErik{Wieder: Die beschreiben ja keine Abstraktion, die sind eine Abstraktion. \enquote{Domains of the system} klingt auch komisch, ich weiß zwar, was Du meinst, aber nenne es nicht \enquote{domain}, sondern lieber \enquote{properties}}
Developers must be aware of those dependencies to ensure that models are modified consistently. 
%Otherwise, the deployed software, which is derived from those models, will potentially not operate correctly.
%\todoErik{Lenkt den Fokus etwas zu stark auf Korrektheit, die wir nicht formal beweisen. Es geht ja nicht nur darum, daß die Software nicht korrekt arbeitet -- möglicherweise tut sie das ja, obwohl die Modelle inkonsistent sind, und das Problem tritt erst bei der Wartung/Evolution auf.}

In large software systems, a single developer cannot know about all dependencies~\cite{petrenko2008a}, %which can be formulated as \emph{consistency constraints} and 
in the following referred to as \emph{consistency relations}, which inevitably leads to inconsistencies. 
Therefore, automated mechanisms that preserve consistency according to those consistency relations are necessary. 
For that purpose, incremental, bidirectional model transformations %or specialized model synchronization approaches 
are commonly used. However, most research considers \emph{binary transformations}, restricted to pairs of models, and does not explicitly consider consistency between more than two models~\cite{stevens2017a}, which we refer to as \emph{multi-model consistency}.
%In general, keeping more than two models consistent is currently not researched well.
Model transformations can either be specified imperatively or declaratively. They differ in who operalizationalizes the preservation of constraints that have to hold, in the first case the transformation developer and in the second case an automated mechanism of the transformation language. This is why we do not explicitly distinguish these approaches, as all problems apply to both approaches and only different roles have to deal with them. 
% Model transformations can either be specified imperatively, such that the transformation developer has to define how to react to a change, or declaratively, such that the transformation developers only the constraints that have to hold and an automated mechanism derives an imperative operationalization from that.
% We will not explicitly distinguish these approaches, as the identified problems and our solution proposals apply to both. The only difference is that in imperative approaches the transformation developer has to deal with them and in declarative approaches the developer of the transformation language has to consider them when defining the generation of the operalizalization.

Although it is possible to combine binary transformations by transitively executing them, it is yet unclear what problems may arise from that, especially if each transformation is developed independently and treated as a black box.
We will exemplify this on the simple example in \autoref{fig:prologue:binary_combination_example}, in which consistency relations define a mapping of a component in an \ac{ADL} to a class in object-oriented design, which is again represented by an implemented class in Java code. 
The name of the class is defined to be the component name with an \enquote{Impl} suffix (cf.~\cite{langhammer2017a}).
When all these relations are expressed in transformations, it is, for example, possible that both transformations from \ac{ADL} to Java, once over \ac{UML} (\ref{fig:prologue:binary_combination_example:R1} and \ref{fig:prologue:binary_combination_example:R2}) and once directly (\ref{fig:prologue:binary_combination_example:R3}), create a Java class after creating an \ac{ADL} component.
We refer to that as an \emph{interoperability problem}.
The transformation specification %or its execution engine 
would have to avoid an overwrite and therefore have to consider dependencies between transformations, using, for example, a shared trace model.
In general, an interoperability problem is an unexpected behavior of transformations, which only occurs if they are executed transitively, but not if each is executed on its own. %, although all preserve the same consistency relations.

Additionally, it is easy to see that %specifying multi-model consistency with combinations of 
combining binary transformations leads to trade-off decisions.
The ternary relation %between the three metamodels 
can either be expressed by three binary transformations between all pairs of metamodels or by two binary transformations with the third being %expressed by the transitive 
the combination of the two others.
The first option leads to redundancies in the specifications, as each pair of transformations has to have an equal semantics than the third.
For example, the \ac{ADL} to Java transformation for \ref{fig:prologue:binary_combination_example:R3} must be equal to the combination of the transformations \ac{ADL} to \ac{UML}~(\ref{fig:prologue:binary_combination_example:R1}) and \ac{UML} to Java~(\ref{fig:prologue:binary_combination_example:R2}).
Consequently, those transformations may be incompatible if not correctly defined, e.g., by leaving out the suffix addition in the transformation for \ref{fig:prologue:binary_combination_example:R3}.
%As an alternative, the second option is express the ternary relation with two binary consistency relation specifications.
%For example, specification \ref{fig:example:R3} can be interpreted as a combination of \ref{fig:example:R1} and \ref{fig:example:R2}.
An alternative is to omit the transformation for \ref{fig:prologue:binary_combination_example:R3} by transitively executing the two others.
However, in this case, modularity is reduced, because it is not possible to use only Java and the \ac{ADL} to develop a specific system and omit the \ac{UML}.
%Additionally, comprehensibility decreases, because the relation between \ac{ADL} and Java is only expressed transitively. 
%This becomes more problematic if transformation paths have a length higher than two.
We refer to this as \emph{specification trade-offs}.

\begin{figure}
    \centering
    \input{figures/prologue/binary_combination_example.tex}
    \caption{Example models with binary consistency relations}
    \label{fig:prologue:binary_combination_example}
\end{figure}

%Although specific approaches for expressing multiary relations, rather than using combinations of binary relations, could be developed, there are some reasons for adhering to binary transformations.
Instead of developing approaches to express multiary consistency relations, there are reasons to adhere to binary transformations, and to research their combinability.
As stated by \textcite{stevens2017a}, %there are especially strong practical reasons, as 
it is hard enough to think about binary relations. %between pairs of models.
%Defining multiary relations would require a knowledge about the relations between all metamodels used to describe a system.
Additionally, each domain expert, who specifies transformations, %in practice, 
will usually only have knowledge about the relations between two or at most a rather limited set of metamodels. %, but not of all involved metamodels. %, which would be necessary to define multiary relations.
%Thus, it is a natural goal to make the modular specification of consistency based on binary transformations possible.
%In the proposed thesis, 
We therefore plan to make the following contributions to research on multi-model consistency preservation:
%\todoErik{Ich fänd's cool, wenn die Probleme auch irgendwie hervorgehoben sind, und Du die Beiträge schon auf die Probleme beziehen kannst, also Mini-PIBA für jedes Deiner identifizierten Probleme. Würde aber erst die Probleme formulieren, dann den IBA-Teil so wie unten (wobei bei manchen noch die Beschreibung des Benefits fehlt).}
\begin{description}[leftmargin=\parindent]
    \item[Transformation interoperability.] %Under the assumption that 
        When several binary transformations are developed independently, they must be combinable in a black box manner, introduced as the \emph{interoperability problem}. We will therefore identify problems that can arise from that combination %of transformations 
        and develop a catalog of patters that can be followed by the transformation developer or language to achieve \emph{non-intrusive} interoperability of binary transformations.
    \item[Decomposition of consistency relations.] 
        The usage of binary transformations for multi-model consistency preservation leads to \emph{specification trade-offs} regarding essential challenges. We will provide a classification of those challenges and investigate the influence of the way in which transformations are specified on them.
        %Decomposing the underlying consistency relations into independent sub-relations allows a partial optimization regarding those challenges.
        %We will therefore investigate how consistency relations can be decomposed into independent subsets.
        We will especially investigate how consistency relations can be decomposed into independent subsets, as this allows a partial optimization regarding those challenges.
    %We will identify relevant properties of consistency specifications, which have to be considered when defining those specifications as they introduce trade-off decision. We already motivated some of those properties above and give a more detailed overview in \autoref{sec:multimodelconsistency}.
    \item[Make common concepts explicit.] 
        Metamodels often represent the same concepts in different ways. As another contribution to reduce \emph{specification trade-offs}, we propose an approach to make these common concepts explicit to improve comprehensibility of transformations and to improve their modular reuse.
\end{description}

% We propose an approach for multi-model consistency based on \aclp{VOMM}. 
% In those virtual metamodels, dependencies between metamodels, which we refer to as \emph{consistency relations}, are made explicit by representing common concepts, whereas in model transformations, which we refer to as \emph{consistency preservation specifications}, they are specified implicitly. 
% The envisioned benefit is an inversion of the above mentioned properties. 

Throughout this paper, we use a simplified notation for metamodels and heir consistency relations to ease their illustration. 
We consider metamodels to be sets of elements and consistency relations to be sets of symmetric, binary relations between those elements.
To ease the representation of combinations of consistency relations, we define the concatenation operation for two consistency relations $R_1$ and $R_2$ as:
\begin{equation*}
    R_1 \concat R_2 \coloneqq \{(x,y)\, |\, \exists t: x\, R_1\, t\, R_2\, y \}.
\end{equation*}
This is the subset of the transitive closure of two relations that contains only the relations transitively defined over $R_1$ and $R_2$.
It can be also expressed as the natural join of $R_1$ and $R_2$ with an additional projection that removes the common elements of both relations.
The operator is commutative since the relations are assumed symmetric.

% \todoErik{Würd ich bei so einem kurzen Paper weglassen. (Ich würde es auch oft bei langen Papern weglassen. :-))}
% In this paper, we first discuss related work in \autoref{sec:relatedwork}. 
% In \autoref{sec:approach}, we give an overview of our planned contributions by explaining the problems in detail and sketching our solution approaches. %we first discuss interoperability problems arising from the combination of independently developed binary transformations and give an overview on envisioned solution patterns.
% %We then give an introduction to the yet identified challenges inducing trade-off decisions during transformation development.
% %From this, we derive the consideration of consistency relation composition and an approach to make common concepts explicit.
% % We then discuss problems arising from the black-box combination of binary transformations and give an overview on envisioned solution patterns.
% % In \autoref{sec:vomms}, we introduce our approach to make overlaps of metamodels explicit to improve properties of multiary consistency specifications.
% Finally, we discuss the current state and planned evaluation in \autoref{sec:status} and conclude the paper in \autoref{sec:conclusion}.


% \begin{itemize}
%     \item Motivation MDSD
%     \item Several models describe single system
%     \item Information overlap between models, e.g. component architecture and code, ref to Michael
%     \item Developers must be aware of redundancies and dependencies, otherwise inconsistencies
%     \item Best: Make redundancies/dependencies explicit for (semi-)automated mechanisms for preserving consistency
%     \item Incremental model transformations can be used (refs) or specialized model consistency or model synchronization approaches (refs)
%     \item Existing approaches only concern consistency preservation between instances of two metamodels
%     \item If more than two models are involved, these approach would require that consistency preservation is executed transitively
%     \item From that, problems arise
%     \begin{itemize}
%         \item Inconsistent consistency specifications: Consistency specifications between different metamodels must be consistent. E.g. having 3 metamodels, a consistency specification between two of them can be contradictory to the two other
%         \item Consequence: Result of a modification depends on the order in which consistency specification are evaluated or even results in propagation cycle due to alternating changes -- EXAMPLE
%         \item Ordering problem: Preserving consistency after a change can require several changes in other models. The order in which they are executed can produce different results -- EXAMPLE
%         \item Confluence problem: Changes can be propagated across several paths, if more than two models are involved. This can result in conflicts, if the propagation confluences in one model. E.g. it can be necessary to create a metaclass instance in that model to preserve consistency. All confluencing change propagations require the creation of an element, but how can you achieve that only the first one creates it and the other see the new element and reference it instead?
%     \end{itemize}
% \end{itemize}

%\todoHeiko{Define metamodel vs. \modelinglanguage, Use \modelinglanguage or DSL?}
%\todoHeiko{Say: code is also a model}
%\todoHeiko{Define: \emph{consistency relation} for existing relationships between metamodels that require consistency preservation and \emph{consistency preservation specification} for mechanisms that semi-automatically preserve consistency according to an existing consistency relation}
%\todoHeiko{We refer to the process of preserving consistency due to defined consistency preservation specifications as \emph{change propagation}, as a performed change resulting in the violation of consistency relations leads is propagated to restore consistency -- Besser change propagation überall weglassen.}
%\todoHeiko{Introduce trace links and their necessity for identifying corresponding elements according to consistency relations (prescriptive vs. descriptive)}


%\todo{Klarmachen, dass es immer darum geht Konsistenzrelationen durch bidirektionale, binäre Transformationen auszudrücken. Das ist die Baseline.}

%\todo{Klarmachen, dass Kombination binärer Transformationen der state-of-the-art ist.}

\end{copiedFrom} % DocSym


\begin{copiedFrom}{SoSym MPM4CPS}

\section{From SoSym MPM4CPS}

%%
%% Scope: Building large systems of many models
%%
The scale of modern software systems and their embedding into cyber-physical systems leads to a high and even increasing complexity of systems to be built. 
To handle that complexity, different roles operate on appropriate extracts and abstractions of the system under construction described by different models or views.
Such a fragmentation of information across different models is common at a high level, i.e., mechanical, electrical and software engineers usually use different models and associated tools to describe a system in their domain.
Additionally, different models can be used on a low level by engineers from the same domain, such as software engineers using different models for architecture specification, behavior development and deployment.
For example, the development of \acp{ECU} software in automotives comprises different tools or standards for specifying the system and software architecture, such as SysML~\cite{sysml} or AUTOSAR~\cite{scheid2015autosar}, for defining the behavior, such as MATLAB/Simulink~\cite{simulink} or ASCET~\cite{ascet}, and for defining the deployment on multi-core hardware architectures, such as Amalthea~\cite{amalthea, wolff2014a}.
Since all these models describe the same system, they usually share an overlap of information in terms of dependencies or redundancies, which can lead to inconsistencies if overlapping information is not modified properly in all models.
Recent research investigated such dependencies between ASCET and SysML~\cite{giese2010a}, as well as Amalthea and how to resolve them~\cite{mazkatli2017ase,mazkatli2016ma}.

%%
%% General solution: incremental BX combined to a network
%%
%For resolving inconsistencies, different approaches have been developed.
Incremental model transformations are a common approach to resolve such inconsistencies by enabling developers to explicitly specify how inconsistencies can be resolved (semi-)automatically. 
Especially bidirectional model transformations~\cite{stevens2010sosym}, which specify the relations between two metamodels and routines how consistency of their instances can be restored, are well suited and well researched.
Relating more than two metamodels can either be achieved by defining a multi-directional transformation between all of them or by specifying bidirectional transformations %transformations between pairs of metamodels, i.e., bidirectional transformations, 
between pairs of them in a modular way and combine them to a network that is able to check and preserve consistency between several models.
%In consequence, a more reasonable option is to specify transformations between pairs of metamodels, i.e., bidirectional transformations, in a modular way and combine them to a network that is able to check and preserve consistency between several models.
%\begin{example}
\autoref{fig:prologue:three_persons_example} exemplifies these different possibilities at the example of relation of transformations between three simple metamodels for persons, employees and residents.
We use an informal notion of consistency, defined more precisely later on, which requires that if any person, employee or resident is contained in a model, there must also be the other two elements with the same names, addresses, incomes and social security numbers. %fulfilling a specific relation of their properties.
%That relation includes that names, addresses, incomes and the social security numbers % (\texttt{socsecnumber}) 
are equal.
This relation can either be expressed as a ternary relation, denoted as $R_{PER}$, or as three binary relations $R_{PE}, R_{PR}, R_{ER}$.
In such a simple scenario a single developer may be able to define all these relations.
However, in a more complex scenarios, like the relations between the previously mentioned SysML, Amalthea and ASCET metamodels, there may not be a single person having the knowledge about all these dependencies~\cite{petrenko2008a}, but there may be different domain experts knowing about relations between subsets of the metamodels~\cite{klare2018docsym}.
Additionally, it is difficult to think about complex multiary relations~\cite{stevens2017a}.
In consequence, building networks of bidirectional transformations provides several benefits over building multi-directional transformations.
%\end{example}

\begin{figure}
    \centering
    \input{figures/prologue/three_persons_example}
    % {\color{consistencycolor2}\begin{align*}
    %     R_{PER} = &
    %         \setted{\tupled{p,e,r} \mid \\
    %         & p.firstname + "\text{\textvisiblespace}" + p.lastname = e.name = r.name\\
    %         & \land p.address = r.address%\\
    %         %& 
    %         \land p.income = e.salary\\
    %         & \land e.socsecnumber = r.socsecnumber
    %     }
    % \end{align*}}
    % \vspace{-2em}
    % {\color{consistencycolor1}\begin{align*}
    %     R_{PE} = &
    %         \setted{\tupled{p,e} \mid %\\
    %         %& 
    %         p.firstname + "\text{\textvisiblespace}" + p.lastname = e.name\\
    %         & \land p.income = e.salary
    %     }\\
    %     R_{PR} = &
    %         \setted{\tupled{p,r} \mid %\\
    %         %& 
    %         p.firstname + "\text{\textvisiblespace}" + p.lastname r.name\\
    %         & \land p.address = r.address
    %     }\\
    %     R_{ER} = &
    %         \setted{\tupled{e,r} \mid %\\
    %         %& 
    %         e.name = r.name\\
    %         & \land e.socsecnumber = r.socsecnumber
    %     }\\
    %     R'_{ER} = &
    %         \setted{\tupled{e,r} \mid %\\
    %         %& 
    %         e.name.toLower = r.name\\
    %         & \land e.socsecnumber = r.socsecnumber
    %     }
    % \end{align*}}
    % \vspace{-1em}
    \caption{Three simple metamodels for persons, employees and residents, one ternary relation $R_{PRE}$ between them and three binary relations $R_{PE}, R_{PR}, R_{ER}$ for each pair of them, with $R'_{ER}$ as an alternative for $R_{ER}$.}
    \label{fig:prologue:three_persons_example}
\end{figure}

%%
%% Problem: Cycles
%%
Such a network of bidirectional transformations may contain cycles of transformations.
\autoref{fig:prologue:three_persons_example} exemplifies why it may be unavoidable to have such cycles. 
There is no pair of binary relations, such that it is equivalent to the ternary relation $R_{PER}$, because each pair of metamodels shares unique information that is not represented in the third one. %, namely address, income and social security number.
An essential issue with such cycles is that they impose the possibility of defining contradictory constraints, such that the relations cannot be fulfilled at the same time.
In such a case, the relations are considered \emph{incompatible}.
Consider the three binary relations $R_{PE}, R_{PR}, R'_{ER}$ in \autoref{fig:prologue:three_persons_example}.
These relation cannot always be fulfilled, because $R'_{ER}$ requires the resident name to be lowercase, whereas the other relations relate the names as they are and thus allow the lowercase names.
In consequence, for a resident with a non-lowercase name it is not possible to find a consistent person and employee.
However, in a transformation network, compatibility of the relations defined by the transformations is a necessary requirement for their repair routines to properly restore consistency~\cite{klare2019icmt}.

% In this article, we focus on the relations of a transformation, which define when two models are considered consistent.
% Compatibility of such relations is a necessary requirement for the repair routines of transformations to properly restore consistency in a transformation network, as shown in \cite{klare2019icmt}.
% Thus, in the following we only consider the relations defined by transformations rather than the repair routines.

In this article, we consider the relations defined by bidirectional transformations.
We clarify the notion of \emph{compatibility} of these relations and develop an approach to prove compatibility of relations in a given network of transformations.
To achieve this, we formally define a notion of consistency, based on fine-grained consistency relations, as well as compatibility.
Building on this formalism, we are able to derive an inductive, formal approach for proving compatibility of relations by identifying those that are redundant.
The essential idea is that if consistency relations have a specific kind of tree structure, we are able to show that they are inherently compatible.
Furthermore, we show that adding redundant relations to such a tree preserves compatibility.
In consequence, reducing an arbitrary network of relations to a tree by removing redundant relations proves compatibility.
Finally, we present an operationalized approach based on that formal approach for \qvtr to prove compatibility of a network of \qvtr relations.
That approach transforms \qvtr relations into first-oder logical formulae and finds redundant relations by applying an SMT solver.
% We propose an approach that is able to prove that transformations are compatible, on the example of QVT-R. The approach represents the transformation rules as a graph of metamodel elements with consistency relations between them. Its goal is to find an equivalent set of trees of consistency relations, which are compatible due to the inherent absence of cycles. To achieve that, it decomposes the graph into independent subsets and then removes redundant consistency relations within existing cycles. To prove redundancy of a relation, cycles of relations are transformed into logical expressions and evaluated with an SMT solver. 
More detailed, we make the following contributions:
\begin{description}[leftmargin=\parindent]
    \item[\contributionlabel{contrib:formalization}{Compatibility Formalization}{C1}:] We formalize a notion of consistency and precisely define \emph{compatibility} of relations in a network of transformation.
    \item[\contributionlabel{contrib:formalapproach}{Formal Approach}{C2}:] We define a formal, inductive approach for proving compatibility of relations based on a notion of redundancy and relation trees. % and proving that such trees are compatible and that redundancy preserves compatibility.
    \item[\contributionlabel{contrib:operationalizedapproach}{Operationalized Approach}{C3}:] We propose an approach that applies the formalism to %transformation languages. %and thus enables proving compatibility of transformations defined in a transformation language. 
    %We especially discuss the approach application to 
    \qvtr and show how a translation to logical formulae and the usage of SMT solver can be used to prove compatibility.
    \item[\contributionlabel{contrib:evaluation}{Applicability Evaluation}{C4}:] While correctness of the approach is given by construction and proven on the formalism, we apply the approach to case studies to show applicability of the approach. 
\end{description}

%\todoHeiko{Discuss gap between extension notion in formalism and intensional notion in transformation languages.}

It is, in general, not possible to prove that transformations are incompatible if the language used to describe consistency relations has sufficient expressiveness and is thus undecidable, such as \qvtr.
On the other hand, it is possible to prove that transformations are compatible.
Our approach is designed to operate conservatively, thus in cases it claims compatibility, the transformations actually are compatible.
However, there may be cases in which relations are compatible but the approach is not able to prove that.

The main benefit that our approach imposes is that it enables domain experts to define transformations independently and %allows them 
to automatically detect their compatibility both during development as well as afterwards when combining them to a network.
This relieves them from the necessity to align the transformations with each other a priori and ensuring compatibility manually.
%It also enables them to constantly check compatibility during the development of transformation.
%Finally, even a single developer defining a transformation network that contains cycles may introduce incompatibilies between the transformations.

\todoDiss{Discuss different benefits / scenarios more clearly, especially second benefit / application scenario: User define relations and wants on-the-fly feedback on compatibility to other existing relations, rather then a posteriori checking}

% \paragraph{Running Example}

% \begin{figure*}
%     \centering
%     \includegraphics[width=\textwidth]{figures/running_example.pdf}
%     \caption{Metamodel extracts for ASCET/ASEM, Amalthea and OO used in automotive ECU development}
%     \label{fig:running_example}
% \end{figure*}

% \begin{itemize}
    % \item multi-paradigm modeling used in automotive domain
    % \item high-level: different domains such as mechanical design, electric design, software, all with different views
    % \item low-level: even on low level different views
    % \item example low-level: development of electronic control units (ECUs) with behavior specification in ASCET/ASEM block diagrams, behavior refinement in OO code (e.g. C++, generated but also manually modified), multi-core deployment specification in Amalthea (tasks/runnables and their deployment to hardware)
    % \item highly simplified relations specified in \autoref{fig:running_example} (aligned with \cite{mazkatli2017ase})
    % \item actual metamodels are much more complex, involving explicit behavior specifications, I/O (method parameters, return values, ports etc.)
% \end{itemize}

\end{copiedFrom} % SoSym MPM4CP


