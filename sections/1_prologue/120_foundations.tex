\chapter{Foundations and Notation
    \pgsize{20 p.}
}
\label{chap:foundations}

\begin{copiedFrom}{SoSym MPM4CPS}

\section{Notation and Assumptions}

In this section, we introduce basic terminology, notations and assumptions that we make throughout the article.
We give an overview of the used notation and elements in \autoref{tab:notation}.

\begin{table}
\centering
\renewcommand{\arraystretch}{1.4}%
%\rowcolors{2}{white}{gray!15}
%\setlength\tabcolsep{4 pt}
\begin{tabular}{R{4.8cm} L{5cm}}
\toprule
\multicolumn{2}{c}{Notations}\\
$\set{S}{} = \setted{a, b, \ldots}$ 
    & Notation for a set $\set{S}{}$ of elements\\
$\tuple{T}{} = \tupled{a, b, \ldots}$ 
    & Notation for a tuple $\tuple{T}{}$ of elements\\
\midrule
\multicolumn{2}{c}{Properties and Classes}\\
$P$                 
    & Property (attribute or reference) \\
$\metamodelinstances{P} = \setted{p_1, p_2, \dots}$     
    & Property values of a property $P$ \\
$\class{C}{} = \tupled{P_1, \dots, P_n}$
    & Class \\
$\metamodelinstances{C} = \setted{o = \tupled{p_1, \dots, p_n} \mid p_i \in \metamodelinstances{P_i}}$ 
    & Instances (objects) of a class $\class{C}{}$\\
$\object{o}{} \in \metamodelinstances{C}$
    & Object of a class $\class{C}{}$ \\
\midrule
\multicolumn{2}{c}{(Meta-)Models}\\
$\metamodel{M}{} = \setted{\class{C}{1}, \dots, \class{C}{m}}$
    & Metamodel\\
$\metamodelinstances{M} = \setted{m \mid m \subseteq \bigcup_{\class{C}{} \in \metamodel{M}{}} \metamodelinstances{C}}$
    & Instances of a metamodel\\
$\metamodelset{M} = \setted{\metamodel{M}{1}, \dots, \metamodel{M}{k}}$
    & Set of metamodels\\
$\metamodelinstances{\metamodelset{M}} = \setted{ \setted{\model{m}{1}, \dots, \model{m}{k}} \mid \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}}$
    & Instances of a metamodel set $\metamodelset{M}$\\
$\model{m}{} \in \metamodelinstances{M}$
    & Model of metamodel $\metamodel{M}{}$\\
$\modelset{m} \in \metamodelinstances{\metamodelset{M}}$
    & Model set of a metamodel set $\metamodelset{M}$\\
\bottomrule
\end{tabular}
\caption{Notations and elements}
\label{tab:notation}
\end{table}

\subsection{Notation}

We usually denote variables representing sets of any kinds of elements in blackboard bold font $\set{S}{}$, those representing tuples of any kinds of elements in gothic font $\tuple{T}{}$ and write the elements of a tuple in angle brackets $\tupled{a, b, \dots}$.

We define the following operators for concise expressions on tuples, which basically allow to treat tuples as sets wherever necessary:
For a tuple $\tuple{t}{} = \tupled{t_1, \dots, t_n}$, we say that:
\begin{align*}
    \formulaskip &
    t' \in \tuple{t}{} \equivalentperdefinition \exists i \in \setted{1, \dots, n} : t' = t_i
\end{align*}
For two tuples $\tuple{t}{1}, \tuple{t}{2}$, we define:
\begin{align*}
    \formulaskip &
    \tuple{t}{1} \cap \tuple{t}{2} := \setted{t \mid t \in \tuple{t}{1} \land t \in \tuple{t}{2}}
\end{align*}
Note that the intersection of tuples is not a tuple but a set, because we are only interested in getting the elements contained in both tuples but do not need to match their order.

Furthermore, we use variables of uppercase letters for all elements at the metamodel level, such as $\metamodel{M}{}$ for a metamodel or $\class{C}{}$ for a class, whereas we use lowercase letters for all elements at the model level, such as $\model{m}{}$ for a model and $\object{o}{}$ for an object.
If not further specified, we use the same indices on related elements on the metamodel and the model level, such as model $\model{m}{1}$ being an instance of metamodel $\metamodel{M}{1}$.

\subsection{Elements}

In general, we consider metamodels as a composition of meta-classes, which in turn are composed of properties representing attributes or references.
Models instantiate metamodel and are composed of objects, which are instances of meta-classes and in turn consist of property values, which instantiate properties.

We denote \emph{properties}, which are the information a meta-class consists of, such as attributes or references, as $P$ and the \emph{property values} as instances of a property as $\metamodelinstances{P} = \setted{p_1, p_2, \dots}$ of property $P$. 
We do not need to further differentiate different types of properties into attributes and references, like it is done in other formalizations, such as the OCL standard~\cite[A.1]{ocl} or the thesis of \citeauthor{kramer2017a}~\cite[2.3.2]{kramer2017a}.

We denote \emph{meta-classes}, in the following shortly called \emph{classes}, as tuples of properties $\class{C}{} = \tupled{P_1, \dots, P_n}$. 
Instances of a \emph{class} are \emph{objects}, each being a tuple of instances of the properties of the class and we denote all instances of a class $\class{C}{}$ as $\metamodelinstances{C} = \setted{o = \tupled{p_1, \dots, p_n} \mid p_i \in \metamodelinstances{P_i}}$.

We denote a metamodel $\metamodel{M}{} = \setted{\class{C}{1}, \dots, \class{C}{m}}$ as a finite set of classes.
The instances of a metamodel are sets of objects $\metamodelinstances{M} = \setted{m \mid m \subseteq \bigcup_{\class{C}{} \in \metamodel{M}{}} \metamodelinstances{C}}$.
Each instance, denoted as a \emph{model}, is a finite set of objects that instantiate the classes in the metamodel.
For a set of metamodels $\metamodelset{M} = \setted{\metamodel{M}{1}, \dots, \metamodel{M}{k}}$, we denote the set that contains all sets of instances of that metamodels as $\metamodelinstances{\metamodelset{M}} = \setted{ \setted{\model{m}{1}, \dots, \model{m}{k}} \mid \model{m}{i} \in \metamodelinstances{\metamodel{M}{i}}}$.

%We use an extensional definition of metamodels, models and consistency relations, i.e. we enumerate the valid instances of a metamodel or the consistent pairs of models instead of intensionally describing how to derive them.
%Although actual modeling frameworks, such as EMF, and languages, such as QVT-R, use intensional specifications, the mathematical foundations of our approach are easier to describe in an extensional specification.
%However, expressiveness is the same, since an intensional specification can be, at least virtually, transformed into an extensional specification by enumerating all elements that fulfill the intensional specification.

%In general, we denote elements at the metamodel level with upper case letters and elements at the instance level with lower case letters. Tuples are denoted in angle brackets $\tupled{t}$.

%We denote models with lower case letters and indices $\model[1]{M}, \model[2]{M}, \ldots$.
%We denote elements of a model, such as meta-class instances, attributes values or reference instances, with lower case letters $e_1, e_2, f_2, f_2, \ldots$.

%We denote the instantiation relation between metamodels and models, as well as metamodel elements and model elements with instance sets:
%$\metamodelinstances{M}$ denotes the valid instances of a $\metamodel{M}$.
%$\metamodelinstances{E}$ denotes the instances of a metamodel element $E$.



\subsection{Assumptions}

We assume models to be finite, so for each model $\model{m}{}$, we assume that $|\model{m}{}| < \infty$.
Additionally, our formalism assumes objects to be unique within a model $\model{m}{}$. 
This is already implicitly covered by the definition of $\metamodelinstances{M}$ for the instances of a metamodel $\metamodel{M}{}$. 
In practice, it is usually allowed to have the same object, i.e., an element with the same type, attribute and reference values, multiple times within the same model. 
This is, however, only a matter of identity, which we assume, without loss of generality, to be represented within the objects, whereas identity in practice is given by different objects being placed at specific places in memory.

% Our definition of models does not restrict validity of models apart from being a collection of instances of the classes in the metamodel.
% It is possible to define further constraints for metamodels that restrict their valid instances.
% We intentionally do not consider such restrictions of valid models, because even a single transformation 


Finally, we assume consistency to be defined in terms of multiple bidirectional transformation, even if more than two metamodels are related.
We already discussed in \autoref{chap:introduction} why this is a reasonable approach in comparison to defining multi-directional transformations based on complexity and available knowledge, as argued in existing work~\cite{stevens2017a, klare2018docsym}. %reasoned why it useful to consider consistency modularly by composing binary (or multiary) relations. 
%First, it is often hard enough to think about relations between two metamodels and the task of defining multiary relations would, in consequence, be overly complex.
%Additionally, domain experts often only know about the relations between some of the metamodels used to develop a system, but not about all of them, so composition of relations is mandatory~\cite{klare2018docsym}.



\todoDiss{Discuss valid models, why we do not consider them and prove that invariants + consistency relations can express any consistency relation.
A single relation can consider constraints on the single models, but combination (even within one transformation) can easily contradict constraints of a model.}

\end{copiedFrom} % SoSym MPM4CPS



\section{Types of Consistency}

Discuss which types of consistency may exist (from Ellwangen retreat), how far they can be checked and what the mismatch is between pragmatic types of consistency and their verifyability.



\section{Transformational Consistency of Multiple Models}

Compare multidirectional transformations with networks of transformations.
Refer for other consistency approaches to related work.


\section{Assumptions / Limitations}

For ease of understanding, we restrict us to binary consistency preservation rules, although one could define the same for multiary ones. 